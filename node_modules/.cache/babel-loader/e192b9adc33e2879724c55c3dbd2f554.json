{"ast":null,"code":"'use strict';\n\nvar regex = require('regex-not');\n\nvar Cache = require('fragment-cache');\n/**\n * Utils\n */\n\n\nvar utils = module.exports;\nvar cache = utils.cache = new Cache();\n/**\n * Cast `val` to an array\n * @return {Array}\n */\n\nutils.arrayify = function (val) {\n  if (!Array.isArray(val)) {\n    return [val];\n  }\n\n  return val;\n};\n/**\n * Memoize a generated regex or function\n */\n\n\nutils.memoize = function (type, pattern, options, fn) {\n  var key = utils.createKey(type + pattern, options);\n\n  if (cache.has(type, key)) {\n    return cache.get(type, key);\n  }\n\n  var val = fn(pattern, options);\n\n  if (options && options.cache === false) {\n    return val;\n  }\n\n  cache.set(type, key, val);\n  return val;\n};\n/**\n * Create the key to use for memoization. The key is generated\n * by iterating over the options and concatenating key-value pairs\n * to the pattern string.\n */\n\n\nutils.createKey = function (pattern, options) {\n  var key = pattern;\n\n  if (typeof options === 'undefined') {\n    return key;\n  }\n\n  for (var prop in options) {\n    key += ';' + prop + '=' + String(options[prop]);\n  }\n\n  return key;\n};\n/**\n * Create the regex to use for matching text\n */\n\n\nutils.createRegex = function (str) {\n  var opts = {\n    contains: true,\n    strictClose: false\n  };\n  return regex(str, opts);\n};","map":null,"metadata":{},"sourceType":"module"}