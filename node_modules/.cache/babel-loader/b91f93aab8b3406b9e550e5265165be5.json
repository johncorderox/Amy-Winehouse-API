{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar parseJson = require(\"json-parse-better-errors\");\n\nvar asyncLib = require(\"neo-async\");\n\nvar path = require(\"path\");\n\nvar _require = require(\"webpack-sources\"),\n    Source = _require.Source;\n\nvar util = require(\"util\");\n\nvar _require2 = require(\"tapable\"),\n    Tapable = _require2.Tapable,\n    SyncHook = _require2.SyncHook,\n    SyncBailHook = _require2.SyncBailHook,\n    AsyncParallelHook = _require2.AsyncParallelHook,\n    AsyncSeriesHook = _require2.AsyncSeriesHook;\n\nvar Compilation = require(\"./Compilation\");\n\nvar Stats = require(\"./Stats\");\n\nvar Watching = require(\"./Watching\");\n\nvar NormalModuleFactory = require(\"./NormalModuleFactory\");\n\nvar ContextModuleFactory = require(\"./ContextModuleFactory\");\n\nvar ResolverFactory = require(\"./ResolverFactory\");\n\nvar RequestShortener = require(\"./RequestShortener\");\n\nvar _require3 = require(\"./util/identifier\"),\n    makePathsRelative = _require3.makePathsRelative;\n\nvar ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\n\nvar _require4 = require(\"./logging/Logger\"),\n    Logger = _require4.Logger;\n/** @typedef {import(\"../declarations/WebpackOptions\").Entry} Entry */\n\n/** @typedef {import(\"../declarations/WebpackOptions\").WebpackOptions} WebpackOptions */\n\n/**\n * @typedef {Object} CompilationParams\n * @property {NormalModuleFactory} normalModuleFactory\n * @property {ContextModuleFactory} contextModuleFactory\n * @property {Set<string>} compilationDependencies\n */\n\n\nvar Compiler = /*#__PURE__*/function (_Tapable) {\n  _inherits(Compiler, _Tapable);\n\n  var _super = _createSuper(Compiler);\n\n  function Compiler(context) {\n    var _this;\n\n    _classCallCheck(this, Compiler);\n\n    _this = _super.call(this);\n    _this.hooks = {\n      /** @type {SyncBailHook<Compilation>} */\n      shouldEmit: new SyncBailHook([\"compilation\"]),\n\n      /** @type {AsyncSeriesHook<Stats>} */\n      done: new AsyncSeriesHook([\"stats\"]),\n\n      /** @type {AsyncSeriesHook<>} */\n      additionalPass: new AsyncSeriesHook([]),\n\n      /** @type {AsyncSeriesHook<Compiler>} */\n      beforeRun: new AsyncSeriesHook([\"compiler\"]),\n\n      /** @type {AsyncSeriesHook<Compiler>} */\n      run: new AsyncSeriesHook([\"compiler\"]),\n\n      /** @type {AsyncSeriesHook<Compilation>} */\n      emit: new AsyncSeriesHook([\"compilation\"]),\n\n      /** @type {AsyncSeriesHook<string, Buffer>} */\n      assetEmitted: new AsyncSeriesHook([\"file\", \"content\"]),\n\n      /** @type {AsyncSeriesHook<Compilation>} */\n      afterEmit: new AsyncSeriesHook([\"compilation\"]),\n\n      /** @type {SyncHook<Compilation, CompilationParams>} */\n      thisCompilation: new SyncHook([\"compilation\", \"params\"]),\n\n      /** @type {SyncHook<Compilation, CompilationParams>} */\n      compilation: new SyncHook([\"compilation\", \"params\"]),\n\n      /** @type {SyncHook<NormalModuleFactory>} */\n      normalModuleFactory: new SyncHook([\"normalModuleFactory\"]),\n\n      /** @type {SyncHook<ContextModuleFactory>}  */\n      contextModuleFactory: new SyncHook([\"contextModulefactory\"]),\n\n      /** @type {AsyncSeriesHook<CompilationParams>} */\n      beforeCompile: new AsyncSeriesHook([\"params\"]),\n\n      /** @type {SyncHook<CompilationParams>} */\n      compile: new SyncHook([\"params\"]),\n\n      /** @type {AsyncParallelHook<Compilation>} */\n      make: new AsyncParallelHook([\"compilation\"]),\n\n      /** @type {AsyncSeriesHook<Compilation>} */\n      afterCompile: new AsyncSeriesHook([\"compilation\"]),\n\n      /** @type {AsyncSeriesHook<Compiler>} */\n      watchRun: new AsyncSeriesHook([\"compiler\"]),\n\n      /** @type {SyncHook<Error>} */\n      failed: new SyncHook([\"error\"]),\n\n      /** @type {SyncHook<string, string>} */\n      invalid: new SyncHook([\"filename\", \"changeTime\"]),\n\n      /** @type {SyncHook} */\n      watchClose: new SyncHook([]),\n\n      /** @type {SyncBailHook<string, string, any[]>} */\n      infrastructureLog: new SyncBailHook([\"origin\", \"type\", \"args\"]),\n      // TODO the following hooks are weirdly located here\n      // TODO move them for webpack 5\n\n      /** @type {SyncHook} */\n      environment: new SyncHook([]),\n\n      /** @type {SyncHook} */\n      afterEnvironment: new SyncHook([]),\n\n      /** @type {SyncHook<Compiler>} */\n      afterPlugins: new SyncHook([\"compiler\"]),\n\n      /** @type {SyncHook<Compiler>} */\n      afterResolvers: new SyncHook([\"compiler\"]),\n\n      /** @type {SyncBailHook<string, Entry>} */\n      entryOption: new SyncBailHook([\"context\", \"entry\"])\n    }; // TODO webpack 5 remove this\n\n    _this.hooks.infrastructurelog = _this.hooks.infrastructureLog;\n\n    _this._pluginCompat.tap(\"Compiler\", function (options) {\n      switch (options.name) {\n        case \"additional-pass\":\n        case \"before-run\":\n        case \"run\":\n        case \"emit\":\n        case \"after-emit\":\n        case \"before-compile\":\n        case \"make\":\n        case \"after-compile\":\n        case \"watch-run\":\n          options.async = true;\n          break;\n      }\n    });\n    /** @type {string=} */\n\n\n    _this.name = undefined;\n    /** @type {Compilation=} */\n\n    _this.parentCompilation = undefined;\n    /** @type {string} */\n\n    _this.outputPath = \"\";\n    _this.outputFileSystem = null;\n    _this.inputFileSystem = null;\n    /** @type {string|null} */\n\n    _this.recordsInputPath = null;\n    /** @type {string|null} */\n\n    _this.recordsOutputPath = null;\n    _this.records = {};\n    _this.removedFiles = new Set();\n    /** @type {Map<string, number>} */\n\n    _this.fileTimestamps = new Map();\n    /** @type {Map<string, number>} */\n\n    _this.contextTimestamps = new Map();\n    /** @type {ResolverFactory} */\n\n    _this.resolverFactory = new ResolverFactory();\n    _this.infrastructureLogger = undefined; // TODO remove in webpack 5\n\n    _this.resolvers = {\n      normal: {\n        plugins: util.deprecate(function (hook, fn) {\n          _this.resolverFactory.plugin(\"resolver normal\", function (resolver) {\n            resolver.plugin(hook, fn);\n          });\n        }, \"webpack: Using compiler.resolvers.normal is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver normal\", resolver => {\\n  resolver.plugin(/* … */);\\n}); instead.'),\n        apply: util.deprecate(function () {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          _this.resolverFactory.plugin(\"resolver normal\", function (resolver) {\n            resolver.apply.apply(resolver, args);\n          });\n        }, \"webpack: Using compiler.resolvers.normal is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver normal\", resolver => {\\n  resolver.apply(/* … */);\\n}); instead.')\n      },\n      loader: {\n        plugins: util.deprecate(function (hook, fn) {\n          _this.resolverFactory.plugin(\"resolver loader\", function (resolver) {\n            resolver.plugin(hook, fn);\n          });\n        }, \"webpack: Using compiler.resolvers.loader is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver loader\", resolver => {\\n  resolver.plugin(/* … */);\\n}); instead.'),\n        apply: util.deprecate(function () {\n          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n          }\n\n          _this.resolverFactory.plugin(\"resolver loader\", function (resolver) {\n            resolver.apply.apply(resolver, args);\n          });\n        }, \"webpack: Using compiler.resolvers.loader is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver loader\", resolver => {\\n  resolver.apply(/* … */);\\n}); instead.')\n      },\n      context: {\n        plugins: util.deprecate(function (hook, fn) {\n          _this.resolverFactory.plugin(\"resolver context\", function (resolver) {\n            resolver.plugin(hook, fn);\n          });\n        }, \"webpack: Using compiler.resolvers.context is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver context\", resolver => {\\n  resolver.plugin(/* … */);\\n}); instead.'),\n        apply: util.deprecate(function () {\n          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n            args[_key3] = arguments[_key3];\n          }\n\n          _this.resolverFactory.plugin(\"resolver context\", function (resolver) {\n            resolver.apply.apply(resolver, args);\n          });\n        }, \"webpack: Using compiler.resolvers.context is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver context\", resolver => {\\n  resolver.apply(/* … */);\\n}); instead.')\n      }\n    };\n    /** @type {WebpackOptions} */\n\n    _this.options =\n    /** @type {WebpackOptions} */\n    {};\n    _this.context = context;\n    _this.requestShortener = new RequestShortener(context);\n    /** @type {boolean} */\n\n    _this.running = false;\n    /** @type {boolean} */\n\n    _this.watchMode = false;\n    /** @private @type {WeakMap<Source, { sizeOnlySource: SizeOnlySource, writtenTo: Map<string, number> }>} */\n\n    _this._assetEmittingSourceCache = new WeakMap();\n    /** @private @type {Map<string, number>} */\n\n    _this._assetEmittingWrittenFiles = new Map();\n    return _this;\n  }\n  /**\n   * @param {string | (function(): string)} name name of the logger, or function called once to get the logger name\n   * @returns {Logger} a logger with that name\n   */\n\n\n  _createClass(Compiler, [{\n    key: \"getInfrastructureLogger\",\n    value: function getInfrastructureLogger(name) {\n      var _this2 = this;\n\n      if (!name) {\n        throw new TypeError(\"Compiler.getInfrastructureLogger(name) called without a name\");\n      }\n\n      return new Logger(function (type, args) {\n        if (typeof name === \"function\") {\n          name = name();\n\n          if (!name) {\n            throw new TypeError(\"Compiler.getInfrastructureLogger(name) called with a function not returning a name\");\n          }\n        }\n\n        if (_this2.hooks.infrastructureLog.call(name, type, args) === undefined) {\n          if (_this2.infrastructureLogger !== undefined) {\n            _this2.infrastructureLogger(name, type, args);\n          }\n        }\n      });\n    }\n  }, {\n    key: \"watch\",\n    value: function watch(watchOptions, handler) {\n      if (this.running) return handler(new ConcurrentCompilationError());\n      this.running = true;\n      this.watchMode = true;\n      this.fileTimestamps = new Map();\n      this.contextTimestamps = new Map();\n      this.removedFiles = new Set();\n      return new Watching(this, watchOptions, handler);\n    }\n  }, {\n    key: \"run\",\n    value: function run(callback) {\n      var _this3 = this;\n\n      if (this.running) return callback(new ConcurrentCompilationError());\n\n      var finalCallback = function finalCallback(err, stats) {\n        _this3.running = false;\n\n        if (err) {\n          _this3.hooks.failed.call(err);\n        }\n\n        if (callback !== undefined) return callback(err, stats);\n      };\n\n      var startTime = Date.now();\n      this.running = true;\n\n      var onCompiled = function onCompiled(err, compilation) {\n        if (err) return finalCallback(err);\n\n        if (_this3.hooks.shouldEmit.call(compilation) === false) {\n          var stats = new Stats(compilation);\n          stats.startTime = startTime;\n          stats.endTime = Date.now();\n\n          _this3.hooks.done.callAsync(stats, function (err) {\n            if (err) return finalCallback(err);\n            return finalCallback(null, stats);\n          });\n\n          return;\n        }\n\n        _this3.emitAssets(compilation, function (err) {\n          if (err) return finalCallback(err);\n\n          if (compilation.hooks.needAdditionalPass.call()) {\n            compilation.needAdditionalPass = true;\n\n            var _stats = new Stats(compilation);\n\n            _stats.startTime = startTime;\n            _stats.endTime = Date.now();\n\n            _this3.hooks.done.callAsync(_stats, function (err) {\n              if (err) return finalCallback(err);\n\n              _this3.hooks.additionalPass.callAsync(function (err) {\n                if (err) return finalCallback(err);\n\n                _this3.compile(onCompiled);\n              });\n            });\n\n            return;\n          }\n\n          _this3.emitRecords(function (err) {\n            if (err) return finalCallback(err);\n            var stats = new Stats(compilation);\n            stats.startTime = startTime;\n            stats.endTime = Date.now();\n\n            _this3.hooks.done.callAsync(stats, function (err) {\n              if (err) return finalCallback(err);\n              return finalCallback(null, stats);\n            });\n          });\n        });\n      };\n\n      this.hooks.beforeRun.callAsync(this, function (err) {\n        if (err) return finalCallback(err);\n\n        _this3.hooks.run.callAsync(_this3, function (err) {\n          if (err) return finalCallback(err);\n\n          _this3.readRecords(function (err) {\n            if (err) return finalCallback(err);\n\n            _this3.compile(onCompiled);\n          });\n        });\n      });\n    }\n  }, {\n    key: \"runAsChild\",\n    value: function runAsChild(callback) {\n      var _this4 = this;\n\n      this.compile(function (err, compilation) {\n        if (err) return callback(err);\n\n        _this4.parentCompilation.children.push(compilation);\n\n        var _iterator = _createForOfIteratorHelper(compilation.getAssets()),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _ref2 = _step.value;\n            var name = _ref2.name;\n            var source = _ref2.source;\n            var info = _ref2.info;\n\n            _this4.parentCompilation.emitAsset(name, source, info);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        var entries = Array.from(compilation.entrypoints.values(), function (ep) {\n          return ep.chunks;\n        }).reduce(function (array, chunks) {\n          return array.concat(chunks);\n        }, []);\n        return callback(null, entries, compilation);\n      });\n    }\n  }, {\n    key: \"purgeInputFileSystem\",\n    value: function purgeInputFileSystem() {\n      if (this.inputFileSystem && this.inputFileSystem.purge) {\n        this.inputFileSystem.purge();\n      }\n    }\n  }, {\n    key: \"emitAssets\",\n    value: function emitAssets(compilation, callback) {\n      var _this5 = this;\n\n      var outputPath;\n\n      var emitFiles = function emitFiles(err) {\n        if (err) return callback(err);\n        asyncLib.forEachLimit(compilation.getAssets(), 15, function (_ref3, callback) {\n          var file = _ref3.name,\n              source = _ref3.source;\n          var targetFile = file;\n          var queryStringIdx = targetFile.indexOf(\"?\");\n\n          if (queryStringIdx >= 0) {\n            targetFile = targetFile.substr(0, queryStringIdx);\n          }\n\n          var writeOut = function writeOut(err) {\n            if (err) return callback(err);\n\n            var targetPath = _this5.outputFileSystem.join(outputPath, targetFile); // TODO webpack 5 remove futureEmitAssets option and make it on by default\n\n\n            if (_this5.options.output.futureEmitAssets) {\n              // check if the target file has already been written by this Compiler\n              var targetFileGeneration = _this5._assetEmittingWrittenFiles.get(targetPath); // create an cache entry for this Source if not already existing\n\n\n              var cacheEntry = _this5._assetEmittingSourceCache.get(source);\n\n              if (cacheEntry === undefined) {\n                cacheEntry = {\n                  sizeOnlySource: undefined,\n                  writtenTo: new Map()\n                };\n\n                _this5._assetEmittingSourceCache.set(source, cacheEntry);\n              } // if the target file has already been written\n\n\n              if (targetFileGeneration !== undefined) {\n                // check if the Source has been written to this target file\n                var writtenGeneration = cacheEntry.writtenTo.get(targetPath);\n\n                if (writtenGeneration === targetFileGeneration) {\n                  // if yes, we skip writing the file\n                  // as it's already there\n                  // (we assume one doesn't remove files while the Compiler is running)\n                  compilation.updateAsset(file, cacheEntry.sizeOnlySource, {\n                    size: cacheEntry.sizeOnlySource.size()\n                  });\n                  return callback();\n                }\n              } // TODO webpack 5: if info.immutable check if file already exists in output\n              // skip emitting if it's already there\n              // get the binary (Buffer) content from the Source\n\n              /** @type {Buffer} */\n\n\n              var content;\n\n              if (typeof source.buffer === \"function\") {\n                content = source.buffer();\n              } else {\n                var bufferOrString = source.source();\n\n                if (Buffer.isBuffer(bufferOrString)) {\n                  content = bufferOrString;\n                } else {\n                  content = Buffer.from(bufferOrString, \"utf8\");\n                }\n              } // Create a replacement resource which only allows to ask for size\n              // This allows to GC all memory allocated by the Source\n              // (expect when the Source is stored in any other cache)\n\n\n              cacheEntry.sizeOnlySource = new SizeOnlySource(content.length);\n              compilation.updateAsset(file, cacheEntry.sizeOnlySource, {\n                size: content.length\n              }); // Write the file to output file system\n\n              _this5.outputFileSystem.writeFile(targetPath, content, function (err) {\n                if (err) return callback(err); // information marker that the asset has been emitted\n\n                compilation.emittedAssets.add(file); // cache the information that the Source has been written to that location\n\n                var newGeneration = targetFileGeneration === undefined ? 1 : targetFileGeneration + 1;\n                cacheEntry.writtenTo.set(targetPath, newGeneration);\n\n                _this5._assetEmittingWrittenFiles.set(targetPath, newGeneration);\n\n                _this5.hooks.assetEmitted.callAsync(file, content, callback);\n              });\n            } else {\n              if (source.existsAt === targetPath) {\n                source.emitted = false;\n                return callback();\n              }\n\n              var _content = source.source();\n\n              if (!Buffer.isBuffer(_content)) {\n                _content = Buffer.from(_content, \"utf8\");\n              }\n\n              source.existsAt = targetPath;\n              source.emitted = true;\n\n              _this5.outputFileSystem.writeFile(targetPath, _content, function (err) {\n                if (err) return callback(err);\n\n                _this5.hooks.assetEmitted.callAsync(file, _content, callback);\n              });\n            }\n          };\n\n          if (targetFile.match(/\\/|\\\\/)) {\n            var dir = path.dirname(targetFile);\n\n            _this5.outputFileSystem.mkdirp(_this5.outputFileSystem.join(outputPath, dir), writeOut);\n          } else {\n            writeOut();\n          }\n        }, function (err) {\n          if (err) return callback(err);\n\n          _this5.hooks.afterEmit.callAsync(compilation, function (err) {\n            if (err) return callback(err);\n            return callback();\n          });\n        });\n      };\n\n      this.hooks.emit.callAsync(compilation, function (err) {\n        if (err) return callback(err);\n        outputPath = compilation.getPath(_this5.outputPath);\n\n        _this5.outputFileSystem.mkdirp(outputPath, emitFiles);\n      });\n    }\n  }, {\n    key: \"emitRecords\",\n    value: function emitRecords(callback) {\n      var _this6 = this;\n\n      if (!this.recordsOutputPath) return callback();\n      var idx1 = this.recordsOutputPath.lastIndexOf(\"/\");\n      var idx2 = this.recordsOutputPath.lastIndexOf(\"\\\\\");\n      var recordsOutputPathDirectory = null;\n\n      if (idx1 > idx2) {\n        recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx1);\n      } else if (idx1 < idx2) {\n        recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx2);\n      }\n\n      var writeFile = function writeFile() {\n        _this6.outputFileSystem.writeFile(_this6.recordsOutputPath, JSON.stringify(_this6.records, undefined, 2), callback);\n      };\n\n      if (!recordsOutputPathDirectory) {\n        return writeFile();\n      }\n\n      this.outputFileSystem.mkdirp(recordsOutputPathDirectory, function (err) {\n        if (err) return callback(err);\n        writeFile();\n      });\n    }\n  }, {\n    key: \"readRecords\",\n    value: function readRecords(callback) {\n      var _this7 = this;\n\n      if (!this.recordsInputPath) {\n        this.records = {};\n        return callback();\n      }\n\n      this.inputFileSystem.stat(this.recordsInputPath, function (err) {\n        // It doesn't exist\n        // We can ignore this.\n        if (err) return callback();\n\n        _this7.inputFileSystem.readFile(_this7.recordsInputPath, function (err, content) {\n          if (err) return callback(err);\n\n          try {\n            _this7.records = parseJson(content.toString(\"utf-8\"));\n          } catch (e) {\n            e.message = \"Cannot parse records: \" + e.message;\n            return callback(e);\n          }\n\n          return callback();\n        });\n      });\n    }\n  }, {\n    key: \"createChildCompiler\",\n    value: function createChildCompiler(compilation, compilerName, compilerIndex, outputOptions, plugins) {\n      var childCompiler = new Compiler(this.context);\n\n      if (Array.isArray(plugins)) {\n        var _iterator2 = _createForOfIteratorHelper(plugins),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var plugin = _step2.value;\n            plugin.apply(childCompiler);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      for (var name in this.hooks) {\n        if (![\"make\", \"compile\", \"emit\", \"afterEmit\", \"invalid\", \"done\", \"thisCompilation\"].includes(name)) {\n          if (childCompiler.hooks[name]) {\n            childCompiler.hooks[name].taps = this.hooks[name].taps.slice();\n          }\n        }\n      }\n\n      childCompiler.name = compilerName;\n      childCompiler.outputPath = this.outputPath;\n      childCompiler.inputFileSystem = this.inputFileSystem;\n      childCompiler.outputFileSystem = null;\n      childCompiler.resolverFactory = this.resolverFactory;\n      childCompiler.fileTimestamps = this.fileTimestamps;\n      childCompiler.contextTimestamps = this.contextTimestamps;\n      var relativeCompilerName = makePathsRelative(this.context, compilerName);\n\n      if (!this.records[relativeCompilerName]) {\n        this.records[relativeCompilerName] = [];\n      }\n\n      if (this.records[relativeCompilerName][compilerIndex]) {\n        childCompiler.records = this.records[relativeCompilerName][compilerIndex];\n      } else {\n        this.records[relativeCompilerName].push(childCompiler.records = {});\n      }\n\n      childCompiler.options = Object.create(this.options);\n      childCompiler.options.output = Object.create(childCompiler.options.output);\n\n      for (var _name in outputOptions) {\n        childCompiler.options.output[_name] = outputOptions[_name];\n      }\n\n      childCompiler.parentCompilation = compilation;\n      compilation.hooks.childCompiler.call(childCompiler, compilerName, compilerIndex);\n      return childCompiler;\n    }\n  }, {\n    key: \"isChild\",\n    value: function isChild() {\n      return !!this.parentCompilation;\n    }\n  }, {\n    key: \"createCompilation\",\n    value: function createCompilation() {\n      return new Compilation(this);\n    }\n  }, {\n    key: \"newCompilation\",\n    value: function newCompilation(params) {\n      var compilation = this.createCompilation();\n      compilation.fileTimestamps = this.fileTimestamps;\n      compilation.contextTimestamps = this.contextTimestamps;\n      compilation.name = this.name;\n      compilation.records = this.records;\n      compilation.compilationDependencies = params.compilationDependencies;\n      this.hooks.thisCompilation.call(compilation, params);\n      this.hooks.compilation.call(compilation, params);\n      return compilation;\n    }\n  }, {\n    key: \"createNormalModuleFactory\",\n    value: function createNormalModuleFactory() {\n      var normalModuleFactory = new NormalModuleFactory(this.options.context, this.resolverFactory, this.options.module || {});\n      this.hooks.normalModuleFactory.call(normalModuleFactory);\n      return normalModuleFactory;\n    }\n  }, {\n    key: \"createContextModuleFactory\",\n    value: function createContextModuleFactory() {\n      var contextModuleFactory = new ContextModuleFactory(this.resolverFactory);\n      this.hooks.contextModuleFactory.call(contextModuleFactory);\n      return contextModuleFactory;\n    }\n  }, {\n    key: \"newCompilationParams\",\n    value: function newCompilationParams() {\n      var params = {\n        normalModuleFactory: this.createNormalModuleFactory(),\n        contextModuleFactory: this.createContextModuleFactory(),\n        compilationDependencies: new Set()\n      };\n      return params;\n    }\n  }, {\n    key: \"compile\",\n    value: function compile(callback) {\n      var _this8 = this;\n\n      var params = this.newCompilationParams();\n      this.hooks.beforeCompile.callAsync(params, function (err) {\n        if (err) return callback(err);\n\n        _this8.hooks.compile.call(params);\n\n        var compilation = _this8.newCompilation(params);\n\n        _this8.hooks.make.callAsync(compilation, function (err) {\n          if (err) return callback(err);\n          compilation.finish(function (err) {\n            if (err) return callback(err);\n            compilation.seal(function (err) {\n              if (err) return callback(err);\n\n              _this8.hooks.afterCompile.callAsync(compilation, function (err) {\n                if (err) return callback(err);\n                return callback(null, compilation);\n              });\n            });\n          });\n        });\n      });\n    }\n  }]);\n\n  return Compiler;\n}(Tapable);\n\nmodule.exports = Compiler;\n\nvar SizeOnlySource = /*#__PURE__*/function (_Source) {\n  _inherits(SizeOnlySource, _Source);\n\n  var _super2 = _createSuper(SizeOnlySource);\n\n  function SizeOnlySource(size) {\n    var _this9;\n\n    _classCallCheck(this, SizeOnlySource);\n\n    _this9 = _super2.call(this);\n    _this9._size = size;\n    return _this9;\n  }\n\n  _createClass(SizeOnlySource, [{\n    key: \"_error\",\n    value: function _error() {\n      return new Error(\"Content and Map of this Source is no longer available (only size() is supported)\");\n    }\n  }, {\n    key: \"size\",\n    value: function size() {\n      return this._size;\n    }\n    /**\n     * @param {any} options options\n     * @returns {string} the source\n     */\n\n  }, {\n    key: \"source\",\n    value: function source(options) {\n      throw this._error();\n    }\n  }, {\n    key: \"node\",\n    value: function node() {\n      throw this._error();\n    }\n  }, {\n    key: \"listMap\",\n    value: function listMap() {\n      throw this._error();\n    }\n  }, {\n    key: \"map\",\n    value: function map() {\n      throw this._error();\n    }\n  }, {\n    key: \"listNode\",\n    value: function listNode() {\n      throw this._error();\n    }\n  }, {\n    key: \"updateHash\",\n    value: function updateHash() {\n      throw this._error();\n    }\n  }]);\n\n  return SizeOnlySource;\n}(Source);","map":null,"metadata":{},"sourceType":"module"}