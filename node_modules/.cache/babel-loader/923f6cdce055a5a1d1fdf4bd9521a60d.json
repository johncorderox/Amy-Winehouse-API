{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar fs = require(\"fs\");\n\nvar path = require(\"path\");\n\nvar mkdirp = require(\"mkdirp\");\n\nvar _require = require(\"chrome-trace-event\"),\n    Tracer = _require.Tracer;\n\nvar validateOptions = require(\"schema-utils\");\n\nvar schema = require(\"../../schemas/plugins/debug/ProfilingPlugin.json\");\n/** @typedef {import(\"../../declarations/plugins/debug/ProfilingPlugin\").ProfilingPluginOptions} ProfilingPluginOptions */\n\n\nvar inspector = undefined;\n\ntry {\n  // eslint-disable-next-line node/no-unsupported-features/node-builtins\n  inspector = require(\"inspector\");\n} catch (e) {\n  console.log(\"Unable to CPU profile in < node 8.0\");\n}\n\nvar Profiler = /*#__PURE__*/function () {\n  function Profiler(inspector) {\n    _classCallCheck(this, Profiler);\n\n    this.session = undefined;\n    this.inspector = inspector;\n  }\n\n  _createClass(Profiler, [{\n    key: \"hasSession\",\n    value: function hasSession() {\n      return this.session !== undefined;\n    }\n  }, {\n    key: \"startProfiling\",\n    value: function startProfiling() {\n      if (this.inspector === undefined) {\n        return Promise.resolve();\n      }\n\n      try {\n        this.session = new inspector.Session();\n        this.session.connect();\n      } catch (_) {\n        this.session = undefined;\n        return Promise.resolve();\n      }\n\n      return Promise.all([this.sendCommand(\"Profiler.setSamplingInterval\", {\n        interval: 100\n      }), this.sendCommand(\"Profiler.enable\"), this.sendCommand(\"Profiler.start\")]);\n    }\n  }, {\n    key: \"sendCommand\",\n    value: function sendCommand(method, params) {\n      var _this = this;\n\n      if (this.hasSession()) {\n        return new Promise(function (res, rej) {\n          return _this.session.post(method, params, function (err, params) {\n            if (err !== null) {\n              rej(err);\n            } else {\n              res(params);\n            }\n          });\n        });\n      } else {\n        return Promise.resolve();\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.hasSession()) {\n        this.session.disconnect();\n      }\n\n      return Promise.resolve();\n    }\n  }, {\n    key: \"stopProfiling\",\n    value: function stopProfiling() {\n      return this.sendCommand(\"Profiler.stop\");\n    }\n  }]);\n\n  return Profiler;\n}();\n/**\n * an object that wraps Tracer and Profiler with a counter\n * @typedef {Object} Trace\n * @property {Tracer} trace instance of Tracer\n * @property {number} counter Counter\n * @property {Profiler} profiler instance of Profiler\n * @property {Function} end the end function\n */\n\n/**\n * @param {string} outputPath The location where to write the log.\n * @returns {Trace} The trace object\n */\n\n\nvar createTrace = function createTrace(outputPath) {\n  var trace = new Tracer({\n    noStream: true\n  });\n  var profiler = new Profiler(inspector);\n\n  if (/\\/|\\\\/.test(outputPath)) {\n    var dirPath = path.dirname(outputPath);\n    mkdirp.sync(dirPath);\n  }\n\n  var fsStream = fs.createWriteStream(outputPath);\n  var counter = 0;\n  trace.pipe(fsStream); // These are critical events that need to be inserted so that tools like\n  // chrome dev tools can load the profile.\n\n  trace.instantEvent({\n    name: \"TracingStartedInPage\",\n    id: ++counter,\n    cat: [\"disabled-by-default-devtools.timeline\"],\n    args: {\n      data: {\n        sessionId: \"-1\",\n        page: \"0xfff\",\n        frames: [{\n          frame: \"0xfff\",\n          url: \"webpack\",\n          name: \"\"\n        }]\n      }\n    }\n  });\n  trace.instantEvent({\n    name: \"TracingStartedInBrowser\",\n    id: ++counter,\n    cat: [\"disabled-by-default-devtools.timeline\"],\n    args: {\n      data: {\n        sessionId: \"-1\"\n      }\n    }\n  });\n  return {\n    trace: trace,\n    counter: counter,\n    profiler: profiler,\n    end: function end(callback) {\n      // Wait until the write stream finishes.\n      fsStream.on(\"finish\", function () {\n        callback();\n      }); // Tear down the readable trace stream.\n\n      trace.push(null);\n    }\n  };\n};\n\nvar pluginName = \"ProfilingPlugin\";\n\nvar ProfilingPlugin = /*#__PURE__*/function () {\n  /**\n   * @param {ProfilingPluginOptions=} opts options object\n   */\n  function ProfilingPlugin(opts) {\n    _classCallCheck(this, ProfilingPlugin);\n\n    validateOptions(schema, opts || {}, \"Profiling plugin\");\n    opts = opts || {};\n    this.outputPath = opts.outputPath || \"events.json\";\n  }\n\n  _createClass(ProfilingPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var tracer = createTrace(this.outputPath);\n      tracer.profiler.startProfiling(); // Compiler Hooks\n\n      Object.keys(compiler.hooks).forEach(function (hookName) {\n        compiler.hooks[hookName].intercept(makeInterceptorFor(\"Compiler\", tracer)(hookName));\n      });\n      Object.keys(compiler.resolverFactory.hooks).forEach(function (hookName) {\n        compiler.resolverFactory.hooks[hookName].intercept(makeInterceptorFor(\"Resolver\", tracer)(hookName));\n      });\n      compiler.hooks.compilation.tap(pluginName, function (compilation, _ref) {\n        var normalModuleFactory = _ref.normalModuleFactory,\n            contextModuleFactory = _ref.contextModuleFactory;\n        interceptAllHooksFor(compilation, tracer, \"Compilation\");\n        interceptAllHooksFor(normalModuleFactory, tracer, \"Normal Module Factory\");\n        interceptAllHooksFor(contextModuleFactory, tracer, \"Context Module Factory\");\n        interceptAllParserHooks(normalModuleFactory, tracer);\n        interceptTemplateInstancesFrom(compilation, tracer);\n      }); // We need to write out the CPU profile when we are all done.\n\n      compiler.hooks.done.tapAsync({\n        name: pluginName,\n        stage: Infinity\n      }, function (stats, callback) {\n        tracer.profiler.stopProfiling().then(function (parsedResults) {\n          if (parsedResults === undefined) {\n            tracer.profiler.destroy();\n            tracer.trace.flush();\n            tracer.end(callback);\n            return;\n          }\n\n          var cpuStartTime = parsedResults.profile.startTime;\n          var cpuEndTime = parsedResults.profile.endTime;\n          tracer.trace.completeEvent({\n            name: \"TaskQueueManager::ProcessTaskFromWorkQueue\",\n            id: ++tracer.counter,\n            cat: [\"toplevel\"],\n            ts: cpuStartTime,\n            args: {\n              src_file: \"../../ipc/ipc_moji_bootstrap.cc\",\n              src_func: \"Accept\"\n            }\n          });\n          tracer.trace.completeEvent({\n            name: \"EvaluateScript\",\n            id: ++tracer.counter,\n            cat: [\"devtools.timeline\"],\n            ts: cpuStartTime,\n            dur: cpuEndTime - cpuStartTime,\n            args: {\n              data: {\n                url: \"webpack\",\n                lineNumber: 1,\n                columnNumber: 1,\n                frame: \"0xFFF\"\n              }\n            }\n          });\n          tracer.trace.instantEvent({\n            name: \"CpuProfile\",\n            id: ++tracer.counter,\n            cat: [\"disabled-by-default-devtools.timeline\"],\n            ts: cpuEndTime,\n            args: {\n              data: {\n                cpuProfile: parsedResults.profile\n              }\n            }\n          });\n          tracer.profiler.destroy();\n          tracer.trace.flush();\n          tracer.end(callback);\n        });\n      });\n    }\n  }]);\n\n  return ProfilingPlugin;\n}();\n\nvar interceptTemplateInstancesFrom = function interceptTemplateInstancesFrom(compilation, tracer) {\n  var mainTemplate = compilation.mainTemplate,\n      chunkTemplate = compilation.chunkTemplate,\n      hotUpdateChunkTemplate = compilation.hotUpdateChunkTemplate,\n      moduleTemplates = compilation.moduleTemplates;\n  var javascript = moduleTemplates.javascript,\n      webassembly = moduleTemplates.webassembly;\n  [{\n    instance: mainTemplate,\n    name: \"MainTemplate\"\n  }, {\n    instance: chunkTemplate,\n    name: \"ChunkTemplate\"\n  }, {\n    instance: hotUpdateChunkTemplate,\n    name: \"HotUpdateChunkTemplate\"\n  }, {\n    instance: javascript,\n    name: \"JavaScriptModuleTemplate\"\n  }, {\n    instance: webassembly,\n    name: \"WebAssemblyModuleTemplate\"\n  }].forEach(function (templateObject) {\n    Object.keys(templateObject.instance.hooks).forEach(function (hookName) {\n      templateObject.instance.hooks[hookName].intercept(makeInterceptorFor(templateObject.name, tracer)(hookName));\n    });\n  });\n};\n\nvar interceptAllHooksFor = function interceptAllHooksFor(instance, tracer, logLabel) {\n  if (Reflect.has(instance, \"hooks\")) {\n    Object.keys(instance.hooks).forEach(function (hookName) {\n      instance.hooks[hookName].intercept(makeInterceptorFor(logLabel, tracer)(hookName));\n    });\n  }\n};\n\nvar interceptAllParserHooks = function interceptAllParserHooks(moduleFactory, tracer) {\n  var moduleTypes = [\"javascript/auto\", \"javascript/dynamic\", \"javascript/esm\", \"json\", \"webassembly/experimental\"];\n  moduleTypes.forEach(function (moduleType) {\n    moduleFactory.hooks.parser[\"for\"](moduleType).tap(\"ProfilingPlugin\", function (parser, parserOpts) {\n      interceptAllHooksFor(parser, tracer, \"Parser\");\n    });\n  });\n};\n\nvar makeInterceptorFor = function makeInterceptorFor(instance, tracer) {\n  return function (hookName) {\n    return {\n      register: function register(_ref2) {\n        var name = _ref2.name,\n            type = _ref2.type,\n            context = _ref2.context,\n            fn = _ref2.fn;\n        var newFn = makeNewProfiledTapFn(hookName, tracer, {\n          name: name,\n          type: type,\n          fn: fn\n        });\n        return {\n          name: name,\n          type: type,\n          context: context,\n          fn: newFn\n        };\n      }\n    };\n  };\n}; // TODO improve typing\n\n/** @typedef {(...args: TODO[]) => void | Promise<TODO>} PluginFunction */\n\n/**\n * @param {string} hookName Name of the hook to profile.\n * @param {Trace} tracer The trace object.\n * @param {object} options Options for the profiled fn.\n * @param {string} options.name Plugin name\n * @param {string} options.type Plugin type (sync | async | promise)\n * @param {PluginFunction} options.fn Plugin function\n * @returns {PluginFunction} Chainable hooked function.\n */\n\n\nvar makeNewProfiledTapFn = function makeNewProfiledTapFn(hookName, tracer, _ref3) {\n  var name = _ref3.name,\n      type = _ref3.type,\n      fn = _ref3.fn;\n  var defaultCategory = [\"blink.user_timing\"];\n\n  switch (type) {\n    case \"promise\":\n      return function () {\n        var id = ++tracer.counter;\n        tracer.trace.begin({\n          name: name,\n          id: id,\n          cat: defaultCategory\n        });\n        var promise =\n        /** @type {Promise<*>} */\n        fn.apply(void 0, arguments);\n        return promise.then(function (r) {\n          tracer.trace.end({\n            name: name,\n            id: id,\n            cat: defaultCategory\n          });\n          return r;\n        });\n      };\n\n    case \"async\":\n      return function () {\n        var id = ++tracer.counter;\n        tracer.trace.begin({\n          name: name,\n          id: id,\n          cat: defaultCategory\n        });\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        var callback = args.pop();\n        fn.apply(void 0, args.concat([function () {\n          tracer.trace.end({\n            name: name,\n            id: id,\n            cat: defaultCategory\n          });\n          callback.apply(void 0, arguments);\n        }]));\n      };\n\n    case \"sync\":\n      return function () {\n        var id = ++tracer.counter; // Do not instrument ourself due to the CPU\n        // profile needing to be the last event in the trace.\n\n        if (name === pluginName) {\n          return fn.apply(void 0, arguments);\n        }\n\n        tracer.trace.begin({\n          name: name,\n          id: id,\n          cat: defaultCategory\n        });\n        var r;\n\n        try {\n          r = fn.apply(void 0, arguments);\n        } catch (error) {\n          tracer.trace.end({\n            name: name,\n            id: id,\n            cat: defaultCategory\n          });\n          throw error;\n        }\n\n        tracer.trace.end({\n          name: name,\n          id: id,\n          cat: defaultCategory\n        });\n        return r;\n      };\n\n    default:\n      break;\n  }\n};\n\nmodule.exports = ProfilingPlugin;\nmodule.exports.Profiler = Profiler;","map":null,"metadata":{},"sourceType":"module"}