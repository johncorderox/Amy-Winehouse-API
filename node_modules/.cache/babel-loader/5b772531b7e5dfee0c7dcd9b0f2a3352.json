{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar AMDRequireItemDependency = require(\"./AMDRequireItemDependency\");\n\nvar AMDRequireContextDependency = require(\"./AMDRequireContextDependency\");\n\nvar ConstDependency = require(\"./ConstDependency\");\n\nvar AMDDefineDependency = require(\"./AMDDefineDependency\");\n\nvar AMDRequireArrayDependency = require(\"./AMDRequireArrayDependency\");\n\nvar LocalModuleDependency = require(\"./LocalModuleDependency\");\n\nvar ContextDependencyHelpers = require(\"./ContextDependencyHelpers\");\n\nvar LocalModulesHelpers = require(\"./LocalModulesHelpers\");\n\nvar isBoundFunctionExpression = function isBoundFunctionExpression(expr) {\n  if (expr.type !== \"CallExpression\") return false;\n  if (expr.callee.type !== \"MemberExpression\") return false;\n  if (expr.callee.computed) return false;\n  if (expr.callee.object.type !== \"FunctionExpression\") return false;\n  if (expr.callee.property.type !== \"Identifier\") return false;\n  if (expr.callee.property.name !== \"bind\") return false;\n  return true;\n};\n\nvar isUnboundFunctionExpression = function isUnboundFunctionExpression(expr) {\n  if (expr.type === \"FunctionExpression\") return true;\n  if (expr.type === \"ArrowFunctionExpression\") return true;\n  return false;\n};\n\nvar isCallable = function isCallable(expr) {\n  if (isUnboundFunctionExpression(expr)) return true;\n  if (isBoundFunctionExpression(expr)) return true;\n  return false;\n};\n\nvar AMDDefineDependencyParserPlugin = /*#__PURE__*/function () {\n  function AMDDefineDependencyParserPlugin(options) {\n    _classCallCheck(this, AMDDefineDependencyParserPlugin);\n\n    this.options = options;\n  }\n\n  _createClass(AMDDefineDependencyParserPlugin, [{\n    key: \"apply\",\n    value: function apply(parser) {\n      parser.hooks.call[\"for\"](\"define\").tap(\"AMDDefineDependencyParserPlugin\", this.processCallDefine.bind(this, parser));\n    }\n  }, {\n    key: \"processArray\",\n    value: function processArray(parser, expr, param, identifiers, namedModule) {\n      var _this = this;\n\n      if (param.isArray()) {\n        param.items.forEach(function (param, idx) {\n          if (param.isString() && [\"require\", \"module\", \"exports\"].includes(param.string)) identifiers[idx] = param.string;\n\n          var result = _this.processItem(parser, expr, param, namedModule);\n\n          if (result === undefined) {\n            _this.processContext(parser, expr, param);\n          }\n        });\n        return true;\n      } else if (param.isConstArray()) {\n        var deps = [];\n        param.array.forEach(function (request, idx) {\n          var dep;\n          var localModule;\n\n          if (request === \"require\") {\n            identifiers[idx] = request;\n            dep = \"__webpack_require__\";\n          } else if ([\"exports\", \"module\"].includes(request)) {\n            identifiers[idx] = request;\n            dep = request;\n          } else if (localModule = LocalModulesHelpers.getLocalModule(parser.state, request)) {\n            dep = new LocalModuleDependency(localModule, undefined, false);\n            dep.loc = expr.loc;\n            parser.state.current.addDependency(dep);\n          } else {\n            dep = _this.newRequireItemDependency(request);\n            dep.loc = expr.loc;\n            dep.optional = !!parser.scope.inTry;\n            parser.state.current.addDependency(dep);\n          }\n\n          deps.push(dep);\n        });\n        var dep = this.newRequireArrayDependency(deps, param.range);\n        dep.loc = expr.loc;\n        dep.optional = !!parser.scope.inTry;\n        parser.state.current.addDependency(dep);\n        return true;\n      }\n    }\n  }, {\n    key: \"processItem\",\n    value: function processItem(parser, expr, param, namedModule) {\n      var _this2 = this;\n\n      if (param.isConditional()) {\n        param.options.forEach(function (param) {\n          var result = _this2.processItem(parser, expr, param);\n\n          if (result === undefined) {\n            _this2.processContext(parser, expr, param);\n          }\n        });\n        return true;\n      } else if (param.isString()) {\n        var dep, localModule;\n\n        if (param.string === \"require\") {\n          dep = new ConstDependency(\"__webpack_require__\", param.range);\n        } else if ([\"require\", \"exports\", \"module\"].includes(param.string)) {\n          dep = new ConstDependency(param.string, param.range);\n        } else if (localModule = LocalModulesHelpers.getLocalModule(parser.state, param.string, namedModule)) {\n          dep = new LocalModuleDependency(localModule, param.range, false);\n        } else {\n          dep = this.newRequireItemDependency(param.string, param.range);\n        }\n\n        dep.loc = expr.loc;\n        dep.optional = !!parser.scope.inTry;\n        parser.state.current.addDependency(dep);\n        return true;\n      }\n    }\n  }, {\n    key: \"processContext\",\n    value: function processContext(parser, expr, param) {\n      var dep = ContextDependencyHelpers.create(AMDRequireContextDependency, param.range, param, expr, this.options, {}, parser);\n      if (!dep) return;\n      dep.loc = expr.loc;\n      dep.optional = !!parser.scope.inTry;\n      parser.state.current.addDependency(dep);\n      return true;\n    }\n  }, {\n    key: \"processCallDefine\",\n    value: function processCallDefine(parser, expr) {\n      var array, fn, obj, namedModule;\n\n      switch (expr.arguments.length) {\n        case 1:\n          if (isCallable(expr.arguments[0])) {\n            // define(f() {…})\n            fn = expr.arguments[0];\n          } else if (expr.arguments[0].type === \"ObjectExpression\") {\n            // define({…})\n            obj = expr.arguments[0];\n          } else {\n            // define(expr)\n            // unclear if function or object\n            obj = fn = expr.arguments[0];\n          }\n\n          break;\n\n        case 2:\n          if (expr.arguments[0].type === \"Literal\") {\n            namedModule = expr.arguments[0].value; // define(\"…\", …)\n\n            if (isCallable(expr.arguments[1])) {\n              // define(\"…\", f() {…})\n              fn = expr.arguments[1];\n            } else if (expr.arguments[1].type === \"ObjectExpression\") {\n              // define(\"…\", {…})\n              obj = expr.arguments[1];\n            } else {\n              // define(\"…\", expr)\n              // unclear if function or object\n              obj = fn = expr.arguments[1];\n            }\n          } else {\n            array = expr.arguments[0];\n\n            if (isCallable(expr.arguments[1])) {\n              // define([…], f() {})\n              fn = expr.arguments[1];\n            } else if (expr.arguments[1].type === \"ObjectExpression\") {\n              // define([…], {…})\n              obj = expr.arguments[1];\n            } else {\n              // define([…], expr)\n              // unclear if function or object\n              obj = fn = expr.arguments[1];\n            }\n          }\n\n          break;\n\n        case 3:\n          // define(\"…\", […], f() {…})\n          namedModule = expr.arguments[0].value;\n          array = expr.arguments[1];\n\n          if (isCallable(expr.arguments[2])) {\n            // define(\"…\", […], f() {})\n            fn = expr.arguments[2];\n          } else if (expr.arguments[2].type === \"ObjectExpression\") {\n            // define(\"…\", […], {…})\n            obj = expr.arguments[2];\n          } else {\n            // define(\"…\", […], expr)\n            // unclear if function or object\n            obj = fn = expr.arguments[2];\n          }\n\n          break;\n\n        default:\n          return;\n      }\n\n      var fnParams = null;\n      var fnParamsOffset = 0;\n\n      if (fn) {\n        if (isUnboundFunctionExpression(fn)) {\n          fnParams = fn.params;\n        } else if (isBoundFunctionExpression(fn)) {\n          fnParams = fn.callee.object.params;\n          fnParamsOffset = fn.arguments.length - 1;\n\n          if (fnParamsOffset < 0) {\n            fnParamsOffset = 0;\n          }\n        }\n      }\n\n      var fnRenames = parser.scope.renames.createChild();\n\n      if (array) {\n        var identifiers = {};\n        var param = parser.evaluateExpression(array);\n        var result = this.processArray(parser, expr, param, identifiers, namedModule);\n        if (!result) return;\n\n        if (fnParams) {\n          fnParams = fnParams.slice(fnParamsOffset).filter(function (param, idx) {\n            if (identifiers[idx]) {\n              fnRenames.set(param.name, identifiers[idx]);\n              return false;\n            }\n\n            return true;\n          });\n        }\n      } else {\n        var _identifiers = [\"require\", \"exports\", \"module\"];\n\n        if (fnParams) {\n          fnParams = fnParams.slice(fnParamsOffset).filter(function (param, idx) {\n            if (_identifiers[idx]) {\n              fnRenames.set(param.name, _identifiers[idx]);\n              return false;\n            }\n\n            return true;\n          });\n        }\n      }\n\n      var inTry;\n\n      if (fn && isUnboundFunctionExpression(fn)) {\n        inTry = parser.scope.inTry;\n        parser.inScope(fnParams, function () {\n          parser.scope.renames = fnRenames;\n          parser.scope.inTry = inTry;\n\n          if (fn.body.type === \"BlockStatement\") {\n            parser.walkStatement(fn.body);\n          } else {\n            parser.walkExpression(fn.body);\n          }\n        });\n      } else if (fn && isBoundFunctionExpression(fn)) {\n        inTry = parser.scope.inTry;\n        parser.inScope(fn.callee.object.params.filter(function (i) {\n          return ![\"require\", \"module\", \"exports\"].includes(i.name);\n        }), function () {\n          parser.scope.renames = fnRenames;\n          parser.scope.inTry = inTry;\n\n          if (fn.callee.object.body.type === \"BlockStatement\") {\n            parser.walkStatement(fn.callee.object.body);\n          } else {\n            parser.walkExpression(fn.callee.object.body);\n          }\n        });\n\n        if (fn.arguments) {\n          parser.walkExpressions(fn.arguments);\n        }\n      } else if (fn || obj) {\n        parser.walkExpression(fn || obj);\n      }\n\n      var dep = this.newDefineDependency(expr.range, array ? array.range : null, fn ? fn.range : null, obj ? obj.range : null, namedModule ? namedModule : null);\n      dep.loc = expr.loc;\n\n      if (namedModule) {\n        dep.localModule = LocalModulesHelpers.addLocalModule(parser.state, namedModule);\n      }\n\n      parser.state.current.addDependency(dep);\n      return true;\n    }\n  }, {\n    key: \"newDefineDependency\",\n    value: function newDefineDependency(range, arrayRange, functionRange, objectRange, namedModule) {\n      return new AMDDefineDependency(range, arrayRange, functionRange, objectRange, namedModule);\n    }\n  }, {\n    key: \"newRequireArrayDependency\",\n    value: function newRequireArrayDependency(depsArray, range) {\n      return new AMDRequireArrayDependency(depsArray, range);\n    }\n  }, {\n    key: \"newRequireItemDependency\",\n    value: function newRequireItemDependency(request, range) {\n      return new AMDRequireItemDependency(request, range);\n    }\n  }]);\n\n  return AMDDefineDependencyParserPlugin;\n}();\n\nmodule.exports = AMDDefineDependencyParserPlugin;","map":null,"metadata":{},"sourceType":"module"}