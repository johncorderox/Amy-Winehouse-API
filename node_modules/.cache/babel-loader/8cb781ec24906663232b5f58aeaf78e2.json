{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar util = require(\"util\");\n\nvar _require = require(\"webpack-sources\"),\n    OriginalSource = _require.OriginalSource,\n    RawSource = _require.RawSource;\n\nvar Module = require(\"./Module\");\n\nvar AsyncDependenciesBlock = require(\"./AsyncDependenciesBlock\");\n\nvar Template = require(\"./Template\");\n\nvar contextify = require(\"./util/identifier\").contextify;\n/** @typedef {\"sync\" | \"eager\" | \"weak\" | \"async-weak\" | \"lazy\" | \"lazy-once\"} ContextMode Context mode */\n\n/** @typedef {import(\"./dependencies/ContextElementDependency\")} ContextElementDependency */\n\n/**\n * @callback ResolveDependenciesCallback\n * @param {Error=} err\n * @param {ContextElementDependency[]} dependencies\n */\n\n/**\n * @callback ResolveDependencies\n * @param {TODO} fs\n * @param {TODO} options\n * @param {ResolveDependenciesCallback} callback\n */\n\n\nvar ContextModule = /*#__PURE__*/function (_Module) {\n  _inherits(ContextModule, _Module);\n\n  var _super = _createSuper(ContextModule);\n\n  // type ContextMode = \"sync\" | \"eager\" | \"weak\" | \"async-weak\" | \"lazy\" | \"lazy-once\"\n  // type ContextOptions = { resource: string, recursive: boolean, regExp: RegExp, addon?: string, mode?: ContextMode, chunkName?: string, include?: RegExp, exclude?: RegExp, groupOptions?: Object }\n  // resolveDependencies: (fs: FS, options: ContextOptions, (err: Error?, dependencies: Dependency[]) => void) => void\n  // options: ContextOptions\n\n  /**\n   * @param {ResolveDependencies} resolveDependencies function to get dependencies in this context\n   * @param {TODO} options options object\n   */\n  function ContextModule(resolveDependencies, options) {\n    var _this;\n\n    _classCallCheck(this, ContextModule);\n\n    var resource;\n    var resourceQuery;\n    var queryIdx = options.resource.indexOf(\"?\");\n\n    if (queryIdx >= 0) {\n      resource = options.resource.substr(0, queryIdx);\n      resourceQuery = options.resource.substr(queryIdx);\n    } else {\n      resource = options.resource;\n      resourceQuery = \"\";\n    }\n\n    _this = _super.call(this, \"javascript/dynamic\", resource); // Info from Factory\n\n    _this.resolveDependencies = resolveDependencies;\n    _this.options = Object.assign({}, options, {\n      resource: resource,\n      resourceQuery: resourceQuery\n    });\n\n    if (options.resolveOptions !== undefined) {\n      _this.resolveOptions = options.resolveOptions;\n    } // Info from Build\n\n\n    _this._contextDependencies = new Set([_this.context]);\n\n    if (typeof options.mode !== \"string\") {\n      throw new Error(\"options.mode is a required option\");\n    }\n\n    _this._identifier = _this._createIdentifier();\n    return _this;\n  }\n\n  _createClass(ContextModule, [{\n    key: \"updateCacheModule\",\n    value: function updateCacheModule(module) {\n      this.resolveDependencies = module.resolveDependencies;\n      this.options = module.options;\n      this.resolveOptions = module.resolveOptions;\n    }\n  }, {\n    key: \"prettyRegExp\",\n    value: function prettyRegExp(regexString) {\n      // remove the \"/\" at the front and the beginning\n      // \"/foo/\" -> \"foo\"\n      return regexString.substring(1, regexString.length - 1);\n    }\n  }, {\n    key: \"_createIdentifier\",\n    value: function _createIdentifier() {\n      var identifier = this.context;\n\n      if (this.options.resourceQuery) {\n        identifier += \" \".concat(this.options.resourceQuery);\n      }\n\n      if (this.options.mode) {\n        identifier += \" \".concat(this.options.mode);\n      }\n\n      if (!this.options.recursive) {\n        identifier += \" nonrecursive\";\n      }\n\n      if (this.options.addon) {\n        identifier += \" \".concat(this.options.addon);\n      }\n\n      if (this.options.regExp) {\n        identifier += \" \".concat(this.options.regExp);\n      }\n\n      if (this.options.include) {\n        identifier += \" include: \".concat(this.options.include);\n      }\n\n      if (this.options.exclude) {\n        identifier += \" exclude: \".concat(this.options.exclude);\n      }\n\n      if (this.options.groupOptions) {\n        identifier += \" groupOptions: \".concat(JSON.stringify(this.options.groupOptions));\n      }\n\n      if (this.options.namespaceObject === \"strict\") {\n        identifier += \" strict namespace object\";\n      } else if (this.options.namespaceObject) {\n        identifier += \" namespace object\";\n      }\n\n      return identifier;\n    }\n  }, {\n    key: \"identifier\",\n    value: function identifier() {\n      return this._identifier;\n    }\n  }, {\n    key: \"readableIdentifier\",\n    value: function readableIdentifier(requestShortener) {\n      var identifier = requestShortener.shorten(this.context);\n\n      if (this.options.resourceQuery) {\n        identifier += \" \".concat(this.options.resourceQuery);\n      }\n\n      if (this.options.mode) {\n        identifier += \" \".concat(this.options.mode);\n      }\n\n      if (!this.options.recursive) {\n        identifier += \" nonrecursive\";\n      }\n\n      if (this.options.addon) {\n        identifier += \" \".concat(requestShortener.shorten(this.options.addon));\n      }\n\n      if (this.options.regExp) {\n        identifier += \" \".concat(this.prettyRegExp(this.options.regExp + \"\"));\n      }\n\n      if (this.options.include) {\n        identifier += \" include: \".concat(this.prettyRegExp(this.options.include + \"\"));\n      }\n\n      if (this.options.exclude) {\n        identifier += \" exclude: \".concat(this.prettyRegExp(this.options.exclude + \"\"));\n      }\n\n      if (this.options.groupOptions) {\n        var groupOptions = this.options.groupOptions;\n\n        for (var _i = 0, _Object$keys = Object.keys(groupOptions); _i < _Object$keys.length; _i++) {\n          var key = _Object$keys[_i];\n          identifier += \" \".concat(key, \": \").concat(groupOptions[key]);\n        }\n      }\n\n      if (this.options.namespaceObject === \"strict\") {\n        identifier += \" strict namespace object\";\n      } else if (this.options.namespaceObject) {\n        identifier += \" namespace object\";\n      }\n\n      return identifier;\n    }\n  }, {\n    key: \"libIdent\",\n    value: function libIdent(options) {\n      var identifier = contextify(options.context, this.context);\n\n      if (this.options.mode) {\n        identifier += \" \".concat(this.options.mode);\n      }\n\n      if (this.options.recursive) {\n        identifier += \" recursive\";\n      }\n\n      if (this.options.addon) {\n        identifier += \" \".concat(contextify(options.context, this.options.addon));\n      }\n\n      if (this.options.regExp) {\n        identifier += \" \".concat(this.prettyRegExp(this.options.regExp + \"\"));\n      }\n\n      if (this.options.include) {\n        identifier += \" include: \".concat(this.prettyRegExp(this.options.include + \"\"));\n      }\n\n      if (this.options.exclude) {\n        identifier += \" exclude: \".concat(this.prettyRegExp(this.options.exclude + \"\"));\n      }\n\n      return identifier;\n    }\n  }, {\n    key: \"needRebuild\",\n    value: function needRebuild(fileTimestamps, contextTimestamps) {\n      var ts = contextTimestamps.get(this.context);\n\n      if (!ts) {\n        return true;\n      }\n\n      return ts >= this.buildInfo.builtTime;\n    }\n  }, {\n    key: \"build\",\n    value: function build(options, compilation, resolver, fs, callback) {\n      var _this2 = this;\n\n      this.built = true;\n      this.buildMeta = {};\n      this.buildInfo = {\n        builtTime: Date.now(),\n        contextDependencies: this._contextDependencies\n      };\n      this.resolveDependencies(fs, this.options, function (err, dependencies) {\n        if (err) return callback(err); // abort if something failed\n        // this will create an empty context\n\n        if (!dependencies) {\n          callback();\n          return;\n        } // enhance dependencies with meta info\n\n\n        var _iterator = _createForOfIteratorHelper(dependencies),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _dep3 = _step.value;\n            _dep3.loc = {\n              name: _dep3.userRequest\n            };\n            _dep3.request = _this2.options.addon + _dep3.request;\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        if (_this2.options.mode === \"sync\" || _this2.options.mode === \"eager\") {\n          // if we have an sync or eager context\n          // just add all dependencies and continue\n          _this2.dependencies = dependencies;\n        } else if (_this2.options.mode === \"lazy-once\") {\n          // for the lazy-once mode create a new async dependency block\n          // and add that block to this context\n          if (dependencies.length > 0) {\n            var block = new AsyncDependenciesBlock(Object.assign({}, _this2.options.groupOptions, {\n              name: _this2.options.chunkName\n            }), _this2);\n\n            var _iterator2 = _createForOfIteratorHelper(dependencies),\n                _step2;\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var dep = _step2.value;\n                block.addDependency(dep);\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n\n            _this2.addBlock(block);\n          }\n        } else if (_this2.options.mode === \"weak\" || _this2.options.mode === \"async-weak\") {\n          // we mark all dependencies as weak\n          var _iterator3 = _createForOfIteratorHelper(dependencies),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _dep = _step3.value;\n              _dep.weak = true;\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n\n          _this2.dependencies = dependencies;\n        } else if (_this2.options.mode === \"lazy\") {\n          // if we are lazy create a new async dependency block per dependency\n          // and add all blocks to this context\n          var index = 0;\n\n          var _iterator4 = _createForOfIteratorHelper(dependencies),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _dep2 = _step4.value;\n              var chunkName = _this2.options.chunkName;\n\n              if (chunkName) {\n                if (!/\\[(index|request)\\]/.test(chunkName)) {\n                  chunkName += \"[index]\";\n                }\n\n                chunkName = chunkName.replace(/\\[index\\]/g, index++);\n                chunkName = chunkName.replace(/\\[request\\]/g, Template.toPath(_dep2.userRequest));\n              }\n\n              var _block = new AsyncDependenciesBlock(Object.assign({}, _this2.options.groupOptions, {\n                name: chunkName\n              }), _dep2.module, _dep2.loc, _dep2.userRequest);\n\n              _block.addDependency(_dep2);\n\n              _this2.addBlock(_block);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        } else {\n          callback(new Error(\"Unsupported mode \\\"\".concat(_this2.options.mode, \"\\\" in context\")));\n          return;\n        }\n\n        callback();\n      });\n    }\n  }, {\n    key: \"getUserRequestMap\",\n    value: function getUserRequestMap(dependencies) {\n      // if we filter first we get a new array\n      // therefor we dont need to create a clone of dependencies explicitly\n      // therefore the order of this is !important!\n      return dependencies.filter(function (dependency) {\n        return dependency.module;\n      }).sort(function (a, b) {\n        if (a.userRequest === b.userRequest) {\n          return 0;\n        }\n\n        return a.userRequest < b.userRequest ? -1 : 1;\n      }).reduce(function (map, dep) {\n        map[dep.userRequest] = dep.module.id;\n        return map;\n      }, Object.create(null));\n    }\n  }, {\n    key: \"getFakeMap\",\n    value: function getFakeMap(dependencies) {\n      var _this3 = this;\n\n      if (!this.options.namespaceObject) {\n        return 9;\n      } // if we filter first we get a new array\n      // therefor we dont need to create a clone of dependencies explicitly\n      // therefore the order of this is !important!\n\n\n      var hasNonHarmony = false;\n      var hasNamespace = false;\n      var hasNamed = false;\n      var fakeMap = dependencies.filter(function (dependency) {\n        return dependency.module;\n      }).sort(function (a, b) {\n        return b.module.id - a.module.id;\n      }).reduce(function (map, dep) {\n        var exportsType = dep.module.buildMeta && dep.module.buildMeta.exportsType;\n        var id = dep.module.id;\n\n        if (!exportsType) {\n          map[id] = _this3.options.namespaceObject === \"strict\" ? 1 : 7;\n          hasNonHarmony = true;\n        } else if (exportsType === \"namespace\") {\n          map[id] = 9;\n          hasNamespace = true;\n        } else if (exportsType === \"named\") {\n          map[id] = 3;\n          hasNamed = true;\n        }\n\n        return map;\n      }, Object.create(null));\n\n      if (!hasNamespace && hasNonHarmony && !hasNamed) {\n        return this.options.namespaceObject === \"strict\" ? 1 : 7;\n      }\n\n      if (hasNamespace && !hasNonHarmony && !hasNamed) {\n        return 9;\n      }\n\n      if (!hasNamespace && !hasNonHarmony && hasNamed) {\n        return 3;\n      }\n\n      if (!hasNamespace && !hasNonHarmony && !hasNamed) {\n        return 9;\n      }\n\n      return fakeMap;\n    }\n  }, {\n    key: \"getFakeMapInitStatement\",\n    value: function getFakeMapInitStatement(fakeMap) {\n      return _typeof(fakeMap) === \"object\" ? \"var fakeMap = \".concat(JSON.stringify(fakeMap, null, \"\\t\"), \";\") : \"\";\n    }\n  }, {\n    key: \"getReturn\",\n    value: function getReturn(type) {\n      if (type === 9) {\n        return \"__webpack_require__(id)\";\n      }\n\n      return \"__webpack_require__.t(id, \".concat(type, \")\");\n    }\n  }, {\n    key: \"getReturnModuleObjectSource\",\n    value: function getReturnModuleObjectSource(fakeMap) {\n      var fakeMapDataExpression = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"fakeMap[id]\";\n\n      if (typeof fakeMap === \"number\") {\n        return \"return \".concat(this.getReturn(fakeMap), \";\");\n      }\n\n      return \"return __webpack_require__.t(id, \".concat(fakeMapDataExpression, \")\");\n    }\n  }, {\n    key: \"getSyncSource\",\n    value: function getSyncSource(dependencies, id) {\n      var map = this.getUserRequestMap(dependencies);\n      var fakeMap = this.getFakeMap(dependencies);\n      var returnModuleObject = this.getReturnModuleObjectSource(fakeMap);\n      return \"var map = \".concat(JSON.stringify(map, null, \"\\t\"), \";\\n\").concat(this.getFakeMapInitStatement(fakeMap), \"\\n\\nfunction webpackContext(req) {\\n\\tvar id = webpackContextResolve(req);\\n\\t\").concat(returnModuleObject, \"\\n}\\nfunction webpackContextResolve(req) {\\n\\tif(!__webpack_require__.o(map, req)) {\\n\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\tthrow e;\\n\\t}\\n\\treturn map[req];\\n}\\nwebpackContext.keys = function webpackContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackContext.resolve = webpackContextResolve;\\nmodule.exports = webpackContext;\\nwebpackContext.id = \").concat(JSON.stringify(id), \";\");\n    }\n  }, {\n    key: \"getWeakSyncSource\",\n    value: function getWeakSyncSource(dependencies, id) {\n      var map = this.getUserRequestMap(dependencies);\n      var fakeMap = this.getFakeMap(dependencies);\n      var returnModuleObject = this.getReturnModuleObjectSource(fakeMap);\n      return \"var map = \".concat(JSON.stringify(map, null, \"\\t\"), \";\\n\").concat(this.getFakeMapInitStatement(fakeMap), \"\\n\\nfunction webpackContext(req) {\\n\\tvar id = webpackContextResolve(req);\\n\\tif(!__webpack_require__.m[id]) {\\n\\t\\tvar e = new Error(\\\"Module '\\\" + req + \\\"' ('\\\" + id + \\\"') is not available (weak dependency)\\\");\\n\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\tthrow e;\\n\\t}\\n\\t\").concat(returnModuleObject, \"\\n}\\nfunction webpackContextResolve(req) {\\n\\tif(!__webpack_require__.o(map, req)) {\\n\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\tthrow e;\\n\\t}\\n\\treturn map[req];\\n}\\nwebpackContext.keys = function webpackContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackContext.resolve = webpackContextResolve;\\nwebpackContext.id = \").concat(JSON.stringify(id), \";\\nmodule.exports = webpackContext;\");\n    }\n  }, {\n    key: \"getAsyncWeakSource\",\n    value: function getAsyncWeakSource(dependencies, id) {\n      var map = this.getUserRequestMap(dependencies);\n      var fakeMap = this.getFakeMap(dependencies);\n      var returnModuleObject = this.getReturnModuleObjectSource(fakeMap);\n      return \"var map = \".concat(JSON.stringify(map, null, \"\\t\"), \";\\n\").concat(this.getFakeMapInitStatement(fakeMap), \"\\n\\nfunction webpackAsyncContext(req) {\\n\\treturn webpackAsyncContextResolve(req).then(function(id) {\\n\\t\\tif(!__webpack_require__.m[id]) {\\n\\t\\t\\tvar e = new Error(\\\"Module '\\\" + req + \\\"' ('\\\" + id + \\\"') is not available (weak dependency)\\\");\\n\\t\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\t\").concat(returnModuleObject, \"\\n\\t});\\n}\\nfunction webpackAsyncContextResolve(req) {\\n\\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\\n\\t// uncaught exception popping up in devtools\\n\\treturn Promise.resolve().then(function() {\\n\\t\\tif(!__webpack_require__.o(map, req)) {\\n\\t\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn map[req];\\n\\t});\\n}\\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackAsyncContext.resolve = webpackAsyncContextResolve;\\nwebpackAsyncContext.id = \").concat(JSON.stringify(id), \";\\nmodule.exports = webpackAsyncContext;\");\n    }\n  }, {\n    key: \"getEagerSource\",\n    value: function getEagerSource(dependencies, id) {\n      var map = this.getUserRequestMap(dependencies);\n      var fakeMap = this.getFakeMap(dependencies);\n      var thenFunction = fakeMap !== 9 ? \"function(id) {\\n\\t\\t\".concat(this.getReturnModuleObjectSource(fakeMap), \"\\n\\t}\") : \"__webpack_require__\";\n      return \"var map = \".concat(JSON.stringify(map, null, \"\\t\"), \";\\n\").concat(this.getFakeMapInitStatement(fakeMap), \"\\n\\nfunction webpackAsyncContext(req) {\\n\\treturn webpackAsyncContextResolve(req).then(\").concat(thenFunction, \");\\n}\\nfunction webpackAsyncContextResolve(req) {\\n\\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\\n\\t// uncaught exception popping up in devtools\\n\\treturn Promise.resolve().then(function() {\\n\\t\\tif(!__webpack_require__.o(map, req)) {\\n\\t\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn map[req];\\n\\t});\\n}\\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackAsyncContext.resolve = webpackAsyncContextResolve;\\nwebpackAsyncContext.id = \").concat(JSON.stringify(id), \";\\nmodule.exports = webpackAsyncContext;\");\n    }\n  }, {\n    key: \"getLazyOnceSource\",\n    value: function getLazyOnceSource(block, dependencies, id, runtimeTemplate) {\n      var promise = runtimeTemplate.blockPromise({\n        block: block,\n        message: \"lazy-once context\"\n      });\n      var map = this.getUserRequestMap(dependencies);\n      var fakeMap = this.getFakeMap(dependencies);\n      var thenFunction = fakeMap !== 9 ? \"function(id) {\\n\\t\\t\".concat(this.getReturnModuleObjectSource(fakeMap), \";\\n\\t}\") : \"__webpack_require__\";\n      return \"var map = \".concat(JSON.stringify(map, null, \"\\t\"), \";\\n\").concat(this.getFakeMapInitStatement(fakeMap), \"\\n\\nfunction webpackAsyncContext(req) {\\n\\treturn webpackAsyncContextResolve(req).then(\").concat(thenFunction, \");\\n}\\nfunction webpackAsyncContextResolve(req) {\\n\\treturn \").concat(promise, \".then(function() {\\n\\t\\tif(!__webpack_require__.o(map, req)) {\\n\\t\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn map[req];\\n\\t});\\n}\\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackAsyncContext.resolve = webpackAsyncContextResolve;\\nwebpackAsyncContext.id = \").concat(JSON.stringify(id), \";\\nmodule.exports = webpackAsyncContext;\");\n    }\n  }, {\n    key: \"getLazySource\",\n    value: function getLazySource(blocks, id) {\n      var hasMultipleOrNoChunks = false;\n      var hasNoChunk = true;\n      var fakeMap = this.getFakeMap(blocks.map(function (b) {\n        return b.dependencies[0];\n      }));\n      var hasFakeMap = _typeof(fakeMap) === \"object\";\n      var map = blocks.filter(function (block) {\n        return block.dependencies[0].module;\n      }).map(function (block) {\n        var chunks = block.chunkGroup ? block.chunkGroup.chunks : [];\n\n        if (chunks.length > 0) {\n          hasNoChunk = false;\n        }\n\n        if (chunks.length !== 1) {\n          hasMultipleOrNoChunks = true;\n        }\n\n        return {\n          dependency: block.dependencies[0],\n          block: block,\n          userRequest: block.dependencies[0].userRequest,\n          chunks: chunks\n        };\n      }).sort(function (a, b) {\n        if (a.userRequest === b.userRequest) return 0;\n        return a.userRequest < b.userRequest ? -1 : 1;\n      }).reduce(function (map, item) {\n        var chunks = item.chunks;\n\n        if (hasNoChunk && !hasFakeMap) {\n          map[item.userRequest] = item.dependency.module.id;\n        } else {\n          var arrayStart = [item.dependency.module.id];\n\n          if (_typeof(fakeMap) === \"object\") {\n            arrayStart.push(fakeMap[item.dependency.module.id]);\n          }\n\n          map[item.userRequest] = arrayStart.concat(chunks.map(function (chunk) {\n            return chunk.id;\n          }));\n        }\n\n        return map;\n      }, Object.create(null));\n      var shortMode = hasNoChunk && !hasFakeMap;\n      var chunksStartPosition = hasFakeMap ? 2 : 1;\n      var requestPrefix = hasNoChunk ? \"Promise.resolve()\" : hasMultipleOrNoChunks ? \"Promise.all(ids.slice(\".concat(chunksStartPosition, \").map(__webpack_require__.e))\") : \"__webpack_require__.e(ids[\".concat(chunksStartPosition, \"])\");\n      var returnModuleObject = this.getReturnModuleObjectSource(fakeMap, shortMode ? \"invalid\" : \"ids[1]\");\n      var webpackAsyncContext = requestPrefix === \"Promise.resolve()\" ? \"\".concat(shortMode ? \"\" : \"\", \"\\nfunction webpackAsyncContext(req) {\\n\\treturn Promise.resolve().then(function() {\\n\\t\\tif(!__webpack_require__.o(map, req)) {\\n\\t\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\n\\t\\t\").concat(shortMode ? \"var id = map[req];\" : \"var ids = map[req], id = ids[0];\", \"\\n\\t\\t\").concat(returnModuleObject, \"\\n\\t});\\n}\") : \"function webpackAsyncContext(req) {\\n\\tif(!__webpack_require__.o(map, req)) {\\n\\t\\treturn Promise.resolve().then(function() {\\n\\t\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\t\\tthrow e;\\n\\t\\t});\\n\\t}\\n\\n\\tvar ids = map[req], id = ids[0];\\n\\treturn \".concat(requestPrefix, \".then(function() {\\n\\t\\t\").concat(returnModuleObject, \"\\n\\t});\\n}\");\n      return \"var map = \".concat(JSON.stringify(map, null, \"\\t\"), \";\\n\").concat(webpackAsyncContext, \"\\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackAsyncContext.id = \").concat(JSON.stringify(id), \";\\nmodule.exports = webpackAsyncContext;\");\n    }\n  }, {\n    key: \"getSourceForEmptyContext\",\n    value: function getSourceForEmptyContext(id) {\n      return \"function webpackEmptyContext(req) {\\n\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\te.code = 'MODULE_NOT_FOUND';\\n\\tthrow e;\\n}\\nwebpackEmptyContext.keys = function() { return []; };\\nwebpackEmptyContext.resolve = webpackEmptyContext;\\nmodule.exports = webpackEmptyContext;\\nwebpackEmptyContext.id = \".concat(JSON.stringify(id), \";\");\n    }\n  }, {\n    key: \"getSourceForEmptyAsyncContext\",\n    value: function getSourceForEmptyAsyncContext(id) {\n      return \"function webpackEmptyAsyncContext(req) {\\n\\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\\n\\t// uncaught exception popping up in devtools\\n\\treturn Promise.resolve().then(function() {\\n\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\tthrow e;\\n\\t});\\n}\\nwebpackEmptyAsyncContext.keys = function() { return []; };\\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\\nmodule.exports = webpackEmptyAsyncContext;\\nwebpackEmptyAsyncContext.id = \".concat(JSON.stringify(id), \";\");\n    }\n  }, {\n    key: \"getSourceString\",\n    value: function getSourceString(asyncMode, runtimeTemplate) {\n      if (asyncMode === \"lazy\") {\n        if (this.blocks && this.blocks.length > 0) {\n          return this.getLazySource(this.blocks, this.id);\n        }\n\n        return this.getSourceForEmptyAsyncContext(this.id);\n      }\n\n      if (asyncMode === \"eager\") {\n        if (this.dependencies && this.dependencies.length > 0) {\n          return this.getEagerSource(this.dependencies, this.id);\n        }\n\n        return this.getSourceForEmptyAsyncContext(this.id);\n      }\n\n      if (asyncMode === \"lazy-once\") {\n        var block = this.blocks[0];\n\n        if (block) {\n          return this.getLazyOnceSource(block, block.dependencies, this.id, runtimeTemplate);\n        }\n\n        return this.getSourceForEmptyAsyncContext(this.id);\n      }\n\n      if (asyncMode === \"async-weak\") {\n        if (this.dependencies && this.dependencies.length > 0) {\n          return this.getAsyncWeakSource(this.dependencies, this.id);\n        }\n\n        return this.getSourceForEmptyAsyncContext(this.id);\n      }\n\n      if (asyncMode === \"weak\") {\n        if (this.dependencies && this.dependencies.length > 0) {\n          return this.getWeakSyncSource(this.dependencies, this.id);\n        }\n      }\n\n      if (this.dependencies && this.dependencies.length > 0) {\n        return this.getSyncSource(this.dependencies, this.id);\n      }\n\n      return this.getSourceForEmptyContext(this.id);\n    }\n  }, {\n    key: \"getSource\",\n    value: function getSource(sourceString) {\n      if (this.useSourceMap) {\n        return new OriginalSource(sourceString, this.identifier());\n      }\n\n      return new RawSource(sourceString);\n    }\n  }, {\n    key: \"source\",\n    value: function source(dependencyTemplates, runtimeTemplate) {\n      return this.getSource(this.getSourceString(this.options.mode, runtimeTemplate));\n    }\n  }, {\n    key: \"size\",\n    value: function size() {\n      // base penalty\n      var initialSize = 160; // if we dont have dependencies we stop here.\n\n      return this.dependencies.reduce(function (size, dependency) {\n        var element =\n        /** @type {ContextElementDependency} */\n        dependency;\n        return size + 5 + element.userRequest.length;\n      }, initialSize);\n    }\n  }]);\n\n  return ContextModule;\n}(Module); // TODO remove in webpack 5\n\n\nObject.defineProperty(ContextModule.prototype, \"recursive\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @returns {boolean} is recursive\n   */\n  function () {\n    return this.options.recursive;\n  }, \"ContextModule.recursive has been moved to ContextModule.options.recursive\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @param {boolean} value is recursive\n   * @returns {void}\n   */\n  function (value) {\n    this.options.recursive = value;\n  }, \"ContextModule.recursive has been moved to ContextModule.options.recursive\")\n}); // TODO remove in webpack 5\n\nObject.defineProperty(ContextModule.prototype, \"regExp\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @returns {RegExp} regular expression\n   */\n  function () {\n    return this.options.regExp;\n  }, \"ContextModule.regExp has been moved to ContextModule.options.regExp\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @param {RegExp} value Regular expression\n   * @returns {void}\n   */\n  function (value) {\n    this.options.regExp = value;\n  }, \"ContextModule.regExp has been moved to ContextModule.options.regExp\")\n}); // TODO remove in webpack 5\n\nObject.defineProperty(ContextModule.prototype, \"addon\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @returns {string} addon\n   */\n  function () {\n    return this.options.addon;\n  }, \"ContextModule.addon has been moved to ContextModule.options.addon\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @param {string} value addon\n   * @returns {void}\n   */\n  function (value) {\n    this.options.addon = value;\n  }, \"ContextModule.addon has been moved to ContextModule.options.addon\")\n}); // TODO remove in webpack 5\n\nObject.defineProperty(ContextModule.prototype, \"async\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @returns {boolean} is async\n   */\n  function () {\n    return this.options.mode;\n  }, \"ContextModule.async has been moved to ContextModule.options.mode\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @param {ContextMode} value Context mode\n   * @returns {void}\n   */\n  function (value) {\n    this.options.mode = value;\n  }, \"ContextModule.async has been moved to ContextModule.options.mode\")\n}); // TODO remove in webpack 5\n\nObject.defineProperty(ContextModule.prototype, \"chunkName\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @returns {string} chunk name\n   */\n  function () {\n    return this.options.chunkName;\n  }, \"ContextModule.chunkName has been moved to ContextModule.options.chunkName\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @param {string} value chunk name\n   * @returns {void}\n   */\n  function (value) {\n    this.options.chunkName = value;\n  }, \"ContextModule.chunkName has been moved to ContextModule.options.chunkName\")\n});\nmodule.exports = ContextModule;","map":null,"metadata":{},"sourceType":"module"}