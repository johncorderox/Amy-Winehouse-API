{"ast":null,"code":"/*\nCopyright (c) 2014, Yahoo! Inc. All rights reserved.\nCopyrights licensed under the New BSD License.\nSee the accompanying LICENSE file for terms.\n*/\n'use strict';\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar randomBytes = require('randombytes'); // Generate an internal UID to make the regexp pattern harder to guess.\n\n\nvar UID_LENGTH = 16;\nvar UID = generateUID();\nvar PLACE_HOLDER_REGEXP = new RegExp('(\\\\\\\\)?\"@__(F|R|D|M|S|U|I|B)-' + UID + '-(\\\\d+)__@\"', 'g');\nvar IS_NATIVE_CODE_REGEXP = /\\{\\s*\\[native code\\]\\s*\\}/g;\nvar IS_PURE_FUNCTION = /function.*?\\(/;\nvar IS_ARROW_FUNCTION = /.*?=>.*?/;\nvar UNSAFE_CHARS_REGEXP = /[<>\\/\\u2028\\u2029]/g;\nvar RESERVED_SYMBOLS = ['*', 'async']; // Mapping of unsafe HTML and invalid JavaScript line terminator chars to their\n// Unicode char counterparts which are safe to use in JavaScript strings.\n\nvar ESCAPED_CHARS = {\n  '<': \"\\\\u003C\",\n  '>': \"\\\\u003E\",\n  '/': \"\\\\u002F\",\n  \"\\u2028\": \"\\\\u2028\",\n  \"\\u2029\": \"\\\\u2029\"\n};\n\nfunction escapeUnsafeChars(unsafeChar) {\n  return ESCAPED_CHARS[unsafeChar];\n}\n\nfunction generateUID() {\n  var bytes = randomBytes(UID_LENGTH);\n  var result = '';\n\n  for (var i = 0; i < UID_LENGTH; ++i) {\n    result += bytes[i].toString(16);\n  }\n\n  return result;\n}\n\nfunction deleteFunctions(obj) {\n  var functionKeys = [];\n\n  for (var key in obj) {\n    if (typeof obj[key] === \"function\") {\n      functionKeys.push(key);\n    }\n  }\n\n  for (var i = 0; i < functionKeys.length; i++) {\n    delete obj[functionKeys[i]];\n  }\n}\n\nmodule.exports = function serialize(obj, options) {\n  options || (options = {}); // Backwards-compatibility for `space` as the second argument.\n\n  if (typeof options === 'number' || typeof options === 'string') {\n    options = {\n      space: options\n    };\n  }\n\n  var functions = [];\n  var regexps = [];\n  var dates = [];\n  var maps = [];\n  var sets = [];\n  var undefs = [];\n  var infinities = [];\n  var bigInts = []; // Returns placeholders for functions and regexps (identified by index)\n  // which are later replaced by their string representation.\n\n  function replacer(key, value) {\n    // For nested function\n    if (options.ignoreFunction) {\n      deleteFunctions(value);\n    }\n\n    if (!value && value !== undefined) {\n      return value;\n    } // If the value is an object w/ a toJSON method, toJSON is called before\n    // the replacer runs, so we use this[key] to get the non-toJSONed value.\n\n\n    var origValue = this[key];\n\n    var type = _typeof(origValue);\n\n    if (type === 'object') {\n      if (origValue instanceof RegExp) {\n        return '@__R-' + UID + '-' + (regexps.push(origValue) - 1) + '__@';\n      }\n\n      if (origValue instanceof Date) {\n        return '@__D-' + UID + '-' + (dates.push(origValue) - 1) + '__@';\n      }\n\n      if (origValue instanceof Map) {\n        return '@__M-' + UID + '-' + (maps.push(origValue) - 1) + '__@';\n      }\n\n      if (origValue instanceof Set) {\n        return '@__S-' + UID + '-' + (sets.push(origValue) - 1) + '__@';\n      }\n    }\n\n    if (type === 'function') {\n      return '@__F-' + UID + '-' + (functions.push(origValue) - 1) + '__@';\n    }\n\n    if (type === 'undefined') {\n      return '@__U-' + UID + '-' + (undefs.push(origValue) - 1) + '__@';\n    }\n\n    if (type === 'number' && !isNaN(origValue) && !isFinite(origValue)) {\n      return '@__I-' + UID + '-' + (infinities.push(origValue) - 1) + '__@';\n    }\n\n    if (type === 'bigint') {\n      return '@__B-' + UID + '-' + (bigInts.push(origValue) - 1) + '__@';\n    }\n\n    return value;\n  }\n\n  function serializeFunc(fn) {\n    var serializedFn = fn.toString();\n\n    if (IS_NATIVE_CODE_REGEXP.test(serializedFn)) {\n      throw new TypeError('Serializing native function: ' + fn.name);\n    } // pure functions, example: {key: function() {}}\n\n\n    if (IS_PURE_FUNCTION.test(serializedFn)) {\n      return serializedFn;\n    } // arrow functions, example: arg1 => arg1+5\n\n\n    if (IS_ARROW_FUNCTION.test(serializedFn)) {\n      return serializedFn;\n    }\n\n    var argsStartsAt = serializedFn.indexOf('(');\n    var def = serializedFn.substr(0, argsStartsAt).trim().split(' ').filter(function (val) {\n      return val.length > 0;\n    });\n    var nonReservedSymbols = def.filter(function (val) {\n      return RESERVED_SYMBOLS.indexOf(val) === -1;\n    }); // enhanced literal objects, example: {key() {}}\n\n    if (nonReservedSymbols.length > 0) {\n      return (def.indexOf('async') > -1 ? 'async ' : '') + 'function' + (def.join('').indexOf('*') > -1 ? '*' : '') + serializedFn.substr(argsStartsAt);\n    } // arrow functions\n\n\n    return serializedFn;\n  } // Check if the parameter is function\n\n\n  if (options.ignoreFunction && typeof obj === \"function\") {\n    obj = undefined;\n  } // Protects against `JSON.stringify()` returning `undefined`, by serializing\n  // to the literal string: \"undefined\".\n\n\n  if (obj === undefined) {\n    return String(obj);\n  }\n\n  var str; // Creates a JSON string representation of the value.\n  // NOTE: Node 0.12 goes into slow mode with extra JSON.stringify() args.\n\n  if (options.isJSON && !options.space) {\n    str = JSON.stringify(obj);\n  } else {\n    str = JSON.stringify(obj, options.isJSON ? null : replacer, options.space);\n  } // Protects against `JSON.stringify()` returning `undefined`, by serializing\n  // to the literal string: \"undefined\".\n\n\n  if (typeof str !== 'string') {\n    return String(str);\n  } // Replace unsafe HTML and invalid JavaScript line terminator chars with\n  // their safe Unicode char counterpart. This _must_ happen before the\n  // regexps and functions are serialized and added back to the string.\n\n\n  if (options.unsafe !== true) {\n    str = str.replace(UNSAFE_CHARS_REGEXP, escapeUnsafeChars);\n  }\n\n  if (functions.length === 0 && regexps.length === 0 && dates.length === 0 && maps.length === 0 && sets.length === 0 && undefs.length === 0 && infinities.length === 0 && bigInts.length === 0) {\n    return str;\n  } // Replaces all occurrences of function, regexp, date, map and set placeholders in the\n  // JSON string with their string representations. If the original value can\n  // not be found, then `undefined` is used.\n\n\n  return str.replace(PLACE_HOLDER_REGEXP, function (match, backSlash, type, valueIndex) {\n    // The placeholder may not be preceded by a backslash. This is to prevent\n    // replacing things like `\"a\\\"@__R-<UID>-0__@\"` and thus outputting\n    // invalid JS.\n    if (backSlash) {\n      return match;\n    }\n\n    if (type === 'D') {\n      return \"new Date(\\\"\" + dates[valueIndex].toISOString() + \"\\\")\";\n    }\n\n    if (type === 'R') {\n      return \"new RegExp(\" + serialize(regexps[valueIndex].source) + \", \\\"\" + regexps[valueIndex].flags + \"\\\")\";\n    }\n\n    if (type === 'M') {\n      return \"new Map(\" + serialize(Array.from(maps[valueIndex].entries()), options) + \")\";\n    }\n\n    if (type === 'S') {\n      return \"new Set(\" + serialize(Array.from(sets[valueIndex].values()), options) + \")\";\n    }\n\n    if (type === 'U') {\n      return 'undefined';\n    }\n\n    if (type === 'I') {\n      return infinities[valueIndex];\n    }\n\n    if (type === 'B') {\n      return \"BigInt(\\\"\" + bigInts[valueIndex] + \"\\\")\";\n    }\n\n    var fn = functions[valueIndex];\n    return serializeFunc(fn);\n  });\n};","map":null,"metadata":{},"sourceType":"module"}