{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar AliasPlugin = require(\"enhanced-resolve/lib/AliasPlugin\");\n\nvar ParserHelpers = require(\"../ParserHelpers\");\n\nvar nodeLibsBrowser = require(\"node-libs-browser\");\n\nmodule.exports = /*#__PURE__*/function () {\n  function NodeSourcePlugin(options) {\n    _classCallCheck(this, NodeSourcePlugin);\n\n    this.options = options;\n  }\n\n  _createClass(NodeSourcePlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var options = this.options;\n\n      if (options === false) {\n        // allow single kill switch to turn off this plugin\n        return;\n      }\n\n      var getPathToModule = function getPathToModule(module, type) {\n        if (type === true || type === undefined && nodeLibsBrowser[module]) {\n          if (!nodeLibsBrowser[module]) {\n            throw new Error(\"No browser version for node.js core module \".concat(module, \" available\"));\n          }\n\n          return nodeLibsBrowser[module];\n        } else if (type === \"mock\") {\n          return require.resolve(\"node-libs-browser/mock/\".concat(module));\n        } else if (type === \"empty\") {\n          return require.resolve(\"node-libs-browser/mock/empty\");\n        } else {\n          return module;\n        }\n      };\n\n      var addExpression = function addExpression(parser, name, module, type, suffix) {\n        suffix = suffix || \"\";\n        parser.hooks.expression[\"for\"](name).tap(\"NodeSourcePlugin\", function () {\n          if (parser.state.module && parser.state.module.resource === getPathToModule(module, type)) return;\n          var mockModule = ParserHelpers.requireFileAsExpression(parser.state.module.context, getPathToModule(module, type));\n          return ParserHelpers.addParsedVariableToModule(parser, name, mockModule + suffix);\n        });\n      };\n\n      compiler.hooks.compilation.tap(\"NodeSourcePlugin\", function (compilation, _ref) {\n        var normalModuleFactory = _ref.normalModuleFactory;\n\n        var handler = function handler(parser, parserOptions) {\n          if (parserOptions.node === false) return;\n          var localOptions = options;\n\n          if (parserOptions.node) {\n            localOptions = Object.assign({}, localOptions, parserOptions.node);\n          }\n\n          if (localOptions.global) {\n            parser.hooks.expression[\"for\"](\"global\").tap(\"NodeSourcePlugin\", function () {\n              var retrieveGlobalModule = ParserHelpers.requireFileAsExpression(parser.state.module.context, require.resolve(\"../../buildin/global\"));\n              return ParserHelpers.addParsedVariableToModule(parser, \"global\", retrieveGlobalModule);\n            });\n          }\n\n          if (localOptions.process) {\n            var processType = localOptions.process;\n            addExpression(parser, \"process\", \"process\", processType);\n          }\n\n          if (localOptions.console) {\n            var consoleType = localOptions.console;\n            addExpression(parser, \"console\", \"console\", consoleType);\n          }\n\n          var bufferType = localOptions.Buffer;\n\n          if (bufferType) {\n            addExpression(parser, \"Buffer\", \"buffer\", bufferType, \".Buffer\");\n          }\n\n          if (localOptions.setImmediate) {\n            var setImmediateType = localOptions.setImmediate;\n            addExpression(parser, \"setImmediate\", \"timers\", setImmediateType, \".setImmediate\");\n            addExpression(parser, \"clearImmediate\", \"timers\", setImmediateType, \".clearImmediate\");\n          }\n        };\n\n        normalModuleFactory.hooks.parser[\"for\"](\"javascript/auto\").tap(\"NodeSourcePlugin\", handler);\n        normalModuleFactory.hooks.parser[\"for\"](\"javascript/dynamic\").tap(\"NodeSourcePlugin\", handler);\n      });\n      compiler.hooks.afterResolvers.tap(\"NodeSourcePlugin\", function (compiler) {\n        var _loop = function _loop() {\n          var lib = _Object$keys[_i];\n\n          if (options[lib] !== false) {\n            compiler.resolverFactory.hooks.resolver[\"for\"](\"normal\").tap(\"NodeSourcePlugin\", function (resolver) {\n              new AliasPlugin(\"described-resolve\", {\n                name: lib,\n                onlyModule: true,\n                alias: getPathToModule(lib, options[lib])\n              }, \"resolve\").apply(resolver);\n            });\n          }\n        };\n\n        for (var _i = 0, _Object$keys = Object.keys(nodeLibsBrowser); _i < _Object$keys.length; _i++) {\n          _loop();\n        }\n      });\n    }\n  }]);\n\n  return NodeSourcePlugin;\n}();","map":null,"metadata":{},"sourceType":"module"}