{"ast":null,"code":"'use strict';\n\nvar BB = require('bluebird');\n\nvar figgyPudding = require('figgy-pudding');\n\nvar fs = require('fs');\n\nvar index = require('./lib/entry-index');\n\nvar memo = require('./lib/memoization');\n\nvar pipe = require('mississippi').pipe;\n\nvar pipeline = require('mississippi').pipeline;\n\nvar read = require('./lib/content/read');\n\nvar through = require('mississippi').through;\n\nvar GetOpts = figgyPudding({\n  integrity: {},\n  memoize: {},\n  size: {}\n});\n\nmodule.exports = function get(cache, key, opts) {\n  return getData(false, cache, key, opts);\n};\n\nmodule.exports.byDigest = function getByDigest(cache, digest, opts) {\n  return getData(true, cache, digest, opts);\n};\n\nfunction getData(byDigest, cache, key, opts) {\n  opts = GetOpts(opts);\n  var memoized = byDigest ? memo.get.byDigest(cache, key, opts) : memo.get(cache, key, opts);\n\n  if (memoized && opts.memoize !== false) {\n    return BB.resolve(byDigest ? memoized : {\n      metadata: memoized.entry.metadata,\n      data: memoized.data,\n      integrity: memoized.entry.integrity,\n      size: memoized.entry.size\n    });\n  }\n\n  return (byDigest ? BB.resolve(null) : index.find(cache, key, opts)).then(function (entry) {\n    if (!entry && !byDigest) {\n      throw new index.NotFoundError(cache, key);\n    }\n\n    return read(cache, byDigest ? key : entry.integrity, {\n      integrity: opts.integrity,\n      size: opts.size\n    }).then(function (data) {\n      return byDigest ? data : {\n        metadata: entry.metadata,\n        data: data,\n        size: entry.size,\n        integrity: entry.integrity\n      };\n    }).then(function (res) {\n      if (opts.memoize && byDigest) {\n        memo.put.byDigest(cache, key, res, opts);\n      } else if (opts.memoize) {\n        memo.put(cache, entry, res.data, opts);\n      }\n\n      return res;\n    });\n  });\n}\n\nmodule.exports.sync = function get(cache, key, opts) {\n  return getDataSync(false, cache, key, opts);\n};\n\nmodule.exports.sync.byDigest = function getByDigest(cache, digest, opts) {\n  return getDataSync(true, cache, digest, opts);\n};\n\nfunction getDataSync(byDigest, cache, key, opts) {\n  opts = GetOpts(opts);\n  var memoized = byDigest ? memo.get.byDigest(cache, key, opts) : memo.get(cache, key, opts);\n\n  if (memoized && opts.memoize !== false) {\n    return byDigest ? memoized : {\n      metadata: memoized.entry.metadata,\n      data: memoized.data,\n      integrity: memoized.entry.integrity,\n      size: memoized.entry.size\n    };\n  }\n\n  var entry = !byDigest && index.find.sync(cache, key, opts);\n\n  if (!entry && !byDigest) {\n    throw new index.NotFoundError(cache, key);\n  }\n\n  var data = read.sync(cache, byDigest ? key : entry.integrity, {\n    integrity: opts.integrity,\n    size: opts.size\n  });\n  var res = byDigest ? data : {\n    metadata: entry.metadata,\n    data: data,\n    size: entry.size,\n    integrity: entry.integrity\n  };\n\n  if (opts.memoize && byDigest) {\n    memo.put.byDigest(cache, key, res, opts);\n  } else if (opts.memoize) {\n    memo.put(cache, entry, res.data, opts);\n  }\n\n  return res;\n}\n\nmodule.exports.stream = getStream;\n\nfunction getStream(cache, key, opts) {\n  opts = GetOpts(opts);\n  var stream = through();\n  var memoized = memo.get(cache, key, opts);\n\n  if (memoized && opts.memoize !== false) {\n    stream.on('newListener', function (ev, cb) {\n      ev === 'metadata' && cb(memoized.entry.metadata);\n      ev === 'integrity' && cb(memoized.entry.integrity);\n      ev === 'size' && cb(memoized.entry.size);\n    });\n    stream.write(memoized.data, function () {\n      return stream.end();\n    });\n    return stream;\n  }\n\n  index.find(cache, key).then(function (entry) {\n    if (!entry) {\n      return stream.emit('error', new index.NotFoundError(cache, key));\n    }\n\n    var memoStream;\n\n    if (opts.memoize) {\n      var memoData = [];\n      var memoLength = 0;\n      memoStream = through(function (c, en, cb) {\n        memoData && memoData.push(c);\n        memoLength += c.length;\n        cb(null, c, en);\n      }, function (cb) {\n        memoData && memo.put(cache, entry, Buffer.concat(memoData, memoLength), opts);\n        cb();\n      });\n    } else {\n      memoStream = through();\n    }\n\n    stream.emit('metadata', entry.metadata);\n    stream.emit('integrity', entry.integrity);\n    stream.emit('size', entry.size);\n    stream.on('newListener', function (ev, cb) {\n      ev === 'metadata' && cb(entry.metadata);\n      ev === 'integrity' && cb(entry.integrity);\n      ev === 'size' && cb(entry.size);\n    });\n    pipe(read.readStream(cache, entry.integrity, opts.concat({\n      size: opts.size == null ? entry.size : opts.size\n    })), memoStream, stream);\n  })[\"catch\"](function (err) {\n    return stream.emit('error', err);\n  });\n  return stream;\n}\n\nmodule.exports.stream.byDigest = getStreamDigest;\n\nfunction getStreamDigest(cache, integrity, opts) {\n  opts = GetOpts(opts);\n  var memoized = memo.get.byDigest(cache, integrity, opts);\n\n  if (memoized && opts.memoize !== false) {\n    var stream = through();\n    stream.write(memoized, function () {\n      return stream.end();\n    });\n    return stream;\n  } else {\n    var _stream = read.readStream(cache, integrity, opts);\n\n    if (opts.memoize) {\n      var memoData = [];\n      var memoLength = 0;\n      var memoStream = through(function (c, en, cb) {\n        memoData && memoData.push(c);\n        memoLength += c.length;\n        cb(null, c, en);\n      }, function (cb) {\n        memoData && memo.put.byDigest(cache, integrity, Buffer.concat(memoData, memoLength), opts);\n        cb();\n      });\n      _stream = pipeline(_stream, memoStream);\n    }\n\n    return _stream;\n  }\n}\n\nmodule.exports.info = info;\n\nfunction info(cache, key, opts) {\n  opts = GetOpts(opts);\n  var memoized = memo.get(cache, key, opts);\n\n  if (memoized && opts.memoize !== false) {\n    return BB.resolve(memoized.entry);\n  } else {\n    return index.find(cache, key);\n  }\n}\n\nmodule.exports.hasContent = read.hasContent;\n\nmodule.exports.copy = function cp(cache, key, dest, opts) {\n  return copy(false, cache, key, dest, opts);\n};\n\nmodule.exports.copy.byDigest = function cpDigest(cache, digest, dest, opts) {\n  return copy(true, cache, digest, dest, opts);\n};\n\nfunction copy(byDigest, cache, key, dest, opts) {\n  opts = GetOpts(opts);\n\n  if (read.copy) {\n    return (byDigest ? BB.resolve(null) : index.find(cache, key, opts)).then(function (entry) {\n      if (!entry && !byDigest) {\n        throw new index.NotFoundError(cache, key);\n      }\n\n      return read.copy(cache, byDigest ? key : entry.integrity, dest, opts).then(function () {\n        return byDigest ? key : {\n          metadata: entry.metadata,\n          size: entry.size,\n          integrity: entry.integrity\n        };\n      });\n    });\n  } else {\n    return getData(byDigest, cache, key, opts).then(function (res) {\n      return fs.writeFileAsync(dest, byDigest ? res : res.data).then(function () {\n        return byDigest ? key : {\n          metadata: res.metadata,\n          size: res.size,\n          integrity: res.integrity\n        };\n      });\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"module"}