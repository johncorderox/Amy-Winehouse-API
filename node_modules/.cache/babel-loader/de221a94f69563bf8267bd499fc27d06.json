{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar fs = require(\"fs\");\n\nvar readFile = fs.readFile.bind(fs);\n\nvar loadLoader = require(\"./loadLoader\");\n\nfunction utf8BufferToString(buf) {\n  var str = buf.toString(\"utf-8\");\n\n  if (str.charCodeAt(0) === 0xFEFF) {\n    return str.substr(1);\n  } else {\n    return str;\n  }\n}\n\nfunction splitQuery(req) {\n  var i = req.indexOf(\"?\");\n  if (i < 0) return [req, \"\"];\n  return [req.substr(0, i), req.substr(i)];\n}\n\nfunction dirname(path) {\n  if (path === \"/\") return \"/\";\n  var i = path.lastIndexOf(\"/\");\n  var j = path.lastIndexOf(\"\\\\\");\n  var i2 = path.indexOf(\"/\");\n  var j2 = path.indexOf(\"\\\\\");\n  var idx = i > j ? i : j;\n  var idx2 = i > j ? i2 : j2;\n  if (idx < 0) return path;\n  if (idx === idx2) return path.substr(0, idx + 1);\n  return path.substr(0, idx);\n}\n\nfunction createLoaderObject(loader) {\n  var obj = {\n    path: null,\n    query: null,\n    options: null,\n    ident: null,\n    normal: null,\n    pitch: null,\n    raw: null,\n    data: null,\n    pitchExecuted: false,\n    normalExecuted: false\n  };\n  Object.defineProperty(obj, \"request\", {\n    enumerable: true,\n    get: function get() {\n      return obj.path + obj.query;\n    },\n    set: function set(value) {\n      if (typeof value === \"string\") {\n        var splittedRequest = splitQuery(value);\n        obj.path = splittedRequest[0];\n        obj.query = splittedRequest[1];\n        obj.options = undefined;\n        obj.ident = undefined;\n      } else {\n        if (!value.loader) throw new Error(\"request should be a string or object with loader and object (\" + JSON.stringify(value) + \")\");\n        obj.path = value.loader;\n        obj.options = value.options;\n        obj.ident = value.ident;\n        if (obj.options === null) obj.query = \"\";else if (obj.options === undefined) obj.query = \"\";else if (typeof obj.options === \"string\") obj.query = \"?\" + obj.options;else if (obj.ident) obj.query = \"??\" + obj.ident;else if (_typeof(obj.options) === \"object\" && obj.options.ident) obj.query = \"??\" + obj.options.ident;else obj.query = \"?\" + JSON.stringify(obj.options);\n      }\n    }\n  });\n  obj.request = loader;\n\n  if (Object.preventExtensions) {\n    Object.preventExtensions(obj);\n  }\n\n  return obj;\n}\n\nfunction runSyncOrAsync(fn, context, args, callback) {\n  var isSync = true;\n  var isDone = false;\n  var isError = false; // internal error\n\n  var reportedError = false;\n\n  context.async = function async() {\n    if (isDone) {\n      if (reportedError) return; // ignore\n\n      throw new Error(\"async(): The callback was already called.\");\n    }\n\n    isSync = false;\n    return innerCallback;\n  };\n\n  var innerCallback = context.callback = function () {\n    if (isDone) {\n      if (reportedError) return; // ignore\n\n      throw new Error(\"callback(): The callback was already called.\");\n    }\n\n    isDone = true;\n    isSync = false;\n\n    try {\n      callback.apply(null, arguments);\n    } catch (e) {\n      isError = true;\n      throw e;\n    }\n  };\n\n  try {\n    var result = function LOADER_EXECUTION() {\n      return fn.apply(context, args);\n    }();\n\n    if (isSync) {\n      isDone = true;\n      if (result === undefined) return callback();\n\n      if (result && _typeof(result) === \"object\" && typeof result.then === \"function\") {\n        return result.then(function (r) {\n          callback(null, r);\n        }, callback);\n      }\n\n      return callback(null, result);\n    }\n  } catch (e) {\n    if (isError) throw e;\n\n    if (isDone) {\n      // loader is already \"done\", so we cannot use the callback function\n      // for better debugging we print the error on the console\n      if (_typeof(e) === \"object\" && e.stack) console.error(e.stack);else console.error(e);\n      return;\n    }\n\n    isDone = true;\n    reportedError = true;\n    callback(e);\n  }\n}\n\nfunction convertArgs(args, raw) {\n  if (!raw && Buffer.isBuffer(args[0])) args[0] = utf8BufferToString(args[0]);else if (raw && typeof args[0] === \"string\") args[0] = new Buffer(args[0], \"utf-8\"); // eslint-disable-line\n}\n\nfunction iteratePitchingLoaders(options, loaderContext, callback) {\n  // abort after last loader\n  if (loaderContext.loaderIndex >= loaderContext.loaders.length) return processResource(options, loaderContext, callback);\n  var currentLoaderObject = loaderContext.loaders[loaderContext.loaderIndex]; // iterate\n\n  if (currentLoaderObject.pitchExecuted) {\n    loaderContext.loaderIndex++;\n    return iteratePitchingLoaders(options, loaderContext, callback);\n  } // load loader module\n\n\n  loadLoader(currentLoaderObject, function (err) {\n    if (err) {\n      loaderContext.cacheable(false);\n      return callback(err);\n    }\n\n    var fn = currentLoaderObject.pitch;\n    currentLoaderObject.pitchExecuted = true;\n    if (!fn) return iteratePitchingLoaders(options, loaderContext, callback);\n    runSyncOrAsync(fn, loaderContext, [loaderContext.remainingRequest, loaderContext.previousRequest, currentLoaderObject.data = {}], function (err) {\n      if (err) return callback(err);\n      var args = Array.prototype.slice.call(arguments, 1);\n\n      if (args.length > 0) {\n        loaderContext.loaderIndex--;\n        iterateNormalLoaders(options, loaderContext, args, callback);\n      } else {\n        iteratePitchingLoaders(options, loaderContext, callback);\n      }\n    });\n  });\n}\n\nfunction processResource(options, loaderContext, callback) {\n  // set loader index to last loader\n  loaderContext.loaderIndex = loaderContext.loaders.length - 1;\n  var resourcePath = loaderContext.resourcePath;\n\n  if (resourcePath) {\n    loaderContext.addDependency(resourcePath);\n    options.readResource(resourcePath, function (err, buffer) {\n      if (err) return callback(err);\n      options.resourceBuffer = buffer;\n      iterateNormalLoaders(options, loaderContext, [buffer], callback);\n    });\n  } else {\n    iterateNormalLoaders(options, loaderContext, [null], callback);\n  }\n}\n\nfunction iterateNormalLoaders(options, loaderContext, args, callback) {\n  if (loaderContext.loaderIndex < 0) return callback(null, args);\n  var currentLoaderObject = loaderContext.loaders[loaderContext.loaderIndex]; // iterate\n\n  if (currentLoaderObject.normalExecuted) {\n    loaderContext.loaderIndex--;\n    return iterateNormalLoaders(options, loaderContext, args, callback);\n  }\n\n  var fn = currentLoaderObject.normal;\n  currentLoaderObject.normalExecuted = true;\n\n  if (!fn) {\n    return iterateNormalLoaders(options, loaderContext, args, callback);\n  }\n\n  convertArgs(args, currentLoaderObject.raw);\n  runSyncOrAsync(fn, loaderContext, args, function (err) {\n    if (err) return callback(err);\n    var args = Array.prototype.slice.call(arguments, 1);\n    iterateNormalLoaders(options, loaderContext, args, callback);\n  });\n}\n\nexports.getContext = function getContext(resource) {\n  var splitted = splitQuery(resource);\n  return dirname(splitted[0]);\n};\n\nexports.runLoaders = function runLoaders(options, callback) {\n  // read options\n  var resource = options.resource || \"\";\n  var loaders = options.loaders || [];\n  var loaderContext = options.context || {};\n  var readResource = options.readResource || readFile; //\n\n  var splittedResource = resource && splitQuery(resource);\n  var resourcePath = splittedResource ? splittedResource[0] : undefined;\n  var resourceQuery = splittedResource ? splittedResource[1] : undefined;\n  var contextDirectory = resourcePath ? dirname(resourcePath) : null; // execution state\n\n  var requestCacheable = true;\n  var fileDependencies = [];\n  var contextDependencies = []; // prepare loader objects\n\n  loaders = loaders.map(createLoaderObject);\n  loaderContext.context = contextDirectory;\n  loaderContext.loaderIndex = 0;\n  loaderContext.loaders = loaders;\n  loaderContext.resourcePath = resourcePath;\n  loaderContext.resourceQuery = resourceQuery;\n  loaderContext.async = null;\n  loaderContext.callback = null;\n\n  loaderContext.cacheable = function cacheable(flag) {\n    if (flag === false) {\n      requestCacheable = false;\n    }\n  };\n\n  loaderContext.dependency = loaderContext.addDependency = function addDependency(file) {\n    fileDependencies.push(file);\n  };\n\n  loaderContext.addContextDependency = function addContextDependency(context) {\n    contextDependencies.push(context);\n  };\n\n  loaderContext.getDependencies = function getDependencies() {\n    return fileDependencies.slice();\n  };\n\n  loaderContext.getContextDependencies = function getContextDependencies() {\n    return contextDependencies.slice();\n  };\n\n  loaderContext.clearDependencies = function clearDependencies() {\n    fileDependencies.length = 0;\n    contextDependencies.length = 0;\n    requestCacheable = true;\n  };\n\n  Object.defineProperty(loaderContext, \"resource\", {\n    enumerable: true,\n    get: function get() {\n      if (loaderContext.resourcePath === undefined) return undefined;\n      return loaderContext.resourcePath + loaderContext.resourceQuery;\n    },\n    set: function set(value) {\n      var splittedResource = value && splitQuery(value);\n      loaderContext.resourcePath = splittedResource ? splittedResource[0] : undefined;\n      loaderContext.resourceQuery = splittedResource ? splittedResource[1] : undefined;\n    }\n  });\n  Object.defineProperty(loaderContext, \"request\", {\n    enumerable: true,\n    get: function get() {\n      return loaderContext.loaders.map(function (o) {\n        return o.request;\n      }).concat(loaderContext.resource || \"\").join(\"!\");\n    }\n  });\n  Object.defineProperty(loaderContext, \"remainingRequest\", {\n    enumerable: true,\n    get: function get() {\n      if (loaderContext.loaderIndex >= loaderContext.loaders.length - 1 && !loaderContext.resource) return \"\";\n      return loaderContext.loaders.slice(loaderContext.loaderIndex + 1).map(function (o) {\n        return o.request;\n      }).concat(loaderContext.resource || \"\").join(\"!\");\n    }\n  });\n  Object.defineProperty(loaderContext, \"currentRequest\", {\n    enumerable: true,\n    get: function get() {\n      return loaderContext.loaders.slice(loaderContext.loaderIndex).map(function (o) {\n        return o.request;\n      }).concat(loaderContext.resource || \"\").join(\"!\");\n    }\n  });\n  Object.defineProperty(loaderContext, \"previousRequest\", {\n    enumerable: true,\n    get: function get() {\n      return loaderContext.loaders.slice(0, loaderContext.loaderIndex).map(function (o) {\n        return o.request;\n      }).join(\"!\");\n    }\n  });\n  Object.defineProperty(loaderContext, \"query\", {\n    enumerable: true,\n    get: function get() {\n      var entry = loaderContext.loaders[loaderContext.loaderIndex];\n      return entry.options && _typeof(entry.options) === \"object\" ? entry.options : entry.query;\n    }\n  });\n  Object.defineProperty(loaderContext, \"data\", {\n    enumerable: true,\n    get: function get() {\n      return loaderContext.loaders[loaderContext.loaderIndex].data;\n    }\n  }); // finish loader context\n\n  if (Object.preventExtensions) {\n    Object.preventExtensions(loaderContext);\n  }\n\n  var processOptions = {\n    resourceBuffer: null,\n    readResource: readResource\n  };\n  iteratePitchingLoaders(processOptions, loaderContext, function (err, result) {\n    if (err) {\n      return callback(err, {\n        cacheable: requestCacheable,\n        fileDependencies: fileDependencies,\n        contextDependencies: contextDependencies\n      });\n    }\n\n    callback(null, {\n      result: result,\n      resourceBuffer: processOptions.resourceBuffer,\n      cacheable: requestCacheable,\n      fileDependencies: fileDependencies,\n      contextDependencies: contextDependencies\n    });\n  });\n};","map":null,"metadata":{},"sourceType":"module"}