{"ast":null,"code":"\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _sourceMap = require(\"source-map\");\n\nvar _webpackSources = require(\"webpack-sources\");\n\nvar _RequestShortener = _interopRequireDefault(require(\"webpack/lib/RequestShortener\"));\n\nvar _ModuleFilenameHelpers = _interopRequireDefault(require(\"webpack/lib/ModuleFilenameHelpers\"));\n\nvar _schemaUtils = _interopRequireDefault(require(\"schema-utils\"));\n\nvar _serializeJavascript = _interopRequireDefault(require(\"serialize-javascript\"));\n\nvar _package = _interopRequireDefault(require(\"terser/package.json\"));\n\nvar _options = _interopRequireDefault(require(\"./options.json\"));\n\nvar _TaskRunner = _interopRequireDefault(require(\"./TaskRunner\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar warningRegex = /\\[.+:([0-9]+),([0-9]+)\\]/;\n\nvar TerserPlugin = /*#__PURE__*/function () {\n  function TerserPlugin() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, TerserPlugin);\n\n    (0, _schemaUtils[\"default\"])(_options[\"default\"], options, 'Terser Plugin');\n    var minify = options.minify,\n        _options$terserOption = options.terserOptions,\n        terserOptions = _options$terserOption === void 0 ? {} : _options$terserOption,\n        _options$test = options.test,\n        test = _options$test === void 0 ? /\\.m?js(\\?.*)?$/i : _options$test,\n        _options$chunkFilter = options.chunkFilter,\n        chunkFilter = _options$chunkFilter === void 0 ? function () {\n      return true;\n    } : _options$chunkFilter,\n        _options$warningsFilt = options.warningsFilter,\n        warningsFilter = _options$warningsFilt === void 0 ? function () {\n      return true;\n    } : _options$warningsFilt,\n        _options$extractComme = options.extractComments,\n        extractComments = _options$extractComme === void 0 ? false : _options$extractComme,\n        _options$sourceMap = options.sourceMap,\n        sourceMap = _options$sourceMap === void 0 ? false : _options$sourceMap,\n        _options$cache = options.cache,\n        cache = _options$cache === void 0 ? false : _options$cache,\n        _options$cacheKeys = options.cacheKeys,\n        cacheKeys = _options$cacheKeys === void 0 ? function (defaultCacheKeys) {\n      return defaultCacheKeys;\n    } : _options$cacheKeys,\n        _options$parallel = options.parallel,\n        parallel = _options$parallel === void 0 ? false : _options$parallel,\n        include = options.include,\n        exclude = options.exclude;\n    this.options = {\n      test: test,\n      chunkFilter: chunkFilter,\n      warningsFilter: warningsFilter,\n      extractComments: extractComments,\n      sourceMap: sourceMap,\n      cache: cache,\n      cacheKeys: cacheKeys,\n      parallel: parallel,\n      include: include,\n      exclude: exclude,\n      minify: minify,\n      terserOptions: _objectSpread({\n        output: {\n          comments: extractComments ? false : /^\\**!|@preserve|@license|@cc_on/i\n        }\n      }, terserOptions)\n    };\n  }\n\n  _createClass(TerserPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var _this = this;\n\n      var buildModuleFn = function buildModuleFn(moduleArg) {\n        // to get detailed location info about errors\n        moduleArg.useSourceMap = true;\n      };\n\n      var optimizeFn = function optimizeFn(compilation, chunks, callback) {\n        var taskRunner = new _TaskRunner[\"default\"]({\n          cache: _this.options.cache,\n          parallel: _this.options.parallel\n        });\n        var processedAssets = new WeakSet();\n        var tasks = [];\n        var chunkFilter = _this.options.chunkFilter;\n        Array.from(chunks).filter(function (chunk) {\n          return chunkFilter && chunkFilter(chunk);\n        }).reduce(function (acc, chunk) {\n          return acc.concat(chunk.files || []);\n        }, []).concat(compilation.additionalChunkAssets || []).filter(_ModuleFilenameHelpers[\"default\"].matchObject.bind(null, _this.options)).forEach(function (file) {\n          var inputSourceMap;\n          var asset = compilation.assets[file];\n\n          if (processedAssets.has(asset)) {\n            return;\n          }\n\n          try {\n            var input;\n\n            if (_this.options.sourceMap && asset.sourceAndMap) {\n              var _asset$sourceAndMap = asset.sourceAndMap(),\n                  source = _asset$sourceAndMap.source,\n                  map = _asset$sourceAndMap.map;\n\n              input = source;\n\n              if (TerserPlugin.isSourceMap(map)) {\n                inputSourceMap = map;\n              } else {\n                inputSourceMap = map;\n                compilation.warnings.push(new Error(\"\".concat(file, \" contains invalid source map\")));\n              }\n            } else {\n              input = asset.source();\n              inputSourceMap = null;\n            } // Handling comment extraction\n\n\n            var commentsFile = false;\n\n            if (_this.options.extractComments) {\n              commentsFile = _this.options.extractComments.filename || \"\".concat(file, \".LICENSE\");\n\n              if (typeof commentsFile === 'function') {\n                commentsFile = commentsFile(file);\n              }\n            }\n\n            var task = {\n              file: file,\n              input: input,\n              inputSourceMap: inputSourceMap,\n              commentsFile: commentsFile,\n              extractComments: _this.options.extractComments,\n              terserOptions: _this.options.terserOptions,\n              minify: _this.options.minify\n            };\n\n            if (_this.options.cache) {\n              var defaultCacheKeys = {\n                terser: _package[\"default\"].version,\n                node_version: process.version,\n                // eslint-disable-next-line global-require\n                'terser-webpack-plugin': require('../package.json').version,\n                'terser-webpack-plugin-options': _this.options,\n                hash: _crypto[\"default\"].createHash('md4').update(input).digest('hex')\n              };\n              task.cacheKeys = _this.options.cacheKeys(defaultCacheKeys, file);\n            }\n\n            tasks.push(task);\n          } catch (error) {\n            compilation.errors.push(TerserPlugin.buildError(error, file, TerserPlugin.buildSourceMap(inputSourceMap), new _RequestShortener[\"default\"](compiler.context)));\n          }\n        });\n        taskRunner.run(tasks, function (tasksError, results) {\n          if (tasksError) {\n            compilation.errors.push(tasksError);\n            return;\n          }\n\n          results.forEach(function (data, index) {\n            var _tasks$index = tasks[index],\n                file = _tasks$index.file,\n                input = _tasks$index.input,\n                inputSourceMap = _tasks$index.inputSourceMap,\n                commentsFile = _tasks$index.commentsFile;\n            var error = data.error,\n                map = data.map,\n                code = data.code,\n                warnings = data.warnings;\n            var extractedComments = data.extractedComments;\n            var sourceMap = null;\n\n            if (error || warnings && warnings.length > 0) {\n              sourceMap = TerserPlugin.buildSourceMap(inputSourceMap);\n            } // Handling results\n            // Error case: add errors, and go to next file\n\n\n            if (error) {\n              compilation.errors.push(TerserPlugin.buildError(error, file, sourceMap, new _RequestShortener[\"default\"](compiler.context)));\n              return;\n            }\n\n            var outputSource;\n\n            if (map) {\n              outputSource = new _webpackSources.SourceMapSource(code, file, JSON.parse(map), input, inputSourceMap, true);\n            } else {\n              outputSource = new _webpackSources.RawSource(code);\n            } // Write extracted comments to commentsFile\n\n\n            if (commentsFile && extractedComments && extractedComments.length > 0) {\n              if (commentsFile in compilation.assets) {\n                var commentsFileSource = compilation.assets[commentsFile].source();\n                extractedComments = extractedComments.filter(function (comment) {\n                  return !commentsFileSource.includes(comment);\n                });\n              }\n\n              if (extractedComments.length > 0) {\n                // Add a banner to the original file\n                if (_this.options.extractComments.banner !== false) {\n                  var banner = _this.options.extractComments.banner || \"For license information please see \".concat(_path[\"default\"].posix.basename(commentsFile));\n\n                  if (typeof banner === 'function') {\n                    banner = banner(commentsFile);\n                  }\n\n                  if (banner) {\n                    outputSource = new _webpackSources.ConcatSource(\"/*! \".concat(banner, \" */\\n\"), outputSource);\n                  }\n                }\n\n                var commentsSource = new _webpackSources.RawSource(\"\".concat(extractedComments.join('\\n\\n'), \"\\n\"));\n\n                if (commentsFile in compilation.assets) {\n                  // commentsFile already exists, append new comments...\n                  if (compilation.assets[commentsFile] instanceof _webpackSources.ConcatSource) {\n                    compilation.assets[commentsFile].add('\\n');\n                    compilation.assets[commentsFile].add(commentsSource);\n                  } else {\n                    compilation.assets[commentsFile] = new _webpackSources.ConcatSource(compilation.assets[commentsFile], '\\n', commentsSource);\n                  }\n                } else {\n                  compilation.assets[commentsFile] = commentsSource;\n                }\n              }\n            } // Updating assets\n\n\n            processedAssets.add(compilation.assets[file] = outputSource); // Handling warnings\n\n            if (warnings && warnings.length > 0) {\n              warnings.forEach(function (warning) {\n                var builtWarning = TerserPlugin.buildWarning(warning, file, sourceMap, new _RequestShortener[\"default\"](compiler.context), _this.options.warningsFilter);\n\n                if (builtWarning) {\n                  compilation.warnings.push(builtWarning);\n                }\n              });\n            }\n          });\n          taskRunner.exit();\n          callback();\n        });\n      };\n\n      var plugin = {\n        name: this.constructor.name\n      };\n      compiler.hooks.compilation.tap(plugin, function (compilation) {\n        if (_this.options.sourceMap) {\n          compilation.hooks.buildModule.tap(plugin, buildModuleFn);\n        }\n\n        var mainTemplate = compilation.mainTemplate,\n            chunkTemplate = compilation.chunkTemplate; // Regenerate `contenthash` for minified assets\n\n        for (var _i = 0, _arr = [mainTemplate, chunkTemplate]; _i < _arr.length; _i++) {\n          var template = _arr[_i];\n          template.hooks.hashForChunk.tap(plugin, function (hash) {\n            var data = (0, _serializeJavascript[\"default\"])({\n              terser: _package[\"default\"].version,\n              terserOptions: _this.options.terserOptions\n            });\n            hash.update('TerserPlugin');\n            hash.update(data);\n          });\n        }\n\n        compilation.hooks.optimizeChunkAssets.tapAsync(plugin, optimizeFn.bind(_this, compilation));\n      });\n    }\n  }], [{\n    key: \"isSourceMap\",\n    value: function isSourceMap(input) {\n      // All required options for `new SourceMapConsumer(...options)`\n      // https://github.com/mozilla/source-map#new-sourcemapconsumerrawsourcemap\n      return Boolean(input && input.version && input.sources && Array.isArray(input.sources) && typeof input.mappings === 'string');\n    }\n  }, {\n    key: \"buildSourceMap\",\n    value: function buildSourceMap(inputSourceMap) {\n      if (!inputSourceMap || !TerserPlugin.isSourceMap(inputSourceMap)) {\n        return null;\n      }\n\n      return new _sourceMap.SourceMapConsumer(inputSourceMap);\n    }\n  }, {\n    key: \"buildError\",\n    value: function buildError(err, file, sourceMap, requestShortener) {\n      // Handling error which should have line, col, filename and message\n      if (err.line) {\n        var original = sourceMap && sourceMap.originalPositionFor({\n          line: err.line,\n          column: err.col\n        });\n\n        if (original && original.source && requestShortener) {\n          return new Error(\"\".concat(file, \" from Terser\\n\").concat(err.message, \" [\").concat(requestShortener.shorten(original.source), \":\").concat(original.line, \",\").concat(original.column, \"][\").concat(file, \":\").concat(err.line, \",\").concat(err.col, \"]\"));\n        }\n\n        return new Error(\"\".concat(file, \" from Terser\\n\").concat(err.message, \" [\").concat(file, \":\").concat(err.line, \",\").concat(err.col, \"]\"));\n      } else if (err.stack) {\n        return new Error(\"\".concat(file, \" from Terser\\n\").concat(err.stack));\n      }\n\n      return new Error(\"\".concat(file, \" from Terser\\n\").concat(err.message));\n    }\n  }, {\n    key: \"buildWarning\",\n    value: function buildWarning(warning, file, sourceMap, requestShortener, warningsFilter) {\n      var warningMessage = warning;\n      var locationMessage = '';\n      var source = null;\n\n      if (sourceMap) {\n        var match = warningRegex.exec(warning);\n\n        if (match) {\n          var line = +match[1];\n          var column = +match[2];\n          var original = sourceMap.originalPositionFor({\n            line: line,\n            column: column\n          });\n\n          if (original && original.source && original.source !== file && requestShortener) {\n            source = original.source;\n            warningMessage = \"\".concat(warningMessage.replace(warningRegex, ''));\n            locationMessage = \"[\".concat(requestShortener.shorten(original.source), \":\").concat(original.line, \",\").concat(original.column, \"]\");\n          }\n        }\n      }\n\n      if (warningsFilter && !warningsFilter(warning, source)) {\n        return null;\n      }\n\n      return \"Terser Plugin: \".concat(warningMessage).concat(locationMessage);\n    }\n  }]);\n\n  return TerserPlugin;\n}();\n\nvar _default = TerserPlugin;\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"module"}