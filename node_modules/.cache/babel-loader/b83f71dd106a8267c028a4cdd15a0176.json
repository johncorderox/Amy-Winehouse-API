{"ast":null,"code":"var fs = require('graceful-fs');\n\nvar Writable = require('readable-stream').Writable;\n\nvar util = require('util');\n\nvar MurmurHash3 = require('imurmurhash');\n\nvar iferr = require('iferr');\n\nvar crypto = require('crypto');\n\nfunction murmurhex() {\n  var hash = MurmurHash3('');\n\n  for (var ii = 0; ii < arguments.length; ++ii) {\n    hash.hash('' + arguments[ii]);\n  }\n\n  return hash.result();\n}\n\nvar invocations = 0;\n\nfunction getTmpname(filename) {\n  return filename + '.' + murmurhex(__filename, process.pid, ++invocations);\n}\n\nvar setImmediate = global.setImmediate || setTimeout;\nmodule.exports = WriteStreamAtomic; // Requirements:\n//   1. Write everything written to the stream to a temp file.\n//   2. If there are no errors:\n//      a. moves the temp file into its final destination\n//      b. emits `finish` & `closed` ONLY after the file is\n//         fully flushed and renamed.\n//   3. If there's an error, removes the temp file.\n\nutil.inherits(WriteStreamAtomic, Writable);\n\nfunction WriteStreamAtomic(path, options) {\n  if (!(this instanceof WriteStreamAtomic)) {\n    return new WriteStreamAtomic(path, options);\n  }\n\n  Writable.call(this, options);\n  this.__isWin = options && options.hasOwnProperty('isWin') ? options.isWin : process.platform === 'win32';\n  this.__atomicTarget = path;\n  this.__atomicTmp = getTmpname(path);\n  this.__atomicChown = options && options.chown;\n  this.__atomicClosed = false;\n  this.__atomicStream = fs.WriteStream(this.__atomicTmp, options);\n\n  this.__atomicStream.once('open', handleOpen(this));\n\n  this.__atomicStream.once('close', handleClose(this));\n\n  this.__atomicStream.once('error', handleError(this));\n} // We have to suppress default finish emitting, because ordinarily it\n// would happen as soon as `end` is called on us and all of the\n// data has been written to our target stream. So we suppress\n// finish from being emitted here, and only emit it after our\n// target stream is closed and we've moved everything around.\n\n\nWriteStreamAtomic.prototype.emit = function (event) {\n  if (event === 'finish') return this.__atomicStream.end();\n  return Writable.prototype.emit.apply(this, arguments);\n};\n\nWriteStreamAtomic.prototype._write = function (buffer, encoding, cb) {\n  var flushed = this.__atomicStream.write(buffer, encoding);\n\n  if (flushed) return cb();\n\n  this.__atomicStream.once('drain', cb);\n};\n\nfunction handleOpen(writeStream) {\n  return function (fd) {\n    writeStream.emit('open', fd);\n  };\n}\n\nfunction handleClose(writeStream) {\n  return function () {\n    if (writeStream.__atomicClosed) return;\n    writeStream.__atomicClosed = true;\n\n    if (writeStream.__atomicChown) {\n      var uid = writeStream.__atomicChown.uid;\n      var gid = writeStream.__atomicChown.gid;\n      return fs.chown(writeStream.__atomicTmp, uid, gid, iferr(cleanup, moveIntoPlace));\n    } else {\n      moveIntoPlace();\n    }\n  };\n\n  function moveIntoPlace() {\n    fs.rename(writeStream.__atomicTmp, writeStream.__atomicTarget, iferr(trapWindowsEPERM, end));\n  }\n\n  function trapWindowsEPERM(err) {\n    if (writeStream.__isWin && err.syscall && err.syscall === 'rename' && err.code && err.code === 'EPERM') {\n      checkFileHashes(err);\n    } else {\n      cleanup(err);\n    }\n  }\n\n  function checkFileHashes(eperm) {\n    var inprocess = 2;\n    var tmpFileHash = crypto.createHash('sha512');\n    var targetFileHash = crypto.createHash('sha512');\n    fs.createReadStream(writeStream.__atomicTmp).on('data', function (data, enc) {\n      tmpFileHash.update(data, enc);\n    }).on('error', fileHashError).on('end', fileHashComplete);\n    fs.createReadStream(writeStream.__atomicTarget).on('data', function (data, enc) {\n      targetFileHash.update(data, enc);\n    }).on('error', fileHashError).on('end', fileHashComplete);\n\n    function fileHashError() {\n      if (inprocess === 0) return;\n      inprocess = 0;\n      cleanup(eperm);\n    }\n\n    function fileHashComplete() {\n      if (inprocess === 0) return;\n      if (--inprocess) return;\n\n      if (tmpFileHash.digest('hex') === targetFileHash.digest('hex')) {\n        return cleanup();\n      } else {\n        return cleanup(eperm);\n      }\n    }\n  }\n\n  function cleanup(err) {\n    fs.unlink(writeStream.__atomicTmp, function () {\n      if (err) {\n        writeStream.emit('error', err);\n        writeStream.emit('close');\n      } else {\n        end();\n      }\n    });\n  }\n\n  function end() {\n    // We have to use our parent class directly because we suppress `finish`\n    // events fired via our own emit method.\n    Writable.prototype.emit.call(writeStream, 'finish'); // Delay the close to provide the same temporal separation a physical\n    // file operation would haveâ€“ that is, the close event is emitted only\n    // after the async close operation completes.\n\n    setImmediate(function () {\n      writeStream.emit('close');\n    });\n  }\n}\n\nfunction handleError(writeStream) {\n  return function (er) {\n    cleanupSync();\n    writeStream.emit('error', er);\n    writeStream.__atomicClosed = true;\n    writeStream.emit('close');\n  };\n\n  function cleanupSync() {\n    try {\n      fs.unlinkSync(writeStream.__atomicTmp);\n    } finally {\n      return;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module"}