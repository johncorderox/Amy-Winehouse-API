{"ast":null,"code":"\"use strict\";\n\nfunction _defineProperty2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _terser = require(\"terser\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar buildTerserOptions = function buildTerserOptions() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      ecma = _ref.ecma,\n      warnings = _ref.warnings,\n      _ref$parse = _ref.parse,\n      parse = _ref$parse === void 0 ? {} : _ref$parse,\n      _ref$compress = _ref.compress,\n      compress = _ref$compress === void 0 ? {} : _ref$compress,\n      mangle = _ref.mangle,\n      module = _ref.module,\n      output = _ref.output,\n      toplevel = _ref.toplevel,\n      nameCache = _ref.nameCache,\n      ie8 = _ref.ie8,\n      keep_classnames = _ref.keep_classnames,\n      keep_fnames = _ref.keep_fnames,\n      safari10 = _ref.safari10;\n\n  return {\n    ecma: ecma,\n    warnings: warnings,\n    parse: _objectSpread({}, parse),\n    compress: typeof compress === 'boolean' ? compress : _objectSpread({}, compress),\n    // eslint-disable-next-line no-nested-ternary\n    mangle: mangle == null ? true : typeof mangle === 'boolean' ? mangle : _objectSpread({}, mangle),\n    output: _objectSpread({\n      shebang: true,\n      comments: false,\n      beautify: false,\n      semicolons: true\n    }, output),\n    module: module,\n    // Ignoring sourceMap from options\n    sourceMap: null,\n    toplevel: toplevel,\n    nameCache: nameCache,\n    ie8: ie8,\n    keep_classnames: keep_classnames,\n    keep_fnames: keep_fnames,\n    safari10: safari10\n  };\n};\n\nvar buildComments = function buildComments(options, terserOptions, extractedComments) {\n  var condition = {};\n  var commentsOpts = terserOptions.output.comments; // Use /^\\**!|@preserve|@license|@cc_on/i RegExp\n\n  if (typeof options.extractComments === 'boolean') {\n    condition.preserve = commentsOpts;\n    condition.extract = /^\\**!|@preserve|@license|@cc_on/i;\n  } else if (typeof options.extractComments === 'string' || options.extractComments instanceof RegExp) {\n    // extractComments specifies the extract condition and commentsOpts specifies the preserve condition\n    condition.preserve = commentsOpts;\n    condition.extract = options.extractComments;\n  } else if (typeof options.extractComments === 'function') {\n    condition.preserve = commentsOpts;\n    condition.extract = options.extractComments;\n  } else if (Object.prototype.hasOwnProperty.call(options.extractComments, 'condition')) {\n    // Extract condition is given in extractComments.condition\n    condition.preserve = commentsOpts;\n    condition.extract = options.extractComments.condition;\n  } else {\n    // No extract condition is given. Extract comments that match commentsOpts instead of preserving them\n    condition.preserve = false;\n    condition.extract = commentsOpts;\n  } // Ensure that both conditions are functions\n\n\n  ['preserve', 'extract'].forEach(function (key) {\n    var regexStr;\n    var regex;\n\n    switch (_typeof(condition[key])) {\n      case 'boolean':\n        condition[key] = condition[key] ? function () {\n          return true;\n        } : function () {\n          return false;\n        };\n        break;\n\n      case 'function':\n        break;\n\n      case 'string':\n        if (condition[key] === 'all') {\n          condition[key] = function () {\n            return true;\n          };\n\n          break;\n        }\n\n        if (condition[key] === 'some') {\n          condition[key] = function (astNode, comment) {\n            return comment.type === 'comment2' && /^\\**!|@preserve|@license|@cc_on/i.test(comment.value);\n          };\n\n          break;\n        }\n\n        regexStr = condition[key];\n\n        condition[key] = function (astNode, comment) {\n          return new RegExp(regexStr).test(comment.value);\n        };\n\n        break;\n\n      default:\n        regex = condition[key];\n\n        condition[key] = function (astNode, comment) {\n          return regex.test(comment.value);\n        };\n\n    }\n  }); // Redefine the comments function to extract and preserve\n  // comments according to the two conditions\n\n  return function (astNode, comment) {\n    if (condition.extract(astNode, comment)) {\n      var commentText = comment.type === 'comment2' ? \"/*\".concat(comment.value, \"*/\") : \"//\".concat(comment.value); // Don't include duplicate comments\n\n      if (!extractedComments.includes(commentText)) {\n        extractedComments.push(commentText);\n      }\n    }\n\n    return condition.preserve(astNode, comment);\n  };\n};\n\nvar minify = function minify(options) {\n  var file = options.file,\n      input = options.input,\n      inputSourceMap = options.inputSourceMap,\n      extractComments = options.extractComments,\n      minifyFn = options.minify;\n\n  if (minifyFn) {\n    return minifyFn(_defineProperty2({}, file, input), inputSourceMap);\n  } // Copy terser options\n\n\n  var terserOptions = buildTerserOptions(options.terserOptions); // Let terser generate a SourceMap\n\n  if (inputSourceMap) {\n    terserOptions.sourceMap = true;\n  }\n\n  var extractedComments = [];\n\n  if (extractComments) {\n    terserOptions.output.comments = buildComments(options, terserOptions, extractedComments);\n  }\n\n  var _ref2 = (0, _terser.minify)(_defineProperty2({}, file, input), terserOptions),\n      error = _ref2.error,\n      map = _ref2.map,\n      code = _ref2.code,\n      warnings = _ref2.warnings;\n\n  return {\n    error: error,\n    map: map,\n    code: code,\n    warnings: warnings,\n    extractedComments: extractedComments\n  };\n};\n\nvar _default = minify;\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"module"}