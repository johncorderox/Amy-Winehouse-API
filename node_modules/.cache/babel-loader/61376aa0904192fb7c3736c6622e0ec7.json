{"ast":null,"code":"import { FSM, makeTransition } from \"@webassemblyjs/helper-fsm\";\nimport { codeFrameFromSource } from \"@webassemblyjs/helper-code-frame\"; // eslint-disable-next-line\n\nfunction getCodeFrame(source, line, column) {\n  var loc = {\n    start: {\n      line: line,\n      column: column\n    }\n  };\n  return \"\\n\" + codeFrameFromSource(source, loc) + \"\\n\";\n}\n\nvar WHITESPACE = /\\s/;\nvar PARENS = /\\(|\\)/;\nvar LETTERS = /[a-z0-9_/]/i;\nvar idchar = /[a-z0-9!#$%&*+./:<=>?@\\\\[\\]^_`|~-]/i;\nvar valtypes = [\"i32\", \"i64\", \"f32\", \"f64\"];\nvar NUMBERS = /[0-9|.|_]/;\nvar NUMBER_KEYWORDS = /nan|inf/;\n\nfunction isNewLine(_char) {\n  return _char.charCodeAt(0) === 10 || _char.charCodeAt(0) === 13;\n}\n\nfunction Token(type, value, start, end) {\n  var opts = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  var token = {\n    type: type,\n    value: value,\n    loc: {\n      start: start,\n      end: end\n    }\n  };\n\n  if (Object.keys(opts).length > 0) {\n    // $FlowIgnore\n    token[\"opts\"] = opts;\n  }\n\n  return token;\n}\n\nvar tokenTypes = {\n  openParen: \"openParen\",\n  closeParen: \"closeParen\",\n  number: \"number\",\n  string: \"string\",\n  name: \"name\",\n  identifier: \"identifier\",\n  valtype: \"valtype\",\n  dot: \"dot\",\n  comment: \"comment\",\n  equal: \"equal\",\n  keyword: \"keyword\"\n};\nexport var keywords = {\n  module: \"module\",\n  func: \"func\",\n  param: \"param\",\n  result: \"result\",\n  \"export\": \"export\",\n  loop: \"loop\",\n  block: \"block\",\n  \"if\": \"if\",\n  then: \"then\",\n  \"else\": \"else\",\n  call: \"call\",\n  call_indirect: \"call_indirect\",\n  \"import\": \"import\",\n  memory: \"memory\",\n  table: \"table\",\n  global: \"global\",\n  anyfunc: \"anyfunc\",\n  mut: \"mut\",\n  data: \"data\",\n  type: \"type\",\n  elem: \"elem\",\n  start: \"start\",\n  offset: \"offset\"\n};\nvar NUMERIC_SEPARATOR = \"_\";\n/**\n * Build the FSM for number literals\n */\n\nvar numberLiteralFSM = new FSM({\n  START: [makeTransition(/-|\\+/, \"AFTER_SIGN\"), makeTransition(/nan:0x/, \"NAN_HEX\", {\n    n: 6\n  }), makeTransition(/nan|inf/, \"STOP\", {\n    n: 3\n  }), makeTransition(/0x/, \"HEX\", {\n    n: 2\n  }), makeTransition(/[0-9]/, \"DEC\"), makeTransition(/\\./, \"DEC_FRAC\")],\n  AFTER_SIGN: [makeTransition(/nan:0x/, \"NAN_HEX\", {\n    n: 6\n  }), makeTransition(/nan|inf/, \"STOP\", {\n    n: 3\n  }), makeTransition(/0x/, \"HEX\", {\n    n: 2\n  }), makeTransition(/[0-9]/, \"DEC\"), makeTransition(/\\./, \"DEC_FRAC\")],\n  DEC_FRAC: [makeTransition(/[0-9]/, \"DEC_FRAC\", {\n    allowedSeparator: NUMERIC_SEPARATOR\n  }), makeTransition(/e|E/, \"DEC_SIGNED_EXP\")],\n  DEC: [makeTransition(/[0-9]/, \"DEC\", {\n    allowedSeparator: NUMERIC_SEPARATOR\n  }), makeTransition(/\\./, \"DEC_FRAC\"), makeTransition(/e|E/, \"DEC_SIGNED_EXP\")],\n  DEC_SIGNED_EXP: [makeTransition(/\\+|-/, \"DEC_EXP\"), makeTransition(/[0-9]/, \"DEC_EXP\")],\n  DEC_EXP: [makeTransition(/[0-9]/, \"DEC_EXP\", {\n    allowedSeparator: NUMERIC_SEPARATOR\n  })],\n  HEX: [makeTransition(/[0-9|A-F|a-f]/, \"HEX\", {\n    allowedSeparator: NUMERIC_SEPARATOR\n  }), makeTransition(/\\./, \"HEX_FRAC\"), makeTransition(/p|P/, \"HEX_SIGNED_EXP\")],\n  HEX_FRAC: [makeTransition(/[0-9|A-F|a-f]/, \"HEX_FRAC\", {\n    allowedSeparator: NUMERIC_SEPARATOR\n  }), makeTransition(/p|P|/, \"HEX_SIGNED_EXP\")],\n  HEX_SIGNED_EXP: [makeTransition(/[0-9|+|-]/, \"HEX_EXP\")],\n  HEX_EXP: [makeTransition(/[0-9]/, \"HEX_EXP\", {\n    allowedSeparator: NUMERIC_SEPARATOR\n  })],\n  NAN_HEX: [makeTransition(/[0-9|A-F|a-f]/, \"NAN_HEX\", {\n    allowedSeparator: NUMERIC_SEPARATOR\n  })],\n  STOP: []\n}, \"START\", \"STOP\");\nexport function tokenize(input) {\n  var current = 0;\n  var _char2 = input[current]; // Used by SourceLocation\n\n  var column = 1;\n  var line = 1;\n  var tokens = [];\n  /**\n   * Creates a pushToken function for a given type\n   */\n\n  function pushToken(type) {\n    return function (v) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var startColumn = opts.startColumn || column - String(v).length;\n      delete opts.startColumn;\n      var endColumn = opts.endColumn || startColumn + String(v).length - 1;\n      delete opts.endColumn;\n      var start = {\n        line: line,\n        column: startColumn\n      };\n      var end = {\n        line: line,\n        column: endColumn\n      };\n      tokens.push(Token(type, v, start, end, opts));\n    };\n  }\n  /**\n   * Functions to save newly encountered tokens\n   */\n\n\n  var pushCloseParenToken = pushToken(tokenTypes.closeParen);\n  var pushOpenParenToken = pushToken(tokenTypes.openParen);\n  var pushNumberToken = pushToken(tokenTypes.number);\n  var pushValtypeToken = pushToken(tokenTypes.valtype);\n  var pushNameToken = pushToken(tokenTypes.name);\n  var pushIdentifierToken = pushToken(tokenTypes.identifier);\n  var pushKeywordToken = pushToken(tokenTypes.keyword);\n  var pushDotToken = pushToken(tokenTypes.dot);\n  var pushStringToken = pushToken(tokenTypes.string);\n  var pushCommentToken = pushToken(tokenTypes.comment);\n  var pushEqualToken = pushToken(tokenTypes.equal);\n  /**\n   * Can be used to look at the next character(s).\n   *\n   * The default behavior `lookahead()` simply returns the next character without consuming it.\n   * Letters are always returned in lowercase.\n   *\n   * @param {number} length How many characters to query. Default = 1\n   * @param {number} offset How many characters to skip forward from current one. Default = 1\n   *\n   */\n\n  function lookahead() {\n    var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    return input.substring(current + offset, current + offset + length).toLowerCase();\n  }\n  /**\n   * Advances the cursor in the input by a certain amount\n   *\n   * @param {number} amount How many characters to consume. Default = 1\n   */\n\n\n  function eatCharacter() {\n    var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    column += amount;\n    current += amount;\n    _char2 = input[current];\n  }\n\n  while (current < input.length) {\n    // ;;\n    if (_char2 === \";\" && lookahead() === \";\") {\n      var startColumn = column;\n      eatCharacter(2);\n      var text = \"\";\n\n      while (!isNewLine(_char2)) {\n        text += _char2;\n        eatCharacter();\n\n        if (_char2 === undefined) {\n          break;\n        }\n      }\n\n      var endColumn = column;\n      pushCommentToken(text, {\n        type: \"leading\",\n        startColumn: startColumn,\n        endColumn: endColumn\n      });\n      continue;\n    } // (;\n\n\n    if (_char2 === \"(\" && lookahead() === \";\") {\n      var _startColumn = column;\n      eatCharacter(2);\n      var _text = \"\"; // ;)\n\n      while (true) {\n        _char2 = input[current];\n\n        if (_char2 === \";\" && lookahead() === \")\") {\n          eatCharacter(2);\n          break;\n        }\n\n        _text += _char2;\n        eatCharacter();\n\n        if (isNewLine(_char2)) {\n          line++;\n          column = 0;\n        }\n      }\n\n      var _endColumn = column;\n      pushCommentToken(_text, {\n        type: \"block\",\n        startColumn: _startColumn,\n        endColumn: _endColumn\n      });\n      continue;\n    }\n\n    if (_char2 === \"(\") {\n      pushOpenParenToken(_char2);\n      eatCharacter();\n      continue;\n    }\n\n    if (_char2 === \"=\") {\n      pushEqualToken(_char2);\n      eatCharacter();\n      continue;\n    }\n\n    if (_char2 === \")\") {\n      pushCloseParenToken(_char2);\n      eatCharacter();\n      continue;\n    }\n\n    if (isNewLine(_char2)) {\n      line++;\n      eatCharacter();\n      column = 0;\n      continue;\n    }\n\n    if (WHITESPACE.test(_char2)) {\n      eatCharacter();\n      continue;\n    }\n\n    if (_char2 === \"$\") {\n      var _startColumn2 = column;\n      eatCharacter();\n      var value = \"\";\n\n      while (idchar.test(_char2)) {\n        value += _char2;\n        eatCharacter();\n      }\n\n      var _endColumn2 = column;\n      pushIdentifierToken(value, {\n        startColumn: _startColumn2,\n        endColumn: _endColumn2\n      });\n      continue;\n    }\n\n    if (NUMBERS.test(_char2) || NUMBER_KEYWORDS.test(lookahead(3, 0)) || _char2 === \"-\" || _char2 === \"+\") {\n      var _startColumn3 = column;\n\n      var _value = numberLiteralFSM.run(input.slice(current));\n\n      if (_value === \"\") {\n        throw new Error(getCodeFrame(input, line, column) + \"Unexpected character \" + JSON.stringify(_char2));\n      }\n\n      pushNumberToken(_value, {\n        startColumn: _startColumn3\n      });\n      eatCharacter(_value.length);\n\n      if (_char2 && !PARENS.test(_char2) && !WHITESPACE.test(_char2)) {\n        throw new Error(getCodeFrame(input, line, column) + \"Unexpected character \" + JSON.stringify(_char2));\n      }\n\n      continue;\n    }\n\n    if (_char2 === '\"') {\n      var _startColumn4 = column;\n      var _value2 = \"\";\n      eatCharacter(); // \"\n\n      while (_char2 !== '\"') {\n        if (isNewLine(_char2)) {\n          throw new Error(getCodeFrame(input, line, column) + \"Unexpected character \" + JSON.stringify(_char2));\n        }\n\n        _value2 += _char2;\n        eatCharacter(); // char\n      }\n\n      eatCharacter(); // \"\n\n      var _endColumn3 = column;\n      pushStringToken(_value2, {\n        startColumn: _startColumn4,\n        endColumn: _endColumn3\n      });\n      continue;\n    }\n\n    if (LETTERS.test(_char2)) {\n      var _value3 = \"\";\n      var _startColumn5 = column;\n\n      while (_char2 && LETTERS.test(_char2)) {\n        _value3 += _char2;\n        eatCharacter();\n      }\n      /*\n       * Handle MemberAccess\n       */\n\n\n      if (_char2 === \".\") {\n        var dotStartColumn = column;\n\n        if (valtypes.indexOf(_value3) !== -1) {\n          pushValtypeToken(_value3, {\n            startColumn: _startColumn5\n          });\n        } else {\n          pushNameToken(_value3);\n        }\n\n        eatCharacter();\n        _value3 = \"\";\n        var nameStartColumn = column;\n\n        while (LETTERS.test(_char2)) {\n          _value3 += _char2;\n          eatCharacter();\n        }\n\n        pushDotToken(\".\", {\n          startColumn: dotStartColumn\n        });\n        pushNameToken(_value3, {\n          startColumn: nameStartColumn\n        });\n        continue;\n      }\n      /*\n       * Handle keywords\n       */\n      // $FlowIgnore\n\n\n      if (typeof keywords[_value3] === \"string\") {\n        pushKeywordToken(_value3, {\n          startColumn: _startColumn5\n        });\n        continue;\n      }\n      /*\n       * Handle types\n       */\n\n\n      if (valtypes.indexOf(_value3) !== -1) {\n        pushValtypeToken(_value3, {\n          startColumn: _startColumn5\n        });\n        continue;\n      }\n      /*\n       * Handle literals\n       */\n\n\n      pushNameToken(_value3, {\n        startColumn: _startColumn5\n      });\n      continue;\n    }\n\n    throw new Error(getCodeFrame(input, line, column) + \"Unexpected character \" + JSON.stringify(_char2));\n  }\n\n  return tokens;\n}\nexport var tokens = tokenTypes;","map":null,"metadata":{},"sourceType":"module"}