{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar crypto = require(\"crypto\");\n\nvar SortableSet = require(\"../util/SortableSet\");\n\nvar GraphHelpers = require(\"../GraphHelpers\");\n\nvar _require = require(\"../util/SetHelpers\"),\n    isSubset = _require.isSubset;\n\nvar deterministicGrouping = require(\"../util/deterministicGrouping\");\n\nvar MinMaxSizeWarning = require(\"./MinMaxSizeWarning\");\n\nvar contextify = require(\"../util/identifier\").contextify;\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../util/deterministicGrouping\").Options<Module>} DeterministicGroupingOptionsForModule */\n\n/** @typedef {import(\"../util/deterministicGrouping\").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */\n\n\nvar deterministicGroupingForModules =\n/** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */\ndeterministicGrouping;\n\nvar hashFilename = function hashFilename(name) {\n  return crypto.createHash(\"md4\").update(name).digest(\"hex\").slice(0, 8);\n};\n\nvar sortByIdentifier = function sortByIdentifier(a, b) {\n  if (a.identifier() > b.identifier()) return 1;\n  if (a.identifier() < b.identifier()) return -1;\n  return 0;\n};\n\nvar getRequests = function getRequests(chunk) {\n  var requests = 0;\n\n  var _iterator = _createForOfIteratorHelper(chunk.groupsIterable),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var chunkGroup = _step.value;\n      requests = Math.max(requests, chunkGroup.chunks.length);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return requests;\n};\n\nvar getModulesSize = function getModulesSize(modules) {\n  var sum = 0;\n\n  var _iterator2 = _createForOfIteratorHelper(modules),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var m = _step2.value;\n      sum += m.size();\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return sum;\n};\n/**\n * @template T\n * @param {Set<T>} a set\n * @param {Set<T>} b other set\n * @returns {boolean} true if at least one item of a is in b\n */\n\n\nvar isOverlap = function isOverlap(a, b) {\n  var _iterator3 = _createForOfIteratorHelper(a),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var item = _step3.value;\n      if (b.has(item)) return true;\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return false;\n};\n\nvar compareEntries = function compareEntries(a, b) {\n  // 1. by priority\n  var diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;\n  if (diffPriority) return diffPriority; // 2. by number of chunks\n\n  var diffCount = a.chunks.size - b.chunks.size;\n  if (diffCount) return diffCount; // 3. by size reduction\n\n  var aSizeReduce = a.size * (a.chunks.size - 1);\n  var bSizeReduce = b.size * (b.chunks.size - 1);\n  var diffSizeReduce = aSizeReduce - bSizeReduce;\n  if (diffSizeReduce) return diffSizeReduce; // 4. by cache group index\n\n  var indexDiff = b.cacheGroupIndex - a.cacheGroupIndex;\n  if (indexDiff) return indexDiff; // 5. by number of modules (to be able to compare by identifier)\n\n  var modulesA = a.modules;\n  var modulesB = b.modules;\n  var diff = modulesA.size - modulesB.size;\n  if (diff) return diff; // 6. by module identifiers\n\n  modulesA.sort();\n  modulesB.sort();\n  var aI = modulesA[Symbol.iterator]();\n  var bI = modulesB[Symbol.iterator](); // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    var aItem = aI.next();\n    var bItem = bI.next();\n    if (aItem.done) return 0;\n    var aModuleIdentifier = aItem.value.identifier();\n    var bModuleIdentifier = bItem.value.identifier();\n    if (aModuleIdentifier > bModuleIdentifier) return -1;\n    if (aModuleIdentifier < bModuleIdentifier) return 1;\n  }\n};\n\nvar compareNumbers = function compareNumbers(a, b) {\n  return a - b;\n};\n\nvar INITIAL_CHUNK_FILTER = function INITIAL_CHUNK_FILTER(chunk) {\n  return chunk.canBeInitial();\n};\n\nvar ASYNC_CHUNK_FILTER = function ASYNC_CHUNK_FILTER(chunk) {\n  return !chunk.canBeInitial();\n};\n\nvar ALL_CHUNK_FILTER = function ALL_CHUNK_FILTER(chunk) {\n  return true;\n};\n\nmodule.exports = /*#__PURE__*/function () {\n  function SplitChunksPlugin(options) {\n    _classCallCheck(this, SplitChunksPlugin);\n\n    this.options = SplitChunksPlugin.normalizeOptions(options);\n  }\n\n  _createClass(SplitChunksPlugin, [{\n    key: \"apply\",\n    value:\n    /**\n     * @param {Compiler} compiler webpack compiler\n     * @returns {void}\n     */\n    function apply(compiler) {\n      var _this = this;\n\n      compiler.hooks.thisCompilation.tap(\"SplitChunksPlugin\", function (compilation) {\n        var alreadyOptimized = false;\n        compilation.hooks.unseal.tap(\"SplitChunksPlugin\", function () {\n          alreadyOptimized = false;\n        });\n        compilation.hooks.optimizeChunksAdvanced.tap(\"SplitChunksPlugin\", function (chunks) {\n          if (alreadyOptimized) return;\n          alreadyOptimized = true; // Give each selected chunk an index (to create strings from chunks)\n\n          var indexMap = new Map();\n          var index = 1;\n\n          var _iterator4 = _createForOfIteratorHelper(chunks),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var chunk = _step4.value;\n              indexMap.set(chunk, index++);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n\n          var getKey = function getKey(chunks) {\n            return Array.from(chunks, function (c) {\n              return indexMap.get(c);\n            }).sort(compareNumbers).join();\n          };\n          /** @type {Map<string, Set<Chunk>>} */\n\n\n          var chunkSetsInGraph = new Map();\n\n          var _iterator5 = _createForOfIteratorHelper(compilation.modules),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _module = _step5.value;\n              var chunksKey = getKey(_module.chunksIterable);\n\n              if (!chunkSetsInGraph.has(chunksKey)) {\n                chunkSetsInGraph.set(chunksKey, new Set(_module.chunksIterable));\n              }\n            } // group these set of chunks by count\n            // to allow to check less sets via isSubset\n            // (only smaller sets can be subset)\n\n            /** @type {Map<number, Array<Set<Chunk>>>} */\n\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n\n          var chunkSetsByCount = new Map();\n\n          var _iterator6 = _createForOfIteratorHelper(chunkSetsInGraph.values()),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var chunksSet = _step6.value;\n              var count = chunksSet.size;\n              var array = chunkSetsByCount.get(count);\n\n              if (array === undefined) {\n                array = [];\n                chunkSetsByCount.set(count, array);\n              }\n\n              array.push(chunksSet);\n            } // Create a list of possible combinations\n\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n\n          var combinationsCache = new Map(); // Map<string, Set<Chunk>[]>\n\n          var getCombinations = function getCombinations(key) {\n            var chunksSet = chunkSetsInGraph.get(key);\n            var array = [chunksSet];\n\n            if (chunksSet.size > 1) {\n              var _iterator7 = _createForOfIteratorHelper(chunkSetsByCount),\n                  _step7;\n\n              try {\n                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                  var _ref3 = _step7.value;\n\n                  var _ref2 = _slicedToArray(_ref3, 2);\n\n                  var count = _ref2[0];\n                  var setArray = _ref2[1];\n\n                  // \"equal\" is not needed because they would have been merge in the first step\n                  if (count < chunksSet.size) {\n                    var _iterator8 = _createForOfIteratorHelper(setArray),\n                        _step8;\n\n                    try {\n                      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                        var set = _step8.value;\n\n                        if (isSubset(chunksSet, set)) {\n                          array.push(set);\n                        }\n                      }\n                    } catch (err) {\n                      _iterator8.e(err);\n                    } finally {\n                      _iterator8.f();\n                    }\n                  }\n                }\n              } catch (err) {\n                _iterator7.e(err);\n              } finally {\n                _iterator7.f();\n              }\n            }\n\n            return array;\n          };\n          /**\n           * @typedef {Object} SelectedChunksResult\n           * @property {Chunk[]} chunks the list of chunks\n           * @property {string} key a key of the list\n           */\n\n          /**\n           * @typedef {function(Chunk): boolean} ChunkFilterFunction\n           */\n\n          /** @type {WeakMap<Set<Chunk>, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */\n\n\n          var selectedChunksCacheByChunksSet = new WeakMap();\n          /**\n           * get list and key by applying the filter function to the list\n           * It is cached for performance reasons\n           * @param {Set<Chunk>} chunks list of chunks\n           * @param {ChunkFilterFunction} chunkFilter filter function for chunks\n           * @returns {SelectedChunksResult} list and key\n           */\n\n          var getSelectedChunks = function getSelectedChunks(chunks, chunkFilter) {\n            var entry = selectedChunksCacheByChunksSet.get(chunks);\n\n            if (entry === undefined) {\n              entry = new WeakMap();\n              selectedChunksCacheByChunksSet.set(chunks, entry);\n            }\n            /** @type {SelectedChunksResult} */\n\n\n            var entry2 = entry.get(chunkFilter);\n\n            if (entry2 === undefined) {\n              /** @type {Chunk[]} */\n              var selectedChunks = [];\n\n              var _iterator9 = _createForOfIteratorHelper(chunks),\n                  _step9;\n\n              try {\n                for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                  var chunk = _step9.value;\n                  if (chunkFilter(chunk)) selectedChunks.push(chunk);\n                }\n              } catch (err) {\n                _iterator9.e(err);\n              } finally {\n                _iterator9.f();\n              }\n\n              entry2 = {\n                chunks: selectedChunks,\n                key: getKey(selectedChunks)\n              };\n              entry.set(chunkFilter, entry2);\n            }\n\n            return entry2;\n          };\n          /**\n           * @typedef {Object} ChunksInfoItem\n           * @property {SortableSet} modules\n           * @property {TODO} cacheGroup\n           * @property {number} cacheGroupIndex\n           * @property {string} name\n           * @property {number} size\n           * @property {Set<Chunk>} chunks\n           * @property {Set<Chunk>} reuseableChunks\n           * @property {Set<string>} chunksKeys\n           */\n          // Map a list of chunks to a list of modules\n          // For the key the chunk \"index\" is used, the value is a SortableSet of modules\n\n          /** @type {Map<string, ChunksInfoItem>} */\n\n\n          var chunksInfoMap = new Map();\n          /**\n           * @param {TODO} cacheGroup the current cache group\n           * @param {number} cacheGroupIndex the index of the cache group of ordering\n           * @param {Chunk[]} selectedChunks chunks selected for this module\n           * @param {string} selectedChunksKey a key of selectedChunks\n           * @param {Module} module the current module\n           * @returns {void}\n           */\n\n          var addModuleToChunksInfoMap = function addModuleToChunksInfoMap(cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, module) {\n            // Break if minimum number of chunks is not reached\n            if (selectedChunks.length < cacheGroup.minChunks) return; // Determine name for split chunk\n\n            var name = cacheGroup.getName(module, selectedChunks, cacheGroup.key); // Create key for maps\n            // When it has a name we use the name as key\n            // Elsewise we create the key from chunks and cache group key\n            // This automatically merges equal names\n\n            var key = cacheGroup.key + (name ? \" name:\".concat(name) : \" chunks:\".concat(selectedChunksKey)); // Add module to maps\n\n            var info = chunksInfoMap.get(key);\n\n            if (info === undefined) {\n              chunksInfoMap.set(key, info = {\n                modules: new SortableSet(undefined, sortByIdentifier),\n                cacheGroup: cacheGroup,\n                cacheGroupIndex: cacheGroupIndex,\n                name: name,\n                size: 0,\n                chunks: new Set(),\n                reuseableChunks: new Set(),\n                chunksKeys: new Set()\n              });\n            }\n\n            var oldSize = info.modules.size;\n            info.modules.add(module);\n\n            if (info.modules.size !== oldSize) {\n              info.size += module.size();\n            }\n\n            var oldChunksKeysSize = info.chunksKeys.size;\n            info.chunksKeys.add(selectedChunksKey);\n\n            if (oldChunksKeysSize !== info.chunksKeys.size) {\n              var _iterator10 = _createForOfIteratorHelper(selectedChunks),\n                  _step10;\n\n              try {\n                for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n                  var chunk = _step10.value;\n                  info.chunks.add(chunk);\n                }\n              } catch (err) {\n                _iterator10.e(err);\n              } finally {\n                _iterator10.f();\n              }\n            }\n          }; // Walk through all modules\n\n\n          var _iterator11 = _createForOfIteratorHelper(compilation.modules),\n              _step11;\n\n          try {\n            for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n              var _module2 = _step11.value;\n\n              // Get cache group\n              var cacheGroups = _this.options.getCacheGroups(_module2);\n\n              if (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {\n                continue;\n              } // Prepare some values\n\n\n              var _chunksKey = getKey(_module2.chunksIterable);\n\n              var combs = combinationsCache.get(_chunksKey);\n\n              if (combs === undefined) {\n                combs = getCombinations(_chunksKey);\n                combinationsCache.set(_chunksKey, combs);\n              }\n\n              var cacheGroupIndex = 0;\n\n              var _iterator14 = _createForOfIteratorHelper(cacheGroups),\n                  _step14;\n\n              try {\n                for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n                  var cacheGroupSource = _step14.value;\n                  var minSize = cacheGroupSource.minSize !== undefined ? cacheGroupSource.minSize : cacheGroupSource.enforce ? 0 : _this.options.minSize;\n                  var enforceSizeThreshold = cacheGroupSource.enforceSizeThreshold !== undefined ? cacheGroupSource.enforceSizeThreshold : cacheGroupSource.enforce ? 0 : _this.options.enforceSizeThreshold;\n                  var cacheGroup = {\n                    key: cacheGroupSource.key,\n                    priority: cacheGroupSource.priority || 0,\n                    chunksFilter: cacheGroupSource.chunksFilter || _this.options.chunksFilter,\n                    minSize: minSize,\n                    minSizeForMaxSize: cacheGroupSource.minSize !== undefined ? cacheGroupSource.minSize : _this.options.minSize,\n                    enforceSizeThreshold: enforceSizeThreshold,\n                    maxSize: cacheGroupSource.maxSize !== undefined ? cacheGroupSource.maxSize : cacheGroupSource.enforce ? 0 : _this.options.maxSize,\n                    minChunks: cacheGroupSource.minChunks !== undefined ? cacheGroupSource.minChunks : cacheGroupSource.enforce ? 1 : _this.options.minChunks,\n                    maxAsyncRequests: cacheGroupSource.maxAsyncRequests !== undefined ? cacheGroupSource.maxAsyncRequests : cacheGroupSource.enforce ? Infinity : _this.options.maxAsyncRequests,\n                    maxInitialRequests: cacheGroupSource.maxInitialRequests !== undefined ? cacheGroupSource.maxInitialRequests : cacheGroupSource.enforce ? Infinity : _this.options.maxInitialRequests,\n                    getName: cacheGroupSource.getName !== undefined ? cacheGroupSource.getName : _this.options.getName,\n                    filename: cacheGroupSource.filename !== undefined ? cacheGroupSource.filename : _this.options.filename,\n                    automaticNameDelimiter: cacheGroupSource.automaticNameDelimiter !== undefined ? cacheGroupSource.automaticNameDelimiter : _this.options.automaticNameDelimiter,\n                    reuseExistingChunk: cacheGroupSource.reuseExistingChunk,\n                    _validateSize: minSize > 0,\n                    _conditionalEnforce: enforceSizeThreshold > 0\n                  }; // For all combination of chunk selection\n\n                  var _iterator15 = _createForOfIteratorHelper(combs),\n                      _step15;\n\n                  try {\n                    for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n                      var chunkCombination = _step15.value;\n                      // Break if minimum number of chunks is not reached\n                      if (chunkCombination.size < cacheGroup.minChunks) continue; // Select chunks by configuration\n\n                      var _getSelectedChunks = getSelectedChunks(chunkCombination, cacheGroup.chunksFilter),\n                          selectedChunks = _getSelectedChunks.chunks,\n                          selectedChunksKey = _getSelectedChunks.key;\n\n                      addModuleToChunksInfoMap(cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, _module2);\n                    }\n                  } catch (err) {\n                    _iterator15.e(err);\n                  } finally {\n                    _iterator15.f();\n                  }\n\n                  cacheGroupIndex++;\n                }\n              } catch (err) {\n                _iterator14.e(err);\n              } finally {\n                _iterator14.f();\n              }\n            } // Filter items were size < minSize\n\n          } catch (err) {\n            _iterator11.e(err);\n          } finally {\n            _iterator11.f();\n          }\n\n          var _iterator12 = _createForOfIteratorHelper(chunksInfoMap),\n              _step12;\n\n          try {\n            for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n              var pair = _step12.value;\n              var info = pair[1];\n\n              if (info.cacheGroup._validateSize && info.size < info.cacheGroup.minSize) {\n                chunksInfoMap[\"delete\"](pair[0]);\n              }\n            }\n            /** @type {Map<Chunk, {minSize: number, maxSize: number, automaticNameDelimiter: string, keys: string[]}>} */\n\n          } catch (err) {\n            _iterator12.e(err);\n          } finally {\n            _iterator12.f();\n          }\n\n          var maxSizeQueueMap = new Map();\n\n          var _loop = function _loop() {\n            // Find best matching entry\n            var bestEntryKey = void 0;\n            var bestEntry = void 0;\n\n            var _iterator16 = _createForOfIteratorHelper(chunksInfoMap),\n                _step16;\n\n            try {\n              for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n                var _pair = _step16.value;\n                var key = _pair[0];\n                var _info = _pair[1];\n\n                if (bestEntry === undefined) {\n                  bestEntry = _info;\n                  bestEntryKey = key;\n                } else if (compareEntries(bestEntry, _info) < 0) {\n                  bestEntry = _info;\n                  bestEntryKey = key;\n                }\n              }\n            } catch (err) {\n              _iterator16.e(err);\n            } finally {\n              _iterator16.f();\n            }\n\n            var item = bestEntry;\n            chunksInfoMap[\"delete\"](bestEntryKey);\n            var chunkName = item.name; // Variable for the new chunk (lazy created)\n\n            /** @type {Chunk} */\n\n            var newChunk = void 0; // When no chunk name, check if we can reuse a chunk instead of creating a new one\n\n            var isReused = false;\n\n            if (item.cacheGroup.reuseExistingChunk) {\n              var _iterator17 = _createForOfIteratorHelper(item.chunks),\n                  _step17;\n\n              try {\n                outer: for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n                  var _chunk = _step17.value;\n                  if (_chunk.getNumberOfModules() !== item.modules.size) continue;\n                  if (_chunk.hasEntryModule()) continue;\n\n                  var _iterator18 = _createForOfIteratorHelper(item.modules),\n                      _step18;\n\n                  try {\n                    for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n                      var _module3 = _step18.value;\n                      if (!_chunk.containsModule(_module3)) continue outer;\n                    }\n                  } catch (err) {\n                    _iterator18.e(err);\n                  } finally {\n                    _iterator18.f();\n                  }\n\n                  if (!newChunk || !newChunk.name) {\n                    newChunk = _chunk;\n                  } else if (_chunk.name && _chunk.name.length < newChunk.name.length) {\n                    newChunk = _chunk;\n                  } else if (_chunk.name && _chunk.name.length === newChunk.name.length && _chunk.name < newChunk.name) {\n                    newChunk = _chunk;\n                  }\n\n                  chunkName = undefined;\n                  isReused = true;\n                }\n              } catch (err) {\n                _iterator17.e(err);\n              } finally {\n                _iterator17.f();\n              }\n            } // Check if maxRequests condition can be fulfilled\n\n\n            var selectedChunks = Array.from(item.chunks).filter(function (chunk) {\n              // skip if we address ourself\n              return (!chunkName || chunk.name !== chunkName) && chunk !== newChunk;\n            });\n            var enforced = item.cacheGroup._conditionalEnforce && item.size >= item.cacheGroup.enforceSizeThreshold; // Skip when no chunk selected\n\n            if (selectedChunks.length === 0) return \"continue\";\n            var usedChunks = new Set(selectedChunks); // Check if maxRequests condition can be fulfilled\n\n            if (!enforced && (Number.isFinite(item.cacheGroup.maxInitialRequests) || Number.isFinite(item.cacheGroup.maxAsyncRequests))) {\n              var _iterator19 = _createForOfIteratorHelper(usedChunks),\n                  _step19;\n\n              try {\n                for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n                  var _chunk2 = _step19.value;\n                  // respect max requests\n                  var maxRequests = _chunk2.isOnlyInitial() ? item.cacheGroup.maxInitialRequests : _chunk2.canBeInitial() ? Math.min(item.cacheGroup.maxInitialRequests, item.cacheGroup.maxAsyncRequests) : item.cacheGroup.maxAsyncRequests;\n\n                  if (isFinite(maxRequests) && getRequests(_chunk2) >= maxRequests) {\n                    usedChunks[\"delete\"](_chunk2);\n                  }\n                }\n              } catch (err) {\n                _iterator19.e(err);\n              } finally {\n                _iterator19.f();\n              }\n            }\n\n            var _iterator20 = _createForOfIteratorHelper(usedChunks),\n                _step20;\n\n            try {\n              outer: for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n                var _chunk5 = _step20.value;\n\n                var _iterator28 = _createForOfIteratorHelper(item.modules),\n                    _step28;\n\n                try {\n                  for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n                    var _module7 = _step28.value;\n                    if (_chunk5.containsModule(_module7)) continue outer;\n                  }\n                } catch (err) {\n                  _iterator28.e(err);\n                } finally {\n                  _iterator28.f();\n                }\n\n                usedChunks[\"delete\"](_chunk5);\n              }\n            } catch (err) {\n              _iterator20.e(err);\n            } finally {\n              _iterator20.f();\n            } // Were some (invalid) chunks removed from usedChunks?\n            // => readd all modules to the queue, as things could have been changed\n\n\n            if (usedChunks.size < selectedChunks.length) {\n              if (usedChunks.size >= item.cacheGroup.minChunks) {\n                var chunksArr = Array.from(usedChunks);\n\n                var _iterator21 = _createForOfIteratorHelper(item.modules),\n                    _step21;\n\n                try {\n                  for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n                    var _module4 = _step21.value;\n                    addModuleToChunksInfoMap(item.cacheGroup, item.cacheGroupIndex, chunksArr, getKey(usedChunks), _module4);\n                  }\n                } catch (err) {\n                  _iterator21.e(err);\n                } finally {\n                  _iterator21.f();\n                }\n              }\n\n              return \"continue\";\n            } // Create the new chunk if not reusing one\n\n\n            if (!isReused) {\n              newChunk = compilation.addChunk(chunkName);\n            } // Walk through all chunks\n\n\n            var _iterator22 = _createForOfIteratorHelper(usedChunks),\n                _step22;\n\n            try {\n              for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n                var _chunk6 = _step22.value;\n\n                // Add graph connections for splitted chunk\n                _chunk6.split(newChunk);\n              } // Add a note to the chunk\n\n            } catch (err) {\n              _iterator22.e(err);\n            } finally {\n              _iterator22.f();\n            }\n\n            newChunk.chunkReason = isReused ? \"reused as split chunk\" : \"split chunk\";\n\n            if (item.cacheGroup.key) {\n              newChunk.chunkReason += \" (cache group: \".concat(item.cacheGroup.key, \")\");\n            }\n\n            if (chunkName) {\n              newChunk.chunkReason += \" (name: \".concat(chunkName, \")\"); // If the chosen name is already an entry point we remove the entry point\n\n              var entrypoint = compilation.entrypoints.get(chunkName);\n\n              if (entrypoint) {\n                compilation.entrypoints[\"delete\"](chunkName);\n                entrypoint.remove();\n                newChunk.entryModule = undefined;\n              }\n            }\n\n            if (item.cacheGroup.filename) {\n              if (!newChunk.isOnlyInitial()) {\n                throw new Error(\"SplitChunksPlugin: You are trying to set a filename for a chunk which is (also) loaded on demand. \" + \"The runtime can only handle loading of chunks which match the chunkFilename schema. \" + \"Using a custom filename would fail at runtime. \" + \"(cache group: \".concat(item.cacheGroup.key, \")\"));\n              }\n\n              newChunk.filenameTemplate = item.cacheGroup.filename;\n            }\n\n            if (!isReused) {\n              // Add all modules to the new chunk\n              var _iterator23 = _createForOfIteratorHelper(item.modules),\n                  _step23;\n\n              try {\n                for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n                  var _module5 = _step23.value;\n\n                  if (typeof _module5.chunkCondition === \"function\") {\n                    if (!_module5.chunkCondition(newChunk)) continue;\n                  } // Add module to new chunk\n\n\n                  GraphHelpers.connectChunkAndModule(newChunk, _module5); // Remove module from used chunks\n\n                  var _iterator24 = _createForOfIteratorHelper(usedChunks),\n                      _step24;\n\n                  try {\n                    for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n                      var _chunk3 = _step24.value;\n\n                      _chunk3.removeModule(_module5);\n\n                      _module5.rewriteChunkInReasons(_chunk3, [newChunk]);\n                    }\n                  } catch (err) {\n                    _iterator24.e(err);\n                  } finally {\n                    _iterator24.f();\n                  }\n                }\n              } catch (err) {\n                _iterator23.e(err);\n              } finally {\n                _iterator23.f();\n              }\n            } else {\n              // Remove all modules from used chunks\n              var _iterator25 = _createForOfIteratorHelper(item.modules),\n                  _step25;\n\n              try {\n                for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n                  var _module6 = _step25.value;\n\n                  var _iterator26 = _createForOfIteratorHelper(usedChunks),\n                      _step26;\n\n                  try {\n                    for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n                      var _chunk4 = _step26.value;\n\n                      _chunk4.removeModule(_module6);\n\n                      _module6.rewriteChunkInReasons(_chunk4, [newChunk]);\n                    }\n                  } catch (err) {\n                    _iterator26.e(err);\n                  } finally {\n                    _iterator26.f();\n                  }\n                }\n              } catch (err) {\n                _iterator25.e(err);\n              } finally {\n                _iterator25.f();\n              }\n            }\n\n            if (item.cacheGroup.maxSize > 0) {\n              var oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);\n              maxSizeQueueMap.set(newChunk, {\n                minSize: Math.max(oldMaxSizeSettings ? oldMaxSizeSettings.minSize : 0, item.cacheGroup.minSizeForMaxSize),\n                maxSize: Math.min(oldMaxSizeSettings ? oldMaxSizeSettings.maxSize : Infinity, item.cacheGroup.maxSize),\n                automaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,\n                keys: oldMaxSizeSettings ? oldMaxSizeSettings.keys.concat(item.cacheGroup.key) : [item.cacheGroup.key]\n              });\n            } // remove all modules from other entries and update size\n\n\n            var _iterator27 = _createForOfIteratorHelper(chunksInfoMap),\n                _step27;\n\n            try {\n              for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n                var _ref6 = _step27.value;\n\n                var _ref5 = _slicedToArray(_ref6, 2);\n\n                var _key = _ref5[0];\n                var _info2 = _ref5[1];\n\n                if (isOverlap(_info2.chunks, usedChunks)) {\n                  // update modules and total size\n                  // may remove it from the map when < minSize\n                  var oldSize = _info2.modules.size;\n\n                  var _iterator29 = _createForOfIteratorHelper(item.modules),\n                      _step29;\n\n                  try {\n                    for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n                      var _module8 = _step29.value;\n\n                      _info2.modules[\"delete\"](_module8);\n                    }\n                  } catch (err) {\n                    _iterator29.e(err);\n                  } finally {\n                    _iterator29.f();\n                  }\n\n                  if (_info2.modules.size !== oldSize) {\n                    if (_info2.modules.size === 0) {\n                      chunksInfoMap[\"delete\"](_key);\n                      continue;\n                    }\n\n                    _info2.size = getModulesSize(_info2.modules);\n\n                    if (_info2.cacheGroup._validateSize && _info2.size < _info2.cacheGroup.minSize) {\n                      chunksInfoMap[\"delete\"](_key);\n                    }\n\n                    if (_info2.modules.size === 0) {\n                      chunksInfoMap[\"delete\"](_key);\n                    }\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator27.e(err);\n            } finally {\n              _iterator27.f();\n            }\n          };\n\n          while (chunksInfoMap.size > 0) {\n            var _ret = _loop();\n\n            if (_ret === \"continue\") continue;\n          }\n\n          var incorrectMinMaxSizeSet = new Set(); // Make sure that maxSize is fulfilled\n\n          var _iterator13 = _createForOfIteratorHelper(compilation.chunks.slice()),\n              _step13;\n\n          try {\n            var _loop2 = function _loop2() {\n              var chunk = _step13.value;\n\n              var _ref7 = maxSizeQueueMap.get(chunk) || _this.options.fallbackCacheGroup,\n                  minSize = _ref7.minSize,\n                  maxSize = _ref7.maxSize,\n                  automaticNameDelimiter = _ref7.automaticNameDelimiter,\n                  keys = _ref7.keys;\n\n              if (!maxSize) return \"continue\";\n\n              if (minSize > maxSize) {\n                var warningKey = \"\".concat(keys && keys.join(), \" \").concat(minSize, \" \").concat(maxSize);\n\n                if (!incorrectMinMaxSizeSet.has(warningKey)) {\n                  incorrectMinMaxSizeSet.add(warningKey);\n                  compilation.warnings.push(new MinMaxSizeWarning(keys, minSize, maxSize));\n                }\n              }\n\n              var results = deterministicGroupingForModules({\n                maxSize: Math.max(minSize, maxSize),\n                minSize: minSize,\n                items: chunk.modulesIterable,\n                getKey: function getKey(module) {\n                  var ident = contextify(compilation.options.context, module.identifier());\n                  var name = module.nameForCondition ? contextify(compilation.options.context, module.nameForCondition()) : ident.replace(/^.*!|\\?[^?!]*$/g, \"\");\n                  var fullKey = name + automaticNameDelimiter + hashFilename(ident);\n                  return fullKey.replace(/[\\\\/?]/g, \"_\");\n                },\n                getSize: function getSize(module) {\n                  return module.size();\n                }\n              });\n              results.sort(function (a, b) {\n                if (a.key < b.key) return -1;\n                if (a.key > b.key) return 1;\n                return 0;\n              });\n\n              for (var i = 0; i < results.length; i++) {\n                var group = results[i];\n                var key = _this.options.hidePathInfo ? hashFilename(group.key) : group.key;\n                var name = chunk.name ? chunk.name + automaticNameDelimiter + key : null;\n\n                if (name && name.length > 100) {\n                  name = name.slice(0, 100) + automaticNameDelimiter + hashFilename(name);\n                }\n\n                var newPart = void 0;\n\n                if (i !== results.length - 1) {\n                  newPart = compilation.addChunk(name);\n                  chunk.split(newPart);\n                  newPart.chunkReason = chunk.chunkReason; // Add all modules to the new chunk\n\n                  var _iterator30 = _createForOfIteratorHelper(group.items),\n                      _step30;\n\n                  try {\n                    for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n                      var _module9 = _step30.value;\n\n                      if (typeof _module9.chunkCondition === \"function\") {\n                        if (!_module9.chunkCondition(newPart)) continue;\n                      } // Add module to new chunk\n\n\n                      GraphHelpers.connectChunkAndModule(newPart, _module9); // Remove module from used chunks\n\n                      chunk.removeModule(_module9);\n\n                      _module9.rewriteChunkInReasons(chunk, [newPart]);\n                    }\n                  } catch (err) {\n                    _iterator30.e(err);\n                  } finally {\n                    _iterator30.f();\n                  }\n                } else {\n                  // change the chunk to be a part\n                  newPart = chunk;\n                  chunk.name = name;\n                }\n              }\n            };\n\n            for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n              var _ret2 = _loop2();\n\n              if (_ret2 === \"continue\") continue;\n            }\n          } catch (err) {\n            _iterator13.e(err);\n          } finally {\n            _iterator13.f();\n          }\n        });\n      });\n    }\n  }], [{\n    key: \"normalizeOptions\",\n    value: function normalizeOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return {\n        chunksFilter: SplitChunksPlugin.normalizeChunksFilter(options.chunks || \"all\"),\n        minSize: options.minSize || 0,\n        enforceSizeThreshold: options.enforceSizeThreshold || 0,\n        maxSize: options.maxSize || 0,\n        minChunks: options.minChunks || 1,\n        maxAsyncRequests: options.maxAsyncRequests || 1,\n        maxInitialRequests: options.maxInitialRequests || 1,\n        hidePathInfo: options.hidePathInfo || false,\n        filename: options.filename || undefined,\n        getCacheGroups: SplitChunksPlugin.normalizeCacheGroups({\n          cacheGroups: options.cacheGroups,\n          name: options.name,\n          automaticNameDelimiter: options.automaticNameDelimiter,\n          automaticNameMaxLength: options.automaticNameMaxLength\n        }),\n        automaticNameDelimiter: options.automaticNameDelimiter,\n        automaticNameMaxLength: options.automaticNameMaxLength || 109,\n        fallbackCacheGroup: SplitChunksPlugin.normalizeFallbackCacheGroup(options.fallbackCacheGroup || {}, options)\n      };\n    }\n  }, {\n    key: \"normalizeName\",\n    value: function normalizeName(_ref8) {\n      var name = _ref8.name,\n          automaticNameDelimiter = _ref8.automaticNameDelimiter,\n          automaticNamePrefix = _ref8.automaticNamePrefix,\n          automaticNameMaxLength = _ref8.automaticNameMaxLength;\n\n      if (name === true) {\n        /** @type {WeakMap<Chunk[], Record<string, string>>} */\n        var cache = new WeakMap();\n\n        var fn = function fn(module, chunks, cacheGroup) {\n          var cacheEntry = cache.get(chunks);\n\n          if (cacheEntry === undefined) {\n            cacheEntry = {};\n            cache.set(chunks, cacheEntry);\n          } else if (cacheGroup in cacheEntry) {\n            return cacheEntry[cacheGroup];\n          }\n\n          var names = chunks.map(function (c) {\n            return c.name;\n          });\n\n          if (!names.every(Boolean)) {\n            cacheEntry[cacheGroup] = undefined;\n            return;\n          }\n\n          names.sort();\n          var prefix = typeof automaticNamePrefix === \"string\" ? automaticNamePrefix : cacheGroup;\n          var namePrefix = prefix ? prefix + automaticNameDelimiter : \"\";\n          var name = namePrefix + names.join(automaticNameDelimiter); // Filenames and paths can't be too long otherwise an\n          // ENAMETOOLONG error is raised. If the generated name if too\n          // long, it is truncated and a hash is appended. The limit has\n          // been set to 109 to prevent `[name].[chunkhash].[ext]` from\n          // generating a 256+ character string.\n\n          if (name.length > automaticNameMaxLength) {\n            var hashedFilename = hashFilename(name);\n            var sliceLength = automaticNameMaxLength - (automaticNameDelimiter.length + hashedFilename.length);\n            name = name.slice(0, sliceLength) + automaticNameDelimiter + hashedFilename;\n          }\n\n          cacheEntry[cacheGroup] = name;\n          return name;\n        };\n\n        return fn;\n      }\n\n      if (typeof name === \"string\") {\n        var _fn = function _fn() {\n          return name;\n        };\n\n        return _fn;\n      }\n\n      if (typeof name === \"function\") return name;\n    }\n  }, {\n    key: \"normalizeChunksFilter\",\n    value: function normalizeChunksFilter(chunks) {\n      if (chunks === \"initial\") {\n        return INITIAL_CHUNK_FILTER;\n      }\n\n      if (chunks === \"async\") {\n        return ASYNC_CHUNK_FILTER;\n      }\n\n      if (chunks === \"all\") {\n        return ALL_CHUNK_FILTER;\n      }\n\n      if (typeof chunks === \"function\") return chunks;\n    }\n  }, {\n    key: \"normalizeFallbackCacheGroup\",\n    value: function normalizeFallbackCacheGroup(_ref9, _ref10) {\n      var _ref9$minSize = _ref9.minSize,\n          minSize = _ref9$minSize === void 0 ? undefined : _ref9$minSize,\n          _ref9$maxSize = _ref9.maxSize,\n          maxSize = _ref9$maxSize === void 0 ? undefined : _ref9$maxSize,\n          _ref9$automaticNameDe = _ref9.automaticNameDelimiter,\n          automaticNameDelimiter = _ref9$automaticNameDe === void 0 ? undefined : _ref9$automaticNameDe;\n      var _ref10$minSize = _ref10.minSize,\n          defaultMinSize = _ref10$minSize === void 0 ? undefined : _ref10$minSize,\n          _ref10$maxSize = _ref10.maxSize,\n          defaultMaxSize = _ref10$maxSize === void 0 ? undefined : _ref10$maxSize,\n          _ref10$automaticNameD = _ref10.automaticNameDelimiter,\n          defaultAutomaticNameDelimiter = _ref10$automaticNameD === void 0 ? undefined : _ref10$automaticNameD;\n      return {\n        minSize: typeof minSize === \"number\" ? minSize : defaultMinSize || 0,\n        maxSize: typeof maxSize === \"number\" ? maxSize : defaultMaxSize || 0,\n        automaticNameDelimiter: automaticNameDelimiter || defaultAutomaticNameDelimiter || \"~\"\n      };\n    }\n  }, {\n    key: \"normalizeCacheGroups\",\n    value: function normalizeCacheGroups(_ref11) {\n      var cacheGroups = _ref11.cacheGroups,\n          name = _ref11.name,\n          automaticNameDelimiter = _ref11.automaticNameDelimiter,\n          automaticNameMaxLength = _ref11.automaticNameMaxLength;\n\n      if (typeof cacheGroups === \"function\") {\n        // TODO webpack 5 remove this\n        if (cacheGroups.length !== 1) {\n          return function (module) {\n            return cacheGroups(module, module.getChunks());\n          };\n        }\n\n        return cacheGroups;\n      }\n\n      if (cacheGroups && _typeof(cacheGroups) === \"object\") {\n        var _fn2 = function _fn2(module) {\n          var results;\n\n          for (var _i2 = 0, _Object$keys = Object.keys(cacheGroups); _i2 < _Object$keys.length; _i2++) {\n            var key = _Object$keys[_i2];\n            var option = cacheGroups[key];\n            if (option === false) continue;\n\n            if (option instanceof RegExp || typeof option === \"string\") {\n              option = {\n                test: option\n              };\n            }\n\n            if (typeof option === \"function\") {\n              var result = option(module);\n\n              if (result) {\n                if (results === undefined) results = [];\n\n                var _iterator31 = _createForOfIteratorHelper(Array.isArray(result) ? result : [result]),\n                    _step31;\n\n                try {\n                  var _loop3 = function _loop3() {\n                    var r = _step31.value;\n                    var result = Object.assign({\n                      key: key\n                    }, r);\n                    if (result.name) result.getName = function () {\n                      return result.name;\n                    };\n\n                    if (result.chunks) {\n                      result.chunksFilter = SplitChunksPlugin.normalizeChunksFilter(result.chunks);\n                    }\n\n                    results.push(result);\n                  };\n\n                  for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n                    _loop3();\n                  }\n                } catch (err) {\n                  _iterator31.e(err);\n                } finally {\n                  _iterator31.f();\n                }\n              }\n            } else if (SplitChunksPlugin.checkTest(option.test, module)) {\n              if (results === undefined) results = [];\n              results.push({\n                key: key,\n                priority: option.priority,\n                getName: SplitChunksPlugin.normalizeName({\n                  name: option.name || name,\n                  automaticNameDelimiter: typeof option.automaticNameDelimiter === \"string\" ? option.automaticNameDelimiter : automaticNameDelimiter,\n                  automaticNamePrefix: option.automaticNamePrefix,\n                  automaticNameMaxLength: option.automaticNameMaxLength || automaticNameMaxLength\n                }) || function () {},\n                chunksFilter: SplitChunksPlugin.normalizeChunksFilter(option.chunks),\n                enforce: option.enforce,\n                minSize: option.minSize,\n                enforceSizeThreshold: option.enforceSizeThreshold,\n                maxSize: option.maxSize,\n                minChunks: option.minChunks,\n                maxAsyncRequests: option.maxAsyncRequests,\n                maxInitialRequests: option.maxInitialRequests,\n                filename: option.filename,\n                reuseExistingChunk: option.reuseExistingChunk\n              });\n            }\n          }\n\n          return results;\n        };\n\n        return _fn2;\n      }\n\n      var fn = function fn() {};\n\n      return fn;\n    }\n  }, {\n    key: \"checkTest\",\n    value: function checkTest(test, module) {\n      if (test === undefined) return true;\n\n      if (typeof test === \"function\") {\n        if (test.length !== 1) {\n          return test(module, module.getChunks());\n        }\n\n        return test(module);\n      }\n\n      if (typeof test === \"boolean\") return test;\n\n      if (typeof test === \"string\") {\n        if (module.nameForCondition && module.nameForCondition().startsWith(test)) {\n          return true;\n        }\n\n        var _iterator32 = _createForOfIteratorHelper(module.chunksIterable),\n            _step32;\n\n        try {\n          for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n            var chunk = _step32.value;\n\n            if (chunk.name && chunk.name.startsWith(test)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator32.e(err);\n        } finally {\n          _iterator32.f();\n        }\n\n        return false;\n      }\n\n      if (test instanceof RegExp) {\n        if (module.nameForCondition && test.test(module.nameForCondition())) {\n          return true;\n        }\n\n        var _iterator33 = _createForOfIteratorHelper(module.chunksIterable),\n            _step33;\n\n        try {\n          for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n            var _chunk7 = _step33.value;\n\n            if (_chunk7.name && test.test(_chunk7.name)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator33.e(err);\n        } finally {\n          _iterator33.f();\n        }\n\n        return false;\n      }\n\n      return false;\n    }\n  }]);\n\n  return SplitChunksPlugin;\n}();","map":null,"metadata":{},"sourceType":"module"}