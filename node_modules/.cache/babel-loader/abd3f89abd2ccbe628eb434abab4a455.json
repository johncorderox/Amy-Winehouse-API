{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar NativeModule = require(\"module\");\n\nvar _require = require(\"webpack-sources\"),\n    CachedSource = _require.CachedSource,\n    LineToLineMappedSource = _require.LineToLineMappedSource,\n    OriginalSource = _require.OriginalSource,\n    RawSource = _require.RawSource,\n    SourceMapSource = _require.SourceMapSource;\n\nvar _require2 = require(\"loader-runner\"),\n    getContext = _require2.getContext,\n    runLoaders = _require2.runLoaders;\n\nvar WebpackError = require(\"./WebpackError\");\n\nvar Module = require(\"./Module\");\n\nvar ModuleParseError = require(\"./ModuleParseError\");\n\nvar ModuleBuildError = require(\"./ModuleBuildError\");\n\nvar ModuleError = require(\"./ModuleError\");\n\nvar ModuleWarning = require(\"./ModuleWarning\");\n\nvar createHash = require(\"./util/createHash\");\n\nvar contextify = require(\"./util/identifier\").contextify;\n/** @typedef {import(\"./util/createHash\").Hash} Hash */\n\n\nvar asString = function asString(buf) {\n  if (Buffer.isBuffer(buf)) {\n    return buf.toString(\"utf-8\");\n  }\n\n  return buf;\n};\n\nvar asBuffer = function asBuffer(str) {\n  if (!Buffer.isBuffer(str)) {\n    return Buffer.from(str, \"utf-8\");\n  }\n\n  return str;\n};\n\nvar NonErrorEmittedError = /*#__PURE__*/function (_WebpackError) {\n  _inherits(NonErrorEmittedError, _WebpackError);\n\n  var _super = _createSuper(NonErrorEmittedError);\n\n  function NonErrorEmittedError(error) {\n    var _this;\n\n    _classCallCheck(this, NonErrorEmittedError);\n\n    _this = _super.call(this);\n    _this.name = \"NonErrorEmittedError\";\n    _this.message = \"(Emitted value instead of an instance of Error) \" + error;\n    Error.captureStackTrace(_assertThisInitialized(_this), _this.constructor);\n    return _this;\n  }\n\n  return NonErrorEmittedError;\n}(WebpackError);\n/**\n * @typedef {Object} CachedSourceEntry\n * @property {TODO} source the generated source\n * @property {string} hash the hash value\n */\n\n\nvar NormalModule = /*#__PURE__*/function (_Module) {\n  _inherits(NormalModule, _Module);\n\n  var _super2 = _createSuper(NormalModule);\n\n  function NormalModule(_ref) {\n    var _this2;\n\n    var type = _ref.type,\n        request = _ref.request,\n        userRequest = _ref.userRequest,\n        rawRequest = _ref.rawRequest,\n        loaders = _ref.loaders,\n        resource = _ref.resource,\n        matchResource = _ref.matchResource,\n        parser = _ref.parser,\n        generator = _ref.generator,\n        resolveOptions = _ref.resolveOptions;\n\n    _classCallCheck(this, NormalModule);\n\n    _this2 = _super2.call(this, type, getContext(resource)); // Info from Factory\n\n    _this2.request = request;\n    _this2.userRequest = userRequest;\n    _this2.rawRequest = rawRequest;\n    _this2.binary = type.startsWith(\"webassembly\");\n    _this2.parser = parser;\n    _this2.generator = generator;\n    _this2.resource = resource;\n    _this2.matchResource = matchResource;\n    _this2.loaders = loaders;\n    if (resolveOptions !== undefined) _this2.resolveOptions = resolveOptions; // Info from Build\n\n    _this2.error = null;\n    _this2._source = null;\n    _this2._sourceSize = null;\n    _this2._buildHash = \"\";\n    _this2.buildTimestamp = undefined;\n    /** @private @type {Map<string, CachedSourceEntry>} */\n\n    _this2._cachedSources = new Map(); // Options for the NormalModule set by plugins\n    // TODO refactor this -> options object filled from Factory\n\n    _this2.useSourceMap = false;\n    _this2.lineToLine = false; // Cache\n\n    _this2._lastSuccessfulBuildMeta = {};\n    return _this2;\n  }\n\n  _createClass(NormalModule, [{\n    key: \"identifier\",\n    value: function identifier() {\n      return this.request;\n    }\n  }, {\n    key: \"readableIdentifier\",\n    value: function readableIdentifier(requestShortener) {\n      return requestShortener.shorten(this.userRequest);\n    }\n  }, {\n    key: \"libIdent\",\n    value: function libIdent(options) {\n      return contextify(options.context, this.userRequest);\n    }\n  }, {\n    key: \"nameForCondition\",\n    value: function nameForCondition() {\n      var resource = this.matchResource || this.resource;\n      var idx = resource.indexOf(\"?\");\n      if (idx >= 0) return resource.substr(0, idx);\n      return resource;\n    }\n  }, {\n    key: \"updateCacheModule\",\n    value: function updateCacheModule(module) {\n      this.type = module.type;\n      this.request = module.request;\n      this.userRequest = module.userRequest;\n      this.rawRequest = module.rawRequest;\n      this.parser = module.parser;\n      this.generator = module.generator;\n      this.resource = module.resource;\n      this.matchResource = module.matchResource;\n      this.loaders = module.loaders;\n      this.resolveOptions = module.resolveOptions;\n    }\n  }, {\n    key: \"createSourceForAsset\",\n    value: function createSourceForAsset(name, content, sourceMap) {\n      if (!sourceMap) {\n        return new RawSource(content);\n      }\n\n      if (typeof sourceMap === \"string\") {\n        return new OriginalSource(content, sourceMap);\n      }\n\n      return new SourceMapSource(content, name, sourceMap);\n    }\n  }, {\n    key: \"createLoaderContext\",\n    value: function createLoaderContext(resolver, options, compilation, fs) {\n      var _this3 = this;\n\n      var requestShortener = compilation.runtimeTemplate.requestShortener;\n\n      var getCurrentLoaderName = function getCurrentLoaderName() {\n        var currentLoader = _this3.getCurrentLoader(loaderContext);\n\n        if (!currentLoader) return \"(not in loader scope)\";\n        return requestShortener.shorten(currentLoader.loader);\n      };\n\n      var loaderContext = {\n        version: 2,\n        emitWarning: function emitWarning(warning) {\n          if (!(warning instanceof Error)) {\n            warning = new NonErrorEmittedError(warning);\n          }\n\n          _this3.warnings.push(new ModuleWarning(_this3, warning, {\n            from: getCurrentLoaderName()\n          }));\n        },\n        emitError: function emitError(error) {\n          if (!(error instanceof Error)) {\n            error = new NonErrorEmittedError(error);\n          }\n\n          _this3.errors.push(new ModuleError(_this3, error, {\n            from: getCurrentLoaderName()\n          }));\n        },\n        getLogger: function getLogger(name) {\n          var currentLoader = _this3.getCurrentLoader(loaderContext);\n\n          return compilation.getLogger(function () {\n            return [currentLoader && currentLoader.loader, name, _this3.identifier()].filter(Boolean).join(\"|\");\n          });\n        },\n        // TODO remove in webpack 5\n        exec: function exec(code, filename) {\n          // @ts-ignore Argument of type 'this' is not assignable to parameter of type 'Module'.\n          var module = new NativeModule(filename, _this3); // @ts-ignore _nodeModulePaths is deprecated and undocumented Node.js API\n\n          module.paths = NativeModule._nodeModulePaths(_this3.context);\n          module.filename = filename;\n\n          module._compile(code, filename);\n\n          return module.exports;\n        },\n        resolve: function resolve(context, request, callback) {\n          resolver.resolve({}, context, request, {}, callback);\n        },\n        getResolve: function getResolve(options) {\n          var child = options ? resolver.withOptions(options) : resolver;\n          return function (context, request, callback) {\n            if (callback) {\n              child.resolve({}, context, request, {}, callback);\n            } else {\n              return new Promise(function (resolve, reject) {\n                child.resolve({}, context, request, {}, function (err, result) {\n                  if (err) reject(err);else resolve(result);\n                });\n              });\n            }\n          };\n        },\n        emitFile: function emitFile(name, content, sourceMap, assetInfo) {\n          if (!_this3.buildInfo.assets) {\n            _this3.buildInfo.assets = Object.create(null);\n            _this3.buildInfo.assetsInfo = new Map();\n          }\n\n          _this3.buildInfo.assets[name] = _this3.createSourceForAsset(name, content, sourceMap);\n\n          _this3.buildInfo.assetsInfo.set(name, assetInfo);\n        },\n        rootContext: options.context,\n        webpack: true,\n        sourceMap: !!this.useSourceMap,\n        mode: options.mode || \"production\",\n        _module: this,\n        _compilation: compilation,\n        _compiler: compilation.compiler,\n        fs: fs\n      };\n      compilation.hooks.normalModuleLoader.call(loaderContext, this);\n\n      if (options.loader) {\n        Object.assign(loaderContext, options.loader);\n      }\n\n      return loaderContext;\n    }\n  }, {\n    key: \"getCurrentLoader\",\n    value: function getCurrentLoader(loaderContext) {\n      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : loaderContext.loaderIndex;\n\n      if (this.loaders && this.loaders.length && index < this.loaders.length && index >= 0 && this.loaders[index]) {\n        return this.loaders[index];\n      }\n\n      return null;\n    }\n  }, {\n    key: \"createSource\",\n    value: function createSource(source, resourceBuffer, sourceMap) {\n      // if there is no identifier return raw source\n      if (!this.identifier) {\n        return new RawSource(source);\n      } // from here on we assume we have an identifier\n\n\n      var identifier = this.identifier();\n\n      if (this.lineToLine && resourceBuffer) {\n        return new LineToLineMappedSource(source, identifier, asString(resourceBuffer));\n      }\n\n      if (this.useSourceMap && sourceMap) {\n        return new SourceMapSource(source, identifier, sourceMap);\n      }\n\n      if (Buffer.isBuffer(source)) {\n        // @ts-ignore\n        // TODO We need to fix @types/webpack-sources to allow RawSource to take a Buffer | string\n        return new RawSource(source);\n      }\n\n      return new OriginalSource(source, identifier);\n    }\n  }, {\n    key: \"doBuild\",\n    value: function doBuild(options, compilation, resolver, fs, callback) {\n      var _this4 = this;\n\n      var loaderContext = this.createLoaderContext(resolver, options, compilation, fs);\n      runLoaders({\n        resource: this.resource,\n        loaders: this.loaders,\n        context: loaderContext,\n        readResource: fs.readFile.bind(fs)\n      }, function (err, result) {\n        if (result) {\n          _this4.buildInfo.cacheable = result.cacheable;\n          _this4.buildInfo.fileDependencies = new Set(result.fileDependencies);\n          _this4.buildInfo.contextDependencies = new Set(result.contextDependencies);\n        }\n\n        if (err) {\n          if (!(err instanceof Error)) {\n            err = new NonErrorEmittedError(err);\n          }\n\n          var currentLoader = _this4.getCurrentLoader(loaderContext);\n\n          var error = new ModuleBuildError(_this4, err, {\n            from: currentLoader && compilation.runtimeTemplate.requestShortener.shorten(currentLoader.loader)\n          });\n          return callback(error);\n        }\n\n        var resourceBuffer = result.resourceBuffer;\n        var source = result.result[0];\n        var sourceMap = result.result.length >= 1 ? result.result[1] : null;\n        var extraInfo = result.result.length >= 2 ? result.result[2] : null;\n\n        if (!Buffer.isBuffer(source) && typeof source !== \"string\") {\n          var _currentLoader = _this4.getCurrentLoader(loaderContext, 0);\n\n          var _err = new Error(\"Final loader (\".concat(_currentLoader ? compilation.runtimeTemplate.requestShortener.shorten(_currentLoader.loader) : \"unknown\", \") didn't return a Buffer or String\"));\n\n          var _error = new ModuleBuildError(_this4, _err);\n\n          return callback(_error);\n        }\n\n        _this4._source = _this4.createSource(_this4.binary ? asBuffer(source) : asString(source), resourceBuffer, sourceMap);\n        _this4._sourceSize = null;\n        _this4._ast = _typeof(extraInfo) === \"object\" && extraInfo !== null && extraInfo.webpackAST !== undefined ? extraInfo.webpackAST : null;\n        return callback();\n      });\n    }\n  }, {\n    key: \"markModuleAsErrored\",\n    value: function markModuleAsErrored(error) {\n      // Restore build meta from successful build to keep importing state\n      this.buildMeta = Object.assign({}, this._lastSuccessfulBuildMeta);\n      this.error = error;\n      this.errors.push(this.error);\n      this._source = new RawSource(\"throw new Error(\" + JSON.stringify(this.error.message) + \");\");\n      this._sourceSize = null;\n      this._ast = null;\n    }\n  }, {\n    key: \"applyNoParseRule\",\n    value: function applyNoParseRule(rule, content) {\n      // must start with \"rule\" if rule is a string\n      if (typeof rule === \"string\") {\n        return content.indexOf(rule) === 0;\n      }\n\n      if (typeof rule === \"function\") {\n        return rule(content);\n      } // we assume rule is a regexp\n\n\n      return rule.test(content);\n    } // check if module should not be parsed\n    // returns \"true\" if the module should !not! be parsed\n    // returns \"false\" if the module !must! be parsed\n\n  }, {\n    key: \"shouldPreventParsing\",\n    value: function shouldPreventParsing(noParseRule, request) {\n      // if no noParseRule exists, return false\n      // the module !must! be parsed.\n      if (!noParseRule) {\n        return false;\n      } // we only have one rule to check\n\n\n      if (!Array.isArray(noParseRule)) {\n        // returns \"true\" if the module is !not! to be parsed\n        return this.applyNoParseRule(noParseRule, request);\n      }\n\n      for (var i = 0; i < noParseRule.length; i++) {\n        var rule = noParseRule[i]; // early exit on first truthy match\n        // this module is !not! to be parsed\n\n        if (this.applyNoParseRule(rule, request)) {\n          return true;\n        }\n      } // no match found, so this module !should! be parsed\n\n\n      return false;\n    }\n  }, {\n    key: \"_initBuildHash\",\n    value: function _initBuildHash(compilation) {\n      var hash = createHash(compilation.outputOptions.hashFunction);\n\n      if (this._source) {\n        hash.update(\"source\");\n\n        this._source.updateHash(hash);\n      }\n\n      hash.update(\"meta\");\n      hash.update(JSON.stringify(this.buildMeta));\n      this._buildHash =\n      /** @type {string} */\n      hash.digest(\"hex\");\n    }\n  }, {\n    key: \"build\",\n    value: function build(options, compilation, resolver, fs, callback) {\n      var _this5 = this;\n\n      this.buildTimestamp = Date.now();\n      this.built = true;\n      this._source = null;\n      this._sourceSize = null;\n      this._ast = null;\n      this._buildHash = \"\";\n      this.error = null;\n      this.errors.length = 0;\n      this.warnings.length = 0;\n      this.buildMeta = {};\n      this.buildInfo = {\n        cacheable: false,\n        fileDependencies: new Set(),\n        contextDependencies: new Set(),\n        assets: undefined,\n        assetsInfo: undefined\n      };\n      return this.doBuild(options, compilation, resolver, fs, function (err) {\n        _this5._cachedSources.clear(); // if we have an error mark module as failed and exit\n\n\n        if (err) {\n          _this5.markModuleAsErrored(err);\n\n          _this5._initBuildHash(compilation);\n\n          return callback();\n        } // check if this module should !not! be parsed.\n        // if so, exit here;\n\n\n        var noParseRule = options.module && options.module.noParse;\n\n        if (_this5.shouldPreventParsing(noParseRule, _this5.request)) {\n          _this5._initBuildHash(compilation);\n\n          return callback();\n        }\n\n        var handleParseError = function handleParseError(e) {\n          var source = _this5._source.source();\n\n          var loaders = _this5.loaders.map(function (item) {\n            return contextify(options.context, item.loader);\n          });\n\n          var error = new ModuleParseError(_this5, source, e, loaders);\n\n          _this5.markModuleAsErrored(error);\n\n          _this5._initBuildHash(compilation);\n\n          return callback();\n        };\n\n        var handleParseResult = function handleParseResult(result) {\n          _this5._lastSuccessfulBuildMeta = _this5.buildMeta;\n\n          _this5._initBuildHash(compilation);\n\n          return callback();\n        };\n\n        try {\n          var result = _this5.parser.parse(_this5._ast || _this5._source.source(), {\n            current: _this5,\n            module: _this5,\n            compilation: compilation,\n            options: options\n          }, function (err, result) {\n            if (err) {\n              handleParseError(err);\n            } else {\n              handleParseResult(result);\n            }\n          });\n\n          if (result !== undefined) {\n            // parse is sync\n            handleParseResult(result);\n          }\n        } catch (e) {\n          handleParseError(e);\n        }\n      });\n    }\n  }, {\n    key: \"getHashDigest\",\n    value: function getHashDigest(dependencyTemplates) {\n      // TODO webpack 5 refactor\n      var dtHash = dependencyTemplates.get(\"hash\");\n      return \"\".concat(this.hash, \"-\").concat(dtHash);\n    }\n  }, {\n    key: \"source\",\n    value: function source(dependencyTemplates, runtimeTemplate) {\n      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"javascript\";\n      var hashDigest = this.getHashDigest(dependencyTemplates);\n\n      var cacheEntry = this._cachedSources.get(type);\n\n      if (cacheEntry !== undefined && cacheEntry.hash === hashDigest) {\n        // We can reuse the cached source\n        return cacheEntry.source;\n      }\n\n      var source = this.generator.generate(this, dependencyTemplates, runtimeTemplate, type);\n      var cachedSource = new CachedSource(source);\n\n      this._cachedSources.set(type, {\n        source: cachedSource,\n        hash: hashDigest\n      });\n\n      return cachedSource;\n    }\n  }, {\n    key: \"originalSource\",\n    value: function originalSource() {\n      return this._source;\n    }\n  }, {\n    key: \"needRebuild\",\n    value: function needRebuild(fileTimestamps, contextTimestamps) {\n      // always try to rebuild in case of an error\n      if (this.error) return true; // always rebuild when module is not cacheable\n\n      if (!this.buildInfo.cacheable) return true; // Check timestamps of all dependencies\n      // Missing timestamp -> need rebuild\n      // Timestamp bigger than buildTimestamp -> need rebuild\n\n      var _iterator = _createForOfIteratorHelper(this.buildInfo.fileDependencies),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var file = _step.value;\n          var timestamp = fileTimestamps.get(file);\n          if (!timestamp) return true;\n          if (timestamp >= this.buildTimestamp) return true;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(this.buildInfo.contextDependencies),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _file = _step2.value;\n\n          var _timestamp = contextTimestamps.get(_file);\n\n          if (!_timestamp) return true;\n          if (_timestamp >= this.buildTimestamp) return true;\n        } // elsewise -> no rebuild needed\n\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return false;\n    }\n  }, {\n    key: \"size\",\n    value: function size() {\n      if (this._sourceSize === null) {\n        this._sourceSize = this._source ? this._source.size() : -1;\n      }\n\n      return this._sourceSize;\n    }\n    /**\n     * @param {Hash} hash the hash used to track dependencies\n     * @returns {void}\n     */\n\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash) {\n      hash.update(this._buildHash);\n\n      _get(_getPrototypeOf(NormalModule.prototype), \"updateHash\", this).call(this, hash);\n    }\n  }]);\n\n  return NormalModule;\n}(Module);\n\nmodule.exports = NormalModule;","map":null,"metadata":{},"sourceType":"module"}