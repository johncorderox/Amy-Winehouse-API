{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar _require = require(\"webpack-sources\"),\n    ConcatSource = _require.ConcatSource,\n    OriginalSource = _require.OriginalSource,\n    PrefixSource = _require.PrefixSource,\n    RawSource = _require.RawSource;\n\nvar _require2 = require(\"tapable\"),\n    Tapable = _require2.Tapable,\n    SyncWaterfallHook = _require2.SyncWaterfallHook,\n    SyncHook = _require2.SyncHook,\n    SyncBailHook = _require2.SyncBailHook;\n\nvar Template = require(\"./Template\");\n/** @typedef {import(\"webpack-sources\").ConcatSource} ConcatSource */\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"./ModuleTemplate\")} ModuleTemplate */\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./Module\")} Module} */\n\n/** @typedef {import(\"./util/createHash\").Hash} Hash} */\n\n/** @typedef {import(\"./Dependency\").DependencyTemplate} DependencyTemplate} */\n\n/**\n * @typedef {Object} RenderManifestOptions\n * @property {Chunk} chunk the chunk used to render\n * @property {string} hash\n * @property {string} fullHash\n * @property {TODO} outputOptions\n * @property {{javascript: ModuleTemplate, webassembly: ModuleTemplate}} moduleTemplates\n * @property {Map<TODO, TODO>} dependencyTemplates\n */\n// require function shortcuts:\n// __webpack_require__.s = the module id of the entry point\n// __webpack_require__.c = the module cache\n// __webpack_require__.m = the module functions\n// __webpack_require__.p = the bundle public path\n// __webpack_require__.i = the identity function used for harmony imports\n// __webpack_require__.e = the chunk ensure function\n// __webpack_require__.d = the exported property define getter function\n// __webpack_require__.o = Object.prototype.hasOwnProperty.call\n// __webpack_require__.r = define compatibility on export\n// __webpack_require__.t = create a fake namespace object\n// __webpack_require__.n = compatibility get default export\n// __webpack_require__.h = the webpack hash\n// __webpack_require__.w = an object containing all installed WebAssembly.Instance export objects keyed by module id\n// __webpack_require__.oe = the uncaught error handler for the webpack runtime\n// __webpack_require__.nc = the script nonce\n\n\nmodule.exports = /*#__PURE__*/function (_Tapable) {\n  _inherits(MainTemplate, _Tapable);\n\n  var _super = _createSuper(MainTemplate);\n\n  /**\n   *\n   * @param {TODO=} outputOptions output options for the MainTemplate\n   */\n  function MainTemplate(outputOptions) {\n    var _this;\n\n    _classCallCheck(this, MainTemplate);\n\n    _this = _super.call(this);\n    /** @type {TODO?} */\n\n    _this.outputOptions = outputOptions || {};\n    _this.hooks = {\n      /** @type {SyncWaterfallHook<TODO[], RenderManifestOptions>} */\n      renderManifest: new SyncWaterfallHook([\"result\", \"options\"]),\n      modules: new SyncWaterfallHook([\"modules\", \"chunk\", \"hash\", \"moduleTemplate\", \"dependencyTemplates\"]),\n      moduleObj: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\", \"moduleIdExpression\"]),\n      requireEnsure: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\", \"chunkIdExpression\"]),\n      bootstrap: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\", \"moduleTemplate\", \"dependencyTemplates\"]),\n      localVars: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\"]),\n      require: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\"]),\n      requireExtensions: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\"]),\n\n      /** @type {SyncWaterfallHook<string, Chunk, string>} */\n      beforeStartup: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\"]),\n\n      /** @type {SyncWaterfallHook<string, Chunk, string>} */\n      startup: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\"]),\n\n      /** @type {SyncWaterfallHook<string, Chunk, string>} */\n      afterStartup: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\"]),\n      render: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\", \"moduleTemplate\", \"dependencyTemplates\"]),\n      renderWithEntry: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\"]),\n      moduleRequire: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\", \"moduleIdExpression\"]),\n      addModule: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\", \"moduleIdExpression\", \"moduleExpression\"]),\n      currentHash: new SyncWaterfallHook([\"source\", \"requestedLength\"]),\n      assetPath: new SyncWaterfallHook([\"path\", \"options\", \"assetInfo\"]),\n      hash: new SyncHook([\"hash\"]),\n      hashForChunk: new SyncHook([\"hash\", \"chunk\"]),\n      globalHashPaths: new SyncWaterfallHook([\"paths\"]),\n      globalHash: new SyncBailHook([\"chunk\", \"paths\"]),\n      // TODO this should be moved somewhere else\n      // It's weird here\n      hotBootstrap: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\"])\n    };\n\n    _this.hooks.startup.tap(\"MainTemplate\", function (source, chunk, hash) {\n      /** @type {string[]} */\n      var buf = [];\n\n      if (chunk.entryModule) {\n        buf.push(\"// Load entry module and return exports\");\n        buf.push(\"return \".concat(_this.renderRequireFunctionForModule(hash, chunk, JSON.stringify(chunk.entryModule.id)), \"(\").concat(_this.requireFn, \".s = \").concat(JSON.stringify(chunk.entryModule.id), \");\"));\n      }\n\n      return Template.asString(buf);\n    });\n\n    _this.hooks.render.tap(\"MainTemplate\", function (bootstrapSource, chunk, hash, moduleTemplate, dependencyTemplates) {\n      var source = new ConcatSource();\n      source.add(\"/******/ (function(modules) { // webpackBootstrap\\n\");\n      source.add(new PrefixSource(\"/******/\", bootstrapSource));\n      source.add(\"/******/ })\\n\");\n      source.add(\"/************************************************************************/\\n\");\n      source.add(\"/******/ (\");\n      source.add(_this.hooks.modules.call(new RawSource(\"\"), chunk, hash, moduleTemplate, dependencyTemplates));\n      source.add(\")\");\n      return source;\n    });\n\n    _this.hooks.localVars.tap(\"MainTemplate\", function (source, chunk, hash) {\n      return Template.asString([source, \"// The module cache\", \"var installedModules = {};\"]);\n    });\n\n    _this.hooks.require.tap(\"MainTemplate\", function (source, chunk, hash) {\n      return Template.asString([source, \"// Check if module is in cache\", \"if(installedModules[moduleId]) {\", Template.indent(\"return installedModules[moduleId].exports;\"), \"}\", \"// Create a new module (and put it into the cache)\", \"var module = installedModules[moduleId] = {\", Template.indent(_this.hooks.moduleObj.call(\"\", chunk, hash, \"moduleId\")), \"};\", \"\", Template.asString(outputOptions.strictModuleExceptionHandling ? [\"// Execute the module function\", \"var threw = true;\", \"try {\", Template.indent([\"modules[moduleId].call(module.exports, module, module.exports, \".concat(_this.renderRequireFunctionForModule(hash, chunk, \"moduleId\"), \");\"), \"threw = false;\"]), \"} finally {\", Template.indent([\"if(threw) delete installedModules[moduleId];\"]), \"}\"] : [\"// Execute the module function\", \"modules[moduleId].call(module.exports, module, module.exports, \".concat(_this.renderRequireFunctionForModule(hash, chunk, \"moduleId\"), \");\")]), \"\", \"// Flag the module as loaded\", \"module.l = true;\", \"\", \"// Return the exports of the module\", \"return module.exports;\"]);\n    });\n\n    _this.hooks.moduleObj.tap(\"MainTemplate\", function (source, chunk, hash, varModuleId) {\n      return Template.asString([\"i: moduleId,\", \"l: false,\", \"exports: {}\"]);\n    });\n\n    _this.hooks.requireExtensions.tap(\"MainTemplate\", function (source, chunk, hash) {\n      var buf = [];\n      var chunkMaps = chunk.getChunkMaps(); // Check if there are non initial chunks which need to be imported using require-ensure\n\n      if (Object.keys(chunkMaps.hash).length) {\n        buf.push(\"// This file contains only the entry chunk.\");\n        buf.push(\"// The chunk loading function for additional chunks\");\n        buf.push(\"\".concat(_this.requireFn, \".e = function requireEnsure(chunkId) {\"));\n        buf.push(Template.indent(\"var promises = [];\"));\n        buf.push(Template.indent(_this.hooks.requireEnsure.call(\"\", chunk, hash, \"chunkId\")));\n        buf.push(Template.indent(\"return Promise.all(promises);\"));\n        buf.push(\"};\");\n      } else if (chunk.hasModuleInGraph(function (m) {\n        return m.blocks.some(function (b) {\n          return b.chunkGroup && b.chunkGroup.chunks.length > 0;\n        });\n      })) {\n        // There async blocks in the graph, so we need to add an empty requireEnsure\n        // function anyway. This can happen with multiple entrypoints.\n        buf.push(\"// The chunk loading function for additional chunks\");\n        buf.push(\"// Since all referenced chunks are already included\");\n        buf.push(\"// in this file, this function is empty here.\");\n        buf.push(\"\".concat(_this.requireFn, \".e = function requireEnsure() {\"));\n        buf.push(Template.indent(\"return Promise.resolve();\"));\n        buf.push(\"};\");\n      }\n\n      buf.push(\"\");\n      buf.push(\"// expose the modules object (__webpack_modules__)\");\n      buf.push(\"\".concat(_this.requireFn, \".m = modules;\"));\n      buf.push(\"\");\n      buf.push(\"// expose the module cache\");\n      buf.push(\"\".concat(_this.requireFn, \".c = installedModules;\"));\n      buf.push(\"\");\n      buf.push(\"// define getter function for harmony exports\");\n      buf.push(\"\".concat(_this.requireFn, \".d = function(exports, name, getter) {\"));\n      buf.push(Template.indent([\"if(!\".concat(_this.requireFn, \".o(exports, name)) {\"), Template.indent([\"Object.defineProperty(exports, name, { enumerable: true, get: getter });\"]), \"}\"]));\n      buf.push(\"};\");\n      buf.push(\"\");\n      buf.push(\"// define __esModule on exports\");\n      buf.push(\"\".concat(_this.requireFn, \".r = function(exports) {\"));\n      buf.push(Template.indent([\"if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\", Template.indent([\"Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\"]), \"}\", \"Object.defineProperty(exports, '__esModule', { value: true });\"]));\n      buf.push(\"};\");\n      buf.push(\"\");\n      buf.push(\"// create a fake namespace object\");\n      buf.push(\"// mode & 1: value is a module id, require it\");\n      buf.push(\"// mode & 2: merge all properties of value into the ns\");\n      buf.push(\"// mode & 4: return value when already ns object\");\n      buf.push(\"// mode & 8|1: behave like require\");\n      buf.push(\"\".concat(_this.requireFn, \".t = function(value, mode) {\"));\n      buf.push(Template.indent([\"if(mode & 1) value = \".concat(_this.requireFn, \"(value);\"), \"if(mode & 8) return value;\", \"if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\", \"var ns = Object.create(null);\", \"\".concat(_this.requireFn, \".r(ns);\"), \"Object.defineProperty(ns, 'default', { enumerable: true, value: value });\", \"if(mode & 2 && typeof value != 'string') for(var key in value) \" + \"\".concat(_this.requireFn, \".d(ns, key, function(key) { \") + \"return value[key]; \" + \"}.bind(null, key));\", \"return ns;\"]));\n      buf.push(\"};\");\n      buf.push(\"\");\n      buf.push(\"// getDefaultExport function for compatibility with non-harmony modules\");\n      buf.push(_this.requireFn + \".n = function(module) {\");\n      buf.push(Template.indent([\"var getter = module && module.__esModule ?\", Template.indent([\"function getDefault() { return module['default']; } :\", \"function getModuleExports() { return module; };\"]), \"\".concat(_this.requireFn, \".d(getter, 'a', getter);\"), \"return getter;\"]));\n      buf.push(\"};\");\n      buf.push(\"\");\n      buf.push(\"// Object.prototype.hasOwnProperty.call\");\n      buf.push(\"\".concat(_this.requireFn, \".o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\"));\n\n      var publicPath = _this.getPublicPath({\n        hash: hash\n      });\n\n      buf.push(\"\");\n      buf.push(\"// __webpack_public_path__\");\n      buf.push(\"\".concat(_this.requireFn, \".p = \").concat(JSON.stringify(publicPath), \";\"));\n      return Template.asString(buf);\n    });\n\n    _this.requireFn = \"__webpack_require__\";\n    return _this;\n  }\n  /**\n   *\n   * @param {RenderManifestOptions} options render manifest options\n   * @returns {TODO[]} returns render manifest\n   */\n\n\n  _createClass(MainTemplate, [{\n    key: \"getRenderManifest\",\n    value: function getRenderManifest(options) {\n      var result = [];\n      this.hooks.renderManifest.call(result, options);\n      return result;\n    }\n    /**\n     * TODO webpack 5: remove moduleTemplate and dependencyTemplates\n     * @param {string} hash hash to be used for render call\n     * @param {Chunk} chunk Chunk instance\n     * @param {ModuleTemplate} moduleTemplate ModuleTemplate instance for render\n     * @param {Map<Function, DependencyTemplate>} dependencyTemplates dependency templates\n     * @returns {string[]} the generated source of the bootstrap code\n     */\n\n  }, {\n    key: \"renderBootstrap\",\n    value: function renderBootstrap(hash, chunk, moduleTemplate, dependencyTemplates) {\n      var buf = [];\n      buf.push(this.hooks.bootstrap.call(\"\", chunk, hash, moduleTemplate, dependencyTemplates));\n      buf.push(this.hooks.localVars.call(\"\", chunk, hash));\n      buf.push(\"\");\n      buf.push(\"// The require function\");\n      buf.push(\"function \".concat(this.requireFn, \"(moduleId) {\"));\n      buf.push(Template.indent(this.hooks.require.call(\"\", chunk, hash)));\n      buf.push(\"}\");\n      buf.push(\"\");\n      buf.push(Template.asString(this.hooks.requireExtensions.call(\"\", chunk, hash)));\n      buf.push(\"\");\n      buf.push(Template.asString(this.hooks.beforeStartup.call(\"\", chunk, hash)));\n      var afterStartupCode = Template.asString(this.hooks.afterStartup.call(\"\", chunk, hash));\n\n      if (afterStartupCode) {\n        // TODO webpack 5: this is a bit hacky to avoid a breaking change\n        // change it to a better way\n        buf.push(\"var startupResult = (function() {\");\n      }\n\n      buf.push(Template.asString(this.hooks.startup.call(\"\", chunk, hash)));\n\n      if (afterStartupCode) {\n        buf.push(\"})();\");\n        buf.push(afterStartupCode);\n        buf.push(\"return startupResult;\");\n      }\n\n      return buf;\n    }\n    /**\n     * @param {string} hash hash to be used for render call\n     * @param {Chunk} chunk Chunk instance\n     * @param {ModuleTemplate} moduleTemplate ModuleTemplate instance for render\n     * @param {Map<Function, DependencyTemplate>} dependencyTemplates dependency templates\n     * @returns {ConcatSource} the newly generated source from rendering\n     */\n\n  }, {\n    key: \"render\",\n    value: function render(hash, chunk, moduleTemplate, dependencyTemplates) {\n      var buf = this.renderBootstrap(hash, chunk, moduleTemplate, dependencyTemplates);\n      var source = this.hooks.render.call(new OriginalSource(Template.prefix(buf, \" \\t\") + \"\\n\", \"webpack/bootstrap\"), chunk, hash, moduleTemplate, dependencyTemplates);\n\n      if (chunk.hasEntryModule()) {\n        source = this.hooks.renderWithEntry.call(source, chunk, hash);\n      }\n\n      if (!source) {\n        throw new Error(\"Compiler error: MainTemplate plugin 'render' should return something\");\n      }\n\n      chunk.rendered = true;\n      return new ConcatSource(source, \";\");\n    }\n    /**\n     *\n     * @param {string} hash hash for render fn\n     * @param {Chunk} chunk Chunk instance for require\n     * @param {(number|string)=} varModuleId module id\n     * @returns {TODO} the moduleRequire hook call return signature\n     */\n\n  }, {\n    key: \"renderRequireFunctionForModule\",\n    value: function renderRequireFunctionForModule(hash, chunk, varModuleId) {\n      return this.hooks.moduleRequire.call(this.requireFn, chunk, hash, varModuleId);\n    }\n    /**\n     *\n     * @param {string} hash hash for render add fn\n     * @param {Chunk} chunk Chunk instance for require add fn\n     * @param {(string|number)=} varModuleId module id\n     * @param {Module} varModule Module instance\n     * @returns {TODO} renderAddModule call\n     */\n\n  }, {\n    key: \"renderAddModule\",\n    value: function renderAddModule(hash, chunk, varModuleId, varModule) {\n      return this.hooks.addModule.call(\"modules[\".concat(varModuleId, \"] = \").concat(varModule, \";\"), chunk, hash, varModuleId, varModule);\n    }\n    /**\n     *\n     * @param {string} hash string hash\n     * @param {number=} length length\n     * @returns {string} call hook return\n     */\n\n  }, {\n    key: \"renderCurrentHashCode\",\n    value: function renderCurrentHashCode(hash, length) {\n      length = length || Infinity;\n      return this.hooks.currentHash.call(JSON.stringify(hash.substr(0, length)), length);\n    }\n    /**\n     *\n     * @param {object} options get public path options\n     * @returns {string} hook call\n     */\n\n  }, {\n    key: \"getPublicPath\",\n    value: function getPublicPath(options) {\n      return this.hooks.assetPath.call(this.outputOptions.publicPath || \"\", options);\n    }\n  }, {\n    key: \"getAssetPath\",\n    value: function getAssetPath(path, options) {\n      return this.hooks.assetPath.call(path, options);\n    }\n  }, {\n    key: \"getAssetPathWithInfo\",\n    value: function getAssetPathWithInfo(path, options) {\n      var assetInfo = {}; // TODO webpack 5: refactor assetPath hook to receive { path, info } object\n\n      var newPath = this.hooks.assetPath.call(path, options, assetInfo);\n      return {\n        path: newPath,\n        info: assetInfo\n      };\n    }\n    /**\n     * Updates hash with information from this template\n     * @param {Hash} hash the hash to update\n     * @returns {void}\n     */\n\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash) {\n      hash.update(\"maintemplate\");\n      hash.update(\"3\");\n      this.hooks.hash.call(hash);\n    }\n    /**\n     * TODO webpack 5: remove moduleTemplate and dependencyTemplates\n     * Updates hash with chunk-specific information from this template\n     * @param {Hash} hash the hash to update\n     * @param {Chunk} chunk the chunk\n     * @param {ModuleTemplate} moduleTemplate ModuleTemplate instance for render\n     * @param {Map<Function, DependencyTemplate>} dependencyTemplates dependency templates\n     * @returns {void}\n     */\n\n  }, {\n    key: \"updateHashForChunk\",\n    value: function updateHashForChunk(hash, chunk, moduleTemplate, dependencyTemplates) {\n      this.updateHash(hash);\n      this.hooks.hashForChunk.call(hash, chunk);\n\n      var _iterator = _createForOfIteratorHelper(this.renderBootstrap(\"0000\", chunk, moduleTemplate, dependencyTemplates)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var line = _step.value;\n          hash.update(line);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"useChunkHash\",\n    value: function useChunkHash(chunk) {\n      var paths = this.hooks.globalHashPaths.call([]);\n      return !this.hooks.globalHash.call(chunk, paths);\n    }\n  }]);\n\n  return MainTemplate;\n}(Tapable);","map":null,"metadata":{},"sourceType":"module"}