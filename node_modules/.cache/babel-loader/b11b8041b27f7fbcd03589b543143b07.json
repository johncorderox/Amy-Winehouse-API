{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar path = require(\"path\");\n\nvar _require = require(\"webpack-sources\"),\n    ConcatSource = _require.ConcatSource,\n    RawSource = _require.RawSource;\n\nvar ModuleFilenameHelpers = require(\"./ModuleFilenameHelpers\");\n\nvar SourceMapDevToolModuleOptionsPlugin = require(\"./SourceMapDevToolModuleOptionsPlugin\");\n\nvar createHash = require(\"./util/createHash\");\n\nvar _require2 = require(\"./util/identifier\"),\n    absolutify = _require2.absolutify;\n\nvar validateOptions = require(\"schema-utils\");\n\nvar schema = require(\"../schemas/plugins/SourceMapDevToolPlugin.json\");\n/** @typedef {import(\"../declarations/plugins/SourceMapDevToolPlugin\").SourceMapDevToolPluginOptions} SourceMapDevToolPluginOptions */\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"source-map\").RawSourceMap} SourceMap */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./Compilation\")} Compilation */\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"./Compilation\")} SourceMapDefinition */\n\n/**\n * @typedef {object} SourceMapTask\n * @property {Source} asset\n * @property {Array<string | Module>} [modules]\n * @property {string} source\n * @property {string} file\n * @property {SourceMap} sourceMap\n * @property {Chunk} chunk\n */\n\n/**\n * @param {string} name file path\n * @returns {string} file name\n */\n\n\nvar basename = function basename(name) {\n  if (!name.includes(\"/\")) return name;\n  return name.substr(name.lastIndexOf(\"/\") + 1);\n};\n/**\n * @type {WeakMap<Source, {file: string, assets: {[k: string]: ConcatSource | RawSource}}>}\n */\n\n\nvar assetsCache = new WeakMap();\n/**\n * Creating {@link SourceMapTask} for given file\n * @param {string} file current compiled file\n * @param {Source} asset the asset\n * @param {Chunk} chunk related chunk\n * @param {SourceMapDevToolPluginOptions} options source map options\n * @param {Compilation} compilation compilation instance\n * @returns {SourceMapTask | undefined} created task instance or `undefined`\n */\n\nvar getTaskForFile = function getTaskForFile(file, asset, chunk, options, compilation) {\n  var source, sourceMap;\n  /**\n   * Check if asset can build source map\n   */\n\n  if (asset.sourceAndMap) {\n    var sourceAndMap = asset.sourceAndMap(options);\n    sourceMap = sourceAndMap.map;\n    source = sourceAndMap.source;\n  } else {\n    sourceMap = asset.map(options);\n    source = asset.source();\n  }\n\n  if (!sourceMap || typeof source !== \"string\") return;\n  var context = compilation.options.context;\n  var modules = sourceMap.sources.map(function (source) {\n    if (source.startsWith(\"webpack://\")) {\n      source = absolutify(context, source.slice(10));\n    }\n\n    var module = compilation.findModule(source);\n    return module || source;\n  });\n  return {\n    chunk: chunk,\n    file: file,\n    asset: asset,\n    source: source,\n    sourceMap: sourceMap,\n    modules: modules\n  };\n};\n\nvar SourceMapDevToolPlugin = /*#__PURE__*/function () {\n  /**\n   * @param {SourceMapDevToolPluginOptions} [options] options object\n   * @throws {Error} throws error, if got more than 1 arguments\n   */\n  function SourceMapDevToolPlugin(options) {\n    _classCallCheck(this, SourceMapDevToolPlugin);\n\n    if (arguments.length > 1) {\n      throw new Error(\"SourceMapDevToolPlugin only takes one argument (pass an options object)\");\n    }\n\n    if (!options) options = {};\n    validateOptions(schema, options, \"SourceMap DevTool Plugin\");\n    /** @type {string | false} */\n\n    this.sourceMapFilename = options.filename;\n    /** @type {string | false} */\n\n    this.sourceMappingURLComment = options.append === false ? false : options.append || \"\\n//# sourceMappingURL=[url]\";\n    /** @type {string | Function} */\n\n    this.moduleFilenameTemplate = options.moduleFilenameTemplate || \"webpack://[namespace]/[resourcePath]\";\n    /** @type {string | Function} */\n\n    this.fallbackModuleFilenameTemplate = options.fallbackModuleFilenameTemplate || \"webpack://[namespace]/[resourcePath]?[hash]\";\n    /** @type {string} */\n\n    this.namespace = options.namespace || \"\";\n    /** @type {SourceMapDevToolPluginOptions} */\n\n    this.options = options;\n  }\n  /**\n   * Apply compiler\n   * @param {Compiler} compiler compiler instance\n   * @returns {void}\n   */\n\n\n  _createClass(SourceMapDevToolPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var sourceMapFilename = this.sourceMapFilename;\n      var sourceMappingURLComment = this.sourceMappingURLComment;\n      var moduleFilenameTemplate = this.moduleFilenameTemplate;\n      var namespace = this.namespace;\n      var fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate;\n      var requestShortener = compiler.requestShortener;\n      var options = this.options;\n      options.test = options.test || /\\.(m?js|css)($|\\?)/i;\n      var matchObject = ModuleFilenameHelpers.matchObject.bind(undefined, options);\n      compiler.hooks.compilation.tap(\"SourceMapDevToolPlugin\", function (compilation) {\n        new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);\n        compilation.hooks.afterOptimizeChunkAssets.tap(\n        /** @type {TODO} */\n        {\n          name: \"SourceMapDevToolPlugin\",\n          context: true\n        },\n        /**\n         * @param {object} context hook context\n         * @param {Array<Chunk>} chunks resulted chunks\n         * @throws {Error} throws error, if `sourceMapFilename === false && sourceMappingURLComment === false`\n         * @returns {void}\n         */\n        function (context, chunks) {\n          /** @type {Map<string | Module, string>} */\n          var moduleToSourceNameMapping = new Map();\n          /**\n           * @type {Function}\n           * @returns {void}\n           */\n\n          var reportProgress = context && context.reportProgress ? context.reportProgress : function () {};\n          var files = [];\n\n          var _iterator = _createForOfIteratorHelper(chunks),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var chunk = _step.value;\n\n              var _iterator2 = _createForOfIteratorHelper(chunk.files),\n                  _step2;\n\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  var file = _step2.value;\n\n                  if (matchObject(file)) {\n                    files.push({\n                      file: file,\n                      chunk: chunk\n                    });\n                  }\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          reportProgress(0.0);\n          var tasks = [];\n          files.forEach(function (_ref, idx) {\n            var file = _ref.file,\n                chunk = _ref.chunk;\n            var asset = compilation.getAsset(file).source;\n            var cache = assetsCache.get(asset);\n            /**\n             * If presented in cache, reassigns assets. Cache assets already have source maps.\n             */\n\n            if (cache && cache.file === file) {\n              for (var cachedFile in cache.assets) {\n                if (cachedFile === file) {\n                  compilation.updateAsset(cachedFile, cache.assets[cachedFile]);\n                } else {\n                  compilation.emitAsset(cachedFile, cache.assets[cachedFile], {\n                    development: true\n                  });\n                }\n                /**\n                 * Add file to chunk, if not presented there\n                 */\n\n\n                if (cachedFile !== file) chunk.files.push(cachedFile);\n              }\n\n              return;\n            }\n\n            reportProgress(0.5 * idx / files.length, file, \"generate SourceMap\");\n            /** @type {SourceMapTask | undefined} */\n\n            var task = getTaskForFile(file, asset, chunk, options, compilation);\n\n            if (task) {\n              var modules = task.modules;\n\n              for (var _idx = 0; _idx < modules.length; _idx++) {\n                var _module = modules[_idx];\n\n                if (!moduleToSourceNameMapping.get(_module)) {\n                  moduleToSourceNameMapping.set(_module, ModuleFilenameHelpers.createFilename(_module, {\n                    moduleFilenameTemplate: moduleFilenameTemplate,\n                    namespace: namespace\n                  }, requestShortener));\n                }\n              }\n\n              tasks.push(task);\n            }\n          });\n          reportProgress(0.5, \"resolve sources\");\n          /** @type {Set<string>} */\n\n          var usedNamesSet = new Set(moduleToSourceNameMapping.values());\n          /** @type {Set<string>} */\n\n          var conflictDetectionSet = new Set();\n          /**\n           * all modules in defined order (longest identifier first)\n           * @type {Array<string | Module>}\n           */\n\n          var allModules = Array.from(moduleToSourceNameMapping.keys()).sort(function (a, b) {\n            var ai = typeof a === \"string\" ? a : a.identifier();\n            var bi = typeof b === \"string\" ? b : b.identifier();\n            return ai.length - bi.length;\n          }); // find modules with conflicting source names\n\n          for (var idx = 0; idx < allModules.length; idx++) {\n            var _module2 = allModules[idx];\n            var sourceName = moduleToSourceNameMapping.get(_module2);\n            var hasName = conflictDetectionSet.has(sourceName);\n\n            if (!hasName) {\n              conflictDetectionSet.add(sourceName);\n              continue;\n            } // try the fallback name first\n\n\n            sourceName = ModuleFilenameHelpers.createFilename(_module2, {\n              moduleFilenameTemplate: fallbackModuleFilenameTemplate,\n              namespace: namespace\n            }, requestShortener);\n            hasName = usedNamesSet.has(sourceName);\n\n            if (!hasName) {\n              moduleToSourceNameMapping.set(_module2, sourceName);\n              usedNamesSet.add(sourceName);\n              continue;\n            } // elsewise just append stars until we have a valid name\n\n\n            while (hasName) {\n              sourceName += \"*\";\n              hasName = usedNamesSet.has(sourceName);\n            }\n\n            moduleToSourceNameMapping.set(_module2, sourceName);\n            usedNamesSet.add(sourceName);\n          }\n\n          tasks.forEach(function (task, index) {\n            reportProgress(0.5 + 0.5 * index / tasks.length, task.file, \"attach SourceMap\");\n            var assets = Object.create(null);\n            var chunk = task.chunk;\n            var file = task.file;\n            var asset = task.asset;\n            var sourceMap = task.sourceMap;\n            var source = task.source;\n            var modules = task.modules;\n            var moduleFilenames = modules.map(function (m) {\n              return moduleToSourceNameMapping.get(m);\n            });\n            sourceMap.sources = moduleFilenames;\n\n            if (options.noSources) {\n              sourceMap.sourcesContent = undefined;\n            }\n\n            sourceMap.sourceRoot = options.sourceRoot || \"\";\n            sourceMap.file = file;\n            assetsCache.set(asset, {\n              file: file,\n              assets: assets\n            });\n            /** @type {string | false} */\n\n            var currentSourceMappingURLComment = sourceMappingURLComment;\n\n            if (currentSourceMappingURLComment !== false && /\\.css($|\\?)/i.test(file)) {\n              currentSourceMappingURLComment = currentSourceMappingURLComment.replace(/^\\n\\/\\/(.*)$/, \"\\n/*$1*/\");\n            }\n\n            var sourceMapString = JSON.stringify(sourceMap);\n\n            if (sourceMapFilename) {\n              var filename = file;\n              var query = \"\";\n\n              var _idx2 = filename.indexOf(\"?\");\n\n              if (_idx2 >= 0) {\n                query = filename.substr(_idx2);\n                filename = filename.substr(0, _idx2);\n              }\n\n              var pathParams = {\n                chunk: chunk,\n                filename: options.fileContext ? path.relative(options.fileContext, filename) : filename,\n                query: query,\n                basename: basename(filename),\n                contentHash: createHash(\"md4\").update(sourceMapString).digest(\"hex\")\n              };\n              var sourceMapFile = compilation.getPath(sourceMapFilename, pathParams);\n              var sourceMapUrl = options.publicPath ? options.publicPath + sourceMapFile.replace(/\\\\/g, \"/\") : path.relative(path.dirname(file), sourceMapFile).replace(/\\\\/g, \"/\");\n              /**\n               * Add source map url to compilation asset, if {@link currentSourceMappingURLComment} presented\n               */\n\n              if (currentSourceMappingURLComment !== false) {\n                var _asset2 = new ConcatSource(new RawSource(source), compilation.getPath(currentSourceMappingURLComment, Object.assign({\n                  url: sourceMapUrl\n                }, pathParams)));\n\n                assets[file] = _asset2;\n                compilation.updateAsset(file, _asset2);\n              }\n              /**\n               * Add source map file to compilation assets and chunk files\n               */\n\n\n              var _asset = new RawSource(sourceMapString);\n\n              assets[sourceMapFile] = _asset;\n              compilation.emitAsset(sourceMapFile, _asset, {\n                development: true\n              });\n              chunk.files.push(sourceMapFile);\n            } else {\n              if (currentSourceMappingURLComment === false) {\n                throw new Error(\"SourceMapDevToolPlugin: append can't be false when no filename is provided\");\n              }\n              /**\n               * Add source map as data url to asset\n               */\n\n\n              var _asset3 = new ConcatSource(new RawSource(source), currentSourceMappingURLComment.replace(/\\[map\\]/g, function () {\n                return sourceMapString;\n              }).replace(/\\[url\\]/g, function () {\n                return \"data:application/json;charset=utf-8;base64,\".concat(Buffer.from(sourceMapString, \"utf-8\").toString(\"base64\"));\n              }));\n\n              assets[file] = _asset3;\n              compilation.updateAsset(file, _asset3);\n            }\n          });\n          reportProgress(1.0);\n        });\n      });\n    }\n  }]);\n\n  return SourceMapDevToolPlugin;\n}();\n\nmodule.exports = SourceMapDevToolPlugin;","map":null,"metadata":{},"sourceType":"module"}