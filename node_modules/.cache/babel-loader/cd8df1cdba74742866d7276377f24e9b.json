{"ast":null,"code":"\"use strict\";\n\nvar path = require(\"path\");\n/**\n * @param {string} context context for relative path\n * @param {string} relativePath path\n * @returns {string} absolute path\n */\n\n\nvar requestToAbsolute = function requestToAbsolute(context, relativePath) {\n  if (relativePath.startsWith(\"./\") || relativePath.startsWith(\"../\")) return path.join(context, relativePath);\n  return relativePath;\n};\n/**\n * @typedef {Object} MakeRelativePathsCache\n * @property {Map<string, Map<string, string>>=} relativePaths\n */\n\n/**\n *\n * @param {string} maybeAbsolutePath path to check\n * @returns {boolean} returns true if path is \"Absolute Path\"-like\n */\n\n\nvar looksLikeAbsolutePath = function looksLikeAbsolutePath(maybeAbsolutePath) {\n  if (/^\\/.*\\/$/.test(maybeAbsolutePath)) {\n    // this 'path' is actually a regexp generated by dynamic requires.\n    // Don't treat it as an absolute path.\n    return false;\n  }\n\n  return /^(?:[a-z]:\\\\|\\/)/i.test(maybeAbsolutePath);\n};\n/**\n *\n * @param {string} p path to normalize\n * @returns {string} normalized version of path\n */\n\n\nvar normalizePathSeparator = function normalizePathSeparator(p) {\n  return p.replace(/\\\\/g, \"/\");\n};\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\n\n\nvar _makePathsRelative = function _makePathsRelative(context, identifier) {\n  return identifier.split(/([|! ])/).map(function (str) {\n    return looksLikeAbsolutePath(str) ? normalizePathSeparator(path.relative(context, str)) : str;\n  }).join(\"\");\n};\n/**\n *\n * @param {string} context context used to create relative path\n * @param {string} identifier identifier used to create relative path\n * @param {MakeRelativePathsCache=} cache the cache object being set\n * @returns {string} the returned relative path\n */\n\n\nexports.makePathsRelative = function (context, identifier, cache) {\n  if (!cache) return _makePathsRelative(context, identifier);\n  var relativePaths = cache.relativePaths || (cache.relativePaths = new Map());\n  var cachedResult;\n  var contextCache = relativePaths.get(context);\n\n  if (contextCache === undefined) {\n    relativePaths.set(context, contextCache = new Map());\n  } else {\n    cachedResult = contextCache.get(identifier);\n  }\n\n  if (cachedResult !== undefined) {\n    return cachedResult;\n  } else {\n    var relativePath = _makePathsRelative(context, identifier);\n\n    contextCache.set(identifier, relativePath);\n    return relativePath;\n  }\n};\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string may containing absolute paths, query string, etc.\n * @returns {string} a new request string avoiding absolute paths when possible\n */\n\n\nexports.contextify = function (context, request) {\n  return request.split(\"!\").map(function (r) {\n    var splitPath = r.split(\"?\", 2);\n\n    if (/^[a-zA-Z]:\\\\/.test(splitPath[0])) {\n      splitPath[0] = path.win32.relative(context, splitPath[0]);\n\n      if (!/^[a-zA-Z]:\\\\/.test(splitPath[0])) {\n        splitPath[0] = splitPath[0].replace(/\\\\/g, \"/\");\n      }\n    }\n\n    if (/^\\//.test(splitPath[0])) {\n      splitPath[0] = path.posix.relative(context, splitPath[0]);\n    }\n\n    if (!/^(\\.\\.\\/|\\/|[a-zA-Z]:\\\\)/.test(splitPath[0])) {\n      splitPath[0] = \"./\" + splitPath[0];\n    }\n\n    return splitPath.join(\"?\");\n  }).join(\"!\");\n};\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string\n * @returns {string} a new request string using absolute paths when possible\n */\n\n\nvar _absolutify = function _absolutify(context, request) {\n  return request.split(\"!\").map(function (r) {\n    return requestToAbsolute(context, r);\n  }).join(\"!\");\n};\n\nexports.absolutify = _absolutify;","map":null,"metadata":{},"sourceType":"module"}