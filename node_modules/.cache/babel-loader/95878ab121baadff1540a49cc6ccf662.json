{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar Generator = require(\"../Generator\");\n\nvar Template = require(\"../Template\");\n\nvar WebAssemblyUtils = require(\"./WebAssemblyUtils\");\n\nvar _require = require(\"webpack-sources\"),\n    RawSource = _require.RawSource;\n\nvar _require2 = require(\"@webassemblyjs/wasm-edit\"),\n    editWithAST = _require2.editWithAST,\n    addWithAST = _require2.addWithAST;\n\nvar _require3 = require(\"@webassemblyjs/wasm-parser\"),\n    decode = _require3.decode;\n\nvar t = require(\"@webassemblyjs/ast\");\n\nvar _require4 = require(\"@webassemblyjs/helper-module-context\"),\n    moduleContextFromModuleAST = _require4.moduleContextFromModuleAST;\n\nvar WebAssemblyExportImportedDependency = require(\"../dependencies/WebAssemblyExportImportedDependency\");\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"./WebAssemblyUtils\").UsedWasmDependency} UsedWasmDependency */\n\n/** @typedef {import(\"../NormalModule\")} NormalModule */\n\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"../Dependency\").DependencyTemplate} DependencyTemplate */\n\n/**\n * @typedef {(ArrayBuffer) => ArrayBuffer} ArrayBufferTransform\n */\n\n/**\n * @template T\n * @param {Function[]} fns transforms\n * @returns {Function} composed transform\n */\n\n\nvar compose = function compose() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  return fns.reduce(function (prevFn, nextFn) {\n    return function (value) {\n      return nextFn(prevFn(value));\n    };\n  }, function (value) {\n    return value;\n  });\n}; // TODO replace with @callback\n\n/**\n * Removes the start instruction\n *\n * @param {Object} state unused state\n * @returns {ArrayBufferTransform} transform\n */\n\n\nvar removeStartFunc = function removeStartFunc(state) {\n  return function (bin) {\n    return editWithAST(state.ast, bin, {\n      Start: function Start(path) {\n        path.remove();\n      }\n    });\n  };\n};\n/**\n * Get imported globals\n *\n * @param {Object} ast Module's AST\n * @returns {Array<t.ModuleImport>} - nodes\n */\n\n\nvar getImportedGlobals = function getImportedGlobals(ast) {\n  var importedGlobals = [];\n  t.traverse(ast, {\n    ModuleImport: function ModuleImport(_ref) {\n      var node = _ref.node;\n\n      if (t.isGlobalType(node.descr)) {\n        importedGlobals.push(node);\n      }\n    }\n  });\n  return importedGlobals;\n};\n/**\n * Get the count for imported func\n *\n * @param {Object} ast Module's AST\n * @returns {Number} - count\n */\n\n\nvar getCountImportedFunc = function getCountImportedFunc(ast) {\n  var count = 0;\n  t.traverse(ast, {\n    ModuleImport: function ModuleImport(_ref2) {\n      var node = _ref2.node;\n\n      if (t.isFuncImportDescr(node.descr)) {\n        count++;\n      }\n    }\n  });\n  return count;\n};\n/**\n * Get next type index\n *\n * @param {Object} ast Module's AST\n * @returns {t.Index} - index\n */\n\n\nvar getNextTypeIndex = function getNextTypeIndex(ast) {\n  var typeSectionMetadata = t.getSectionMetadata(ast, \"type\");\n\n  if (typeSectionMetadata === undefined) {\n    return t.indexLiteral(0);\n  }\n\n  return t.indexLiteral(typeSectionMetadata.vectorOfSize.value);\n};\n/**\n * Get next func index\n *\n * The Func section metadata provide informations for implemented funcs\n * in order to have the correct index we shift the index by number of external\n * functions.\n *\n * @param {Object} ast Module's AST\n * @param {Number} countImportedFunc number of imported funcs\n * @returns {t.Index} - index\n */\n\n\nvar getNextFuncIndex = function getNextFuncIndex(ast, countImportedFunc) {\n  var funcSectionMetadata = t.getSectionMetadata(ast, \"func\");\n\n  if (funcSectionMetadata === undefined) {\n    return t.indexLiteral(0 + countImportedFunc);\n  }\n\n  var vectorOfSize = funcSectionMetadata.vectorOfSize.value;\n  return t.indexLiteral(vectorOfSize + countImportedFunc);\n};\n/**\n * Creates an init instruction for a global type\n * @param {t.GlobalType} globalType the global type\n * @returns {t.Instruction} init expression\n */\n\n\nvar createDefaultInitForGlobal = function createDefaultInitForGlobal(globalType) {\n  if (globalType.valtype[0] === \"i\") {\n    // create NumberLiteral global initializer\n    return t.objectInstruction(\"const\", globalType.valtype, [t.numberLiteralFromRaw(66)]);\n  } else if (globalType.valtype[0] === \"f\") {\n    // create FloatLiteral global initializer\n    return t.objectInstruction(\"const\", globalType.valtype, [t.floatLiteral(66, false, false, \"66\")]);\n  } else {\n    throw new Error(\"unknown type: \" + globalType.valtype);\n  }\n};\n/**\n * Rewrite the import globals:\n * - removes the ModuleImport instruction\n * - injects at the same offset a mutable global of the same type\n *\n * Since the imported globals are before the other global declarations, our\n * indices will be preserved.\n *\n * Note that globals will become mutable.\n *\n * @param {Object} state unused state\n * @returns {ArrayBufferTransform} transform\n */\n\n\nvar rewriteImportedGlobals = function rewriteImportedGlobals(state) {\n  return function (bin) {\n    var additionalInitCode = state.additionalInitCode;\n    var newGlobals = [];\n    bin = editWithAST(state.ast, bin, {\n      ModuleImport: function ModuleImport(path) {\n        if (t.isGlobalType(path.node.descr)) {\n          var globalType = path.node.descr;\n          globalType.mutability = \"var\";\n          var init = [createDefaultInitForGlobal(globalType), t.instruction(\"end\")];\n          newGlobals.push(t.global(globalType, init));\n          path.remove();\n        }\n      },\n      // in order to preserve non-imported global's order we need to re-inject\n      // those as well\n      Global: function Global(path) {\n        var node = path.node;\n\n        var _node$init = _slicedToArray(node.init, 1),\n            init = _node$init[0];\n\n        if (init.id === \"get_global\") {\n          node.globalType.mutability = \"var\";\n          var initialGlobalidx = init.args[0];\n          node.init = [createDefaultInitForGlobal(node.globalType), t.instruction(\"end\")];\n          additionalInitCode.push(\n          /**\n           * get_global in global initializer only works for imported globals.\n           * They have the same indices as the init params, so use the\n           * same index.\n           */\n          t.instruction(\"get_local\", [initialGlobalidx]), t.instruction(\"set_global\", [t.indexLiteral(newGlobals.length)]));\n        }\n\n        newGlobals.push(node);\n        path.remove();\n      }\n    }); // Add global declaration instructions\n\n    return addWithAST(state.ast, bin, newGlobals);\n  };\n};\n/**\n * Rewrite the export names\n * @param {Object} state state\n * @param {Object} state.ast Module's ast\n * @param {Module} state.module Module\n * @param {Set<string>} state.externalExports Module\n * @returns {ArrayBufferTransform} transform\n */\n\n\nvar rewriteExportNames = function rewriteExportNames(_ref3) {\n  var ast = _ref3.ast,\n      module = _ref3.module,\n      externalExports = _ref3.externalExports;\n  return function (bin) {\n    return editWithAST(ast, bin, {\n      ModuleExport: function ModuleExport(path) {\n        var isExternal = externalExports.has(path.node.name);\n\n        if (isExternal) {\n          path.remove();\n          return;\n        }\n\n        var usedName = module.isUsed(path.node.name);\n\n        if (!usedName) {\n          path.remove();\n          return;\n        }\n\n        path.node.name = usedName;\n      }\n    });\n  };\n};\n/**\n * Mangle import names and modules\n * @param {Object} state state\n * @param {Object} state.ast Module's ast\n * @param {Map<string, UsedWasmDependency>} state.usedDependencyMap mappings to mangle names\n * @returns {ArrayBufferTransform} transform\n */\n\n\nvar rewriteImports = function rewriteImports(_ref4) {\n  var ast = _ref4.ast,\n      usedDependencyMap = _ref4.usedDependencyMap;\n  return function (bin) {\n    return editWithAST(ast, bin, {\n      ModuleImport: function ModuleImport(path) {\n        var result = usedDependencyMap.get(path.node.module + \":\" + path.node.name);\n\n        if (result !== undefined) {\n          path.node.module = result.module;\n          path.node.name = result.name;\n        }\n      }\n    });\n  };\n};\n/**\n * Add an init function.\n *\n * The init function fills the globals given input arguments.\n *\n * @param {Object} state transformation state\n * @param {Object} state.ast Module's ast\n * @param {t.Identifier} state.initFuncId identifier of the init function\n * @param {t.Index} state.startAtFuncOffset index of the start function\n * @param {t.ModuleImport[]} state.importedGlobals list of imported globals\n * @param {t.Instruction[]} state.additionalInitCode list of addition instructions for the init function\n * @param {t.Index} state.nextFuncIndex index of the next function\n * @param {t.Index} state.nextTypeIndex index of the next type\n * @returns {ArrayBufferTransform} transform\n */\n\n\nvar addInitFunction = function addInitFunction(_ref5) {\n  var ast = _ref5.ast,\n      initFuncId = _ref5.initFuncId,\n      startAtFuncOffset = _ref5.startAtFuncOffset,\n      importedGlobals = _ref5.importedGlobals,\n      additionalInitCode = _ref5.additionalInitCode,\n      nextFuncIndex = _ref5.nextFuncIndex,\n      nextTypeIndex = _ref5.nextTypeIndex;\n  return function (bin) {\n    var funcParams = importedGlobals.map(function (importedGlobal) {\n      // used for debugging\n      var id = t.identifier(\"\".concat(importedGlobal.module, \".\").concat(importedGlobal.name));\n      return t.funcParam(importedGlobal.descr.valtype, id);\n    });\n    var funcBody = importedGlobals.reduce(function (acc, importedGlobal, index) {\n      var args = [t.indexLiteral(index)];\n      var body = [t.instruction(\"get_local\", args), t.instruction(\"set_global\", args)];\n      return [].concat(_toConsumableArray(acc), body);\n    }, []);\n\n    if (typeof startAtFuncOffset === \"number\") {\n      funcBody.push(t.callInstruction(t.numberLiteralFromRaw(startAtFuncOffset)));\n    }\n\n    var _iterator = _createForOfIteratorHelper(additionalInitCode),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var instr = _step.value;\n        funcBody.push(instr);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    funcBody.push(t.instruction(\"end\"));\n    var funcResults = []; // Code section\n\n    var funcSignature = t.signature(funcParams, funcResults);\n    var func = t.func(initFuncId, funcSignature, funcBody); // Type section\n\n    var functype = t.typeInstruction(undefined, funcSignature); // Func section\n\n    var funcindex = t.indexInFuncSection(nextTypeIndex); // Export section\n\n    var moduleExport = t.moduleExport(initFuncId.value, t.moduleExportDescr(\"Func\", nextFuncIndex));\n    return addWithAST(ast, bin, [func, moduleExport, funcindex, functype]);\n  };\n};\n/**\n * Extract mangle mappings from module\n * @param {Module} module current module\n * @param {boolean} mangle mangle imports\n * @returns {Map<string, UsedWasmDependency>} mappings to mangled names\n */\n\n\nvar getUsedDependencyMap = function getUsedDependencyMap(module, mangle) {\n  /** @type {Map<string, UsedWasmDependency>} */\n  var map = new Map();\n\n  var _iterator2 = _createForOfIteratorHelper(WebAssemblyUtils.getUsedDependencies(module, mangle)),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var usedDep = _step2.value;\n      var dep = usedDep.dependency;\n      var request = dep.request;\n      var exportName = dep.name;\n      map.set(request + \":\" + exportName, usedDep);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return map;\n};\n\nvar WebAssemblyGenerator = /*#__PURE__*/function (_Generator) {\n  _inherits(WebAssemblyGenerator, _Generator);\n\n  var _super = _createSuper(WebAssemblyGenerator);\n\n  function WebAssemblyGenerator(options) {\n    var _this;\n\n    _classCallCheck(this, WebAssemblyGenerator);\n\n    _this = _super.call(this);\n    _this.options = options;\n    return _this;\n  }\n  /**\n   * @param {NormalModule} module module for which the code should be generated\n   * @param {Map<Function, DependencyTemplate>} dependencyTemplates mapping from dependencies to templates\n   * @param {RuntimeTemplate} runtimeTemplate the runtime template\n   * @param {string} type which kind of code should be generated\n   * @returns {Source} generated code\n   */\n\n\n  _createClass(WebAssemblyGenerator, [{\n    key: \"generate\",\n    value: function generate(module, dependencyTemplates, runtimeTemplate, type) {\n      var bin = module.originalSource().source();\n      var initFuncId = t.identifier(Array.isArray(module.usedExports) ? Template.numberToIdentifer(module.usedExports.length) : \"__webpack_init__\"); // parse it\n\n      var ast = decode(bin, {\n        ignoreDataSection: true,\n        ignoreCodeSection: true,\n        ignoreCustomNameSection: true\n      });\n      var moduleContext = moduleContextFromModuleAST(ast.body[0]);\n      var importedGlobals = getImportedGlobals(ast);\n      var countImportedFunc = getCountImportedFunc(ast);\n      var startAtFuncOffset = moduleContext.getStart();\n      var nextFuncIndex = getNextFuncIndex(ast, countImportedFunc);\n      var nextTypeIndex = getNextTypeIndex(ast);\n      var usedDependencyMap = getUsedDependencyMap(module, this.options.mangleImports);\n      var externalExports = new Set(module.dependencies.filter(function (d) {\n        return d instanceof WebAssemblyExportImportedDependency;\n      }).map(function (d) {\n        var wasmDep =\n        /** @type {WebAssemblyExportImportedDependency} */\n        d;\n        return wasmDep.exportName;\n      }));\n      /** @type {t.Instruction[]} */\n\n      var additionalInitCode = [];\n      var transform = compose(rewriteExportNames({\n        ast: ast,\n        module: module,\n        externalExports: externalExports\n      }), removeStartFunc({\n        ast: ast\n      }), rewriteImportedGlobals({\n        ast: ast,\n        additionalInitCode: additionalInitCode\n      }), rewriteImports({\n        ast: ast,\n        usedDependencyMap: usedDependencyMap\n      }), addInitFunction({\n        ast: ast,\n        initFuncId: initFuncId,\n        importedGlobals: importedGlobals,\n        additionalInitCode: additionalInitCode,\n        startAtFuncOffset: startAtFuncOffset,\n        nextFuncIndex: nextFuncIndex,\n        nextTypeIndex: nextTypeIndex\n      }));\n      var newBin = transform(bin);\n      return new RawSource(newBin);\n    }\n  }]);\n\n  return WebAssemblyGenerator;\n}(Generator);\n\nmodule.exports = WebAssemblyGenerator;","map":null,"metadata":{},"sourceType":"module"}