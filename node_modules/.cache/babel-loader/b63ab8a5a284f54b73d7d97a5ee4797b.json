{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Jason Anderson @diurnalist\n*/\n\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar REGEXP_HASH = /\\[hash(?::(\\d+))?\\]/gi,\n    REGEXP_CHUNKHASH = /\\[chunkhash(?::(\\d+))?\\]/gi,\n    REGEXP_MODULEHASH = /\\[modulehash(?::(\\d+))?\\]/gi,\n    REGEXP_CONTENTHASH = /\\[contenthash(?::(\\d+))?\\]/gi,\n    REGEXP_NAME = /\\[name\\]/gi,\n    REGEXP_ID = /\\[id\\]/gi,\n    REGEXP_MODULEID = /\\[moduleid\\]/gi,\n    REGEXP_FILE = /\\[file\\]/gi,\n    REGEXP_QUERY = /\\[query\\]/gi,\n    REGEXP_FILEBASE = /\\[filebase\\]/gi,\n    REGEXP_URL = /\\[url\\]/gi; // Using global RegExp for .test is dangerous\n// We use a normal RegExp instead of .test\n\nvar REGEXP_HASH_FOR_TEST = new RegExp(REGEXP_HASH.source, \"i\"),\n    REGEXP_CHUNKHASH_FOR_TEST = new RegExp(REGEXP_CHUNKHASH.source, \"i\"),\n    REGEXP_CONTENTHASH_FOR_TEST = new RegExp(REGEXP_CONTENTHASH.source, \"i\"),\n    REGEXP_NAME_FOR_TEST = new RegExp(REGEXP_NAME.source, \"i\");\n\nvar withHashLength = function withHashLength(replacer, handlerFn, assetInfo) {\n  var fn = function fn(match, hashLength) {\n    if (assetInfo) assetInfo.immutable = true;\n    var length = hashLength && parseInt(hashLength, 10);\n\n    if (length && handlerFn) {\n      return handlerFn(length);\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    var hash = replacer.apply(void 0, [match, hashLength].concat(args));\n    return length ? hash.slice(0, length) : hash;\n  };\n\n  return fn;\n};\n\nvar getReplacer = function getReplacer(value, allowEmpty) {\n  var fn = function fn(match) {\n    var _ref;\n\n    // last argument in replacer is the entire input string\n    var input = (_ref = (arguments.length <= 1 ? 0 : arguments.length - 1) - 1 + 1, _ref < 1 || arguments.length <= _ref ? undefined : arguments[_ref]);\n\n    if (value === null || value === undefined) {\n      if (!allowEmpty) {\n        throw new Error(\"Path variable \".concat(match, \" not implemented in this context: \").concat(input));\n      }\n\n      return \"\";\n    } else {\n      return \"\".concat(escapePathVariables(value));\n    }\n  };\n\n  return fn;\n};\n\nvar escapePathVariables = function escapePathVariables(value) {\n  return typeof value === \"string\" ? value.replace(/\\[(\\\\*[\\w:]+\\\\*)\\]/gi, \"[\\\\$1\\\\]\") : value;\n};\n\nvar replacePathVariables = function replacePathVariables(path, data, assetInfo) {\n  var chunk = data.chunk;\n  var chunkId = chunk && chunk.id;\n  var chunkName = chunk && (chunk.name || chunk.id);\n  var chunkHash = chunk && (chunk.renderedHash || chunk.hash);\n  var chunkHashWithLength = chunk && chunk.hashWithLength;\n  var contentHashType = data.contentHashType;\n  var contentHash = chunk && chunk.contentHash && chunk.contentHash[contentHashType] || data.contentHash;\n  var contentHashWithLength = chunk && chunk.contentHashWithLength && chunk.contentHashWithLength[contentHashType] || data.contentHashWithLength;\n  var module = data.module;\n  var moduleId = module && module.id;\n  var moduleHash = module && (module.renderedHash || module.hash);\n  var moduleHashWithLength = module && module.hashWithLength;\n\n  if (typeof path === \"function\") {\n    path = path(data);\n  }\n\n  if (data.noChunkHash && (REGEXP_CHUNKHASH_FOR_TEST.test(path) || REGEXP_CONTENTHASH_FOR_TEST.test(path))) {\n    throw new Error(\"Cannot use [chunkhash] or [contenthash] for chunk in '\".concat(path, \"' (use [hash] instead)\"));\n  }\n\n  return path.replace(REGEXP_HASH, withHashLength(getReplacer(data.hash), data.hashWithLength, assetInfo)).replace(REGEXP_CHUNKHASH, withHashLength(getReplacer(chunkHash), chunkHashWithLength, assetInfo)).replace(REGEXP_CONTENTHASH, withHashLength(getReplacer(contentHash), contentHashWithLength, assetInfo)).replace(REGEXP_MODULEHASH, withHashLength(getReplacer(moduleHash), moduleHashWithLength, assetInfo)).replace(REGEXP_ID, getReplacer(chunkId)).replace(REGEXP_MODULEID, getReplacer(moduleId)).replace(REGEXP_NAME, getReplacer(chunkName)).replace(REGEXP_FILE, getReplacer(data.filename)).replace(REGEXP_FILEBASE, getReplacer(data.basename)) // query is optional, it's OK if it's in a path but there's nothing to replace it with\n  .replace(REGEXP_QUERY, getReplacer(data.query, true)) // only available in sourceMappingURLComment\n  .replace(REGEXP_URL, getReplacer(data.url)).replace(/\\[\\\\(\\\\*[\\w:]+\\\\*)\\\\\\]/gi, \"[$1]\");\n};\n\nvar TemplatedPathPlugin = /*#__PURE__*/function () {\n  function TemplatedPathPlugin() {\n    _classCallCheck(this, TemplatedPathPlugin);\n  }\n\n  _createClass(TemplatedPathPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      compiler.hooks.compilation.tap(\"TemplatedPathPlugin\", function (compilation) {\n        var mainTemplate = compilation.mainTemplate;\n        mainTemplate.hooks.assetPath.tap(\"TemplatedPathPlugin\", replacePathVariables);\n        mainTemplate.hooks.globalHash.tap(\"TemplatedPathPlugin\", function (chunk, paths) {\n          var outputOptions = mainTemplate.outputOptions;\n          var publicPath = outputOptions.publicPath || \"\";\n          var filename = outputOptions.filename || \"\";\n          var chunkFilename = outputOptions.chunkFilename || outputOptions.filename;\n          if (REGEXP_HASH_FOR_TEST.test(publicPath) || REGEXP_CHUNKHASH_FOR_TEST.test(publicPath) || REGEXP_CONTENTHASH_FOR_TEST.test(publicPath) || REGEXP_NAME_FOR_TEST.test(publicPath)) return true;\n          if (REGEXP_HASH_FOR_TEST.test(filename)) return true;\n          if (REGEXP_HASH_FOR_TEST.test(chunkFilename)) return true;\n          if (REGEXP_HASH_FOR_TEST.test(paths.join(\"|\"))) return true;\n        });\n        mainTemplate.hooks.hashForChunk.tap(\"TemplatedPathPlugin\", function (hash, chunk) {\n          var outputOptions = mainTemplate.outputOptions;\n          var chunkFilename = outputOptions.chunkFilename || outputOptions.filename;\n\n          if (REGEXP_CHUNKHASH_FOR_TEST.test(chunkFilename)) {\n            hash.update(JSON.stringify(chunk.getChunkMaps(true).hash));\n          }\n\n          if (REGEXP_CONTENTHASH_FOR_TEST.test(chunkFilename)) {\n            hash.update(JSON.stringify(chunk.getChunkMaps(true).contentHash.javascript || {}));\n          }\n\n          if (REGEXP_NAME_FOR_TEST.test(chunkFilename)) {\n            hash.update(JSON.stringify(chunk.getChunkMaps(true).name));\n          }\n        });\n      });\n    }\n  }]);\n\n  return TemplatedPathPlugin;\n}();\n\nmodule.exports = TemplatedPathPlugin;","map":null,"metadata":{},"sourceType":"module"}