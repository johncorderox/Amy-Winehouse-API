{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n/*\n<rules>: <rule>\n<rules>: [<rule>]\n<rule>: {\n\tresource: {\n\t\ttest: <condition>,\n\t\tinclude: <condition>,\n\t\texclude: <condition>,\n\t},\n\tresource: <condition>, -> resource.test\n\ttest: <condition>, -> resource.test\n\tinclude: <condition>, -> resource.include\n\texclude: <condition>, -> resource.exclude\n\tresourceQuery: <condition>,\n\tcompiler: <condition>,\n\tissuer: <condition>,\n\tuse: \"loader\", -> use[0].loader\n\tloader: <>, -> use[0].loader\n\tloaders: <>, -> use\n\toptions: {}, -> use[0].options,\n\tquery: {}, -> options\n\tparser: {},\n\tuse: [\n\t\t\"loader\" -> use[x].loader\n\t],\n\tuse: [\n\t\t{\n\t\t\tloader: \"loader\",\n\t\t\toptions: {}\n\t\t}\n\t],\n\trules: [\n\t\t<rule>\n\t],\n\toneOf: [\n\t\t<rule>\n\t]\n}\n\n<condition>: /regExp/\n<condition>: function(arg) {}\n<condition>: \"starting\"\n<condition>: [<condition>] // or\n<condition>: { and: [<condition>] }\n<condition>: { or: [<condition>] }\n<condition>: { not: [<condition>] }\n<condition>: { test: <condition>, include: <condition>, exclude: <condition> }\n\n\nnormalized:\n\n{\n\tresource: function(),\n\tresourceQuery: function(),\n\tcompiler: function(),\n\tissuer: function(),\n\tuse: [\n\t\t{\n\t\t\tloader: string,\n\t\t\toptions: string,\n\t\t\t<any>: <any>\n\t\t}\n\t],\n\trules: [<rule>],\n\toneOf: [<rule>],\n\t<any>: <any>,\n}\n\n*/\n\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar notMatcher = function notMatcher(matcher) {\n  return function (str) {\n    return !matcher(str);\n  };\n};\n\nvar orMatcher = function orMatcher(items) {\n  return function (str) {\n    for (var i = 0; i < items.length; i++) {\n      if (items[i](str)) return true;\n    }\n\n    return false;\n  };\n};\n\nvar andMatcher = function andMatcher(items) {\n  return function (str) {\n    for (var i = 0; i < items.length; i++) {\n      if (!items[i](str)) return false;\n    }\n\n    return true;\n  };\n};\n\nmodule.exports = /*#__PURE__*/function () {\n  function RuleSet(rules) {\n    _classCallCheck(this, RuleSet);\n\n    this.references = Object.create(null);\n    this.rules = RuleSet.normalizeRules(rules, this.references, \"ref-\");\n  }\n\n  _createClass(RuleSet, [{\n    key: \"exec\",\n    value: function exec(data) {\n      var result = [];\n\n      this._run(data, {\n        rules: this.rules\n      }, result);\n\n      return result;\n    }\n  }, {\n    key: \"_run\",\n    value: function _run(data, rule, result) {\n      // test conditions\n      if (rule.resource && !data.resource) return false;\n      if (rule.realResource && !data.realResource) return false;\n      if (rule.resourceQuery && !data.resourceQuery) return false;\n      if (rule.compiler && !data.compiler) return false;\n      if (rule.issuer && !data.issuer) return false;\n      if (rule.resource && !rule.resource(data.resource)) return false;\n      if (rule.realResource && !rule.realResource(data.realResource)) return false;\n      if (data.issuer && rule.issuer && !rule.issuer(data.issuer)) return false;\n\n      if (data.resourceQuery && rule.resourceQuery && !rule.resourceQuery(data.resourceQuery)) {\n        return false;\n      }\n\n      if (data.compiler && rule.compiler && !rule.compiler(data.compiler)) {\n        return false;\n      } // apply\n\n\n      var keys = Object.keys(rule).filter(function (key) {\n        return ![\"resource\", \"realResource\", \"resourceQuery\", \"compiler\", \"issuer\", \"rules\", \"oneOf\", \"use\", \"enforce\"].includes(key);\n      });\n\n      var _iterator = _createForOfIteratorHelper(keys),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n          result.push({\n            type: key,\n            value: rule[key]\n          });\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (rule.use) {\n        var process = function process(use) {\n          if (typeof use === \"function\") {\n            process(use(data));\n          } else if (Array.isArray(use)) {\n            use.forEach(process);\n          } else {\n            result.push({\n              type: \"use\",\n              value: use,\n              enforce: rule.enforce\n            });\n          }\n        };\n\n        process(rule.use);\n      }\n\n      if (rule.rules) {\n        for (var i = 0; i < rule.rules.length; i++) {\n          this._run(data, rule.rules[i], result);\n        }\n      }\n\n      if (rule.oneOf) {\n        for (var _i = 0; _i < rule.oneOf.length; _i++) {\n          if (this._run(data, rule.oneOf[_i], result)) break;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"findOptionsByIdent\",\n    value: function findOptionsByIdent(ident) {\n      var options = this.references[ident];\n\n      if (!options) {\n        throw new Error(\"Can't find options with ident '\" + ident + \"'\");\n      }\n\n      return options;\n    }\n  }], [{\n    key: \"normalizeRules\",\n    value: function normalizeRules(rules, refs, ident) {\n      if (Array.isArray(rules)) {\n        return rules.map(function (rule, idx) {\n          return RuleSet.normalizeRule(rule, refs, \"\".concat(ident, \"-\").concat(idx));\n        });\n      } else if (rules) {\n        return [RuleSet.normalizeRule(rules, refs, ident)];\n      } else {\n        return [];\n      }\n    }\n  }, {\n    key: \"normalizeRule\",\n    value: function normalizeRule(rule, refs, ident) {\n      if (typeof rule === \"string\") {\n        return {\n          use: [{\n            loader: rule\n          }]\n        };\n      }\n\n      if (!rule) {\n        throw new Error(\"Unexcepted null when object was expected as rule\");\n      }\n\n      if (_typeof(rule) !== \"object\") {\n        throw new Error(\"Unexcepted \" + _typeof(rule) + \" when object was expected as rule (\" + rule + \")\");\n      }\n\n      var newRule = {};\n      var useSource;\n      var resourceSource;\n      var condition;\n\n      var checkUseSource = function checkUseSource(newSource) {\n        if (useSource && useSource !== newSource) {\n          throw new Error(RuleSet.buildErrorMessage(rule, new Error(\"Rule can only have one result source (provided \" + newSource + \" and \" + useSource + \")\")));\n        }\n\n        useSource = newSource;\n      };\n\n      var checkResourceSource = function checkResourceSource(newSource) {\n        if (resourceSource && resourceSource !== newSource) {\n          throw new Error(RuleSet.buildErrorMessage(rule, new Error(\"Rule can only have one resource source (provided \" + newSource + \" and \" + resourceSource + \")\")));\n        }\n\n        resourceSource = newSource;\n      };\n\n      if (rule.test || rule.include || rule.exclude) {\n        checkResourceSource(\"test + include + exclude\");\n        condition = {\n          test: rule.test,\n          include: rule.include,\n          exclude: rule.exclude\n        };\n\n        try {\n          newRule.resource = RuleSet.normalizeCondition(condition);\n        } catch (error) {\n          throw new Error(RuleSet.buildErrorMessage(condition, error));\n        }\n      }\n\n      if (rule.resource) {\n        checkResourceSource(\"resource\");\n\n        try {\n          newRule.resource = RuleSet.normalizeCondition(rule.resource);\n        } catch (error) {\n          throw new Error(RuleSet.buildErrorMessage(rule.resource, error));\n        }\n      }\n\n      if (rule.realResource) {\n        try {\n          newRule.realResource = RuleSet.normalizeCondition(rule.realResource);\n        } catch (error) {\n          throw new Error(RuleSet.buildErrorMessage(rule.realResource, error));\n        }\n      }\n\n      if (rule.resourceQuery) {\n        try {\n          newRule.resourceQuery = RuleSet.normalizeCondition(rule.resourceQuery);\n        } catch (error) {\n          throw new Error(RuleSet.buildErrorMessage(rule.resourceQuery, error));\n        }\n      }\n\n      if (rule.compiler) {\n        try {\n          newRule.compiler = RuleSet.normalizeCondition(rule.compiler);\n        } catch (error) {\n          throw new Error(RuleSet.buildErrorMessage(rule.compiler, error));\n        }\n      }\n\n      if (rule.issuer) {\n        try {\n          newRule.issuer = RuleSet.normalizeCondition(rule.issuer);\n        } catch (error) {\n          throw new Error(RuleSet.buildErrorMessage(rule.issuer, error));\n        }\n      }\n\n      if (rule.loader && rule.loaders) {\n        throw new Error(RuleSet.buildErrorMessage(rule, new Error(\"Provided loader and loaders for rule (use only one of them)\")));\n      }\n\n      var loader = rule.loaders || rule.loader;\n\n      if (typeof loader === \"string\" && !rule.options && !rule.query) {\n        checkUseSource(\"loader\");\n        newRule.use = RuleSet.normalizeUse(loader.split(\"!\"), ident);\n      } else if (typeof loader === \"string\" && (rule.options || rule.query)) {\n        checkUseSource(\"loader + options/query\");\n        newRule.use = RuleSet.normalizeUse({\n          loader: loader,\n          options: rule.options,\n          query: rule.query\n        }, ident);\n      } else if (loader && (rule.options || rule.query)) {\n        throw new Error(RuleSet.buildErrorMessage(rule, new Error(\"options/query cannot be used with loaders (use options for each array item)\")));\n      } else if (loader) {\n        checkUseSource(\"loaders\");\n        newRule.use = RuleSet.normalizeUse(loader, ident);\n      } else if (rule.options || rule.query) {\n        throw new Error(RuleSet.buildErrorMessage(rule, new Error(\"options/query provided without loader (use loader + options)\")));\n      }\n\n      if (rule.use) {\n        checkUseSource(\"use\");\n        newRule.use = RuleSet.normalizeUse(rule.use, ident);\n      }\n\n      if (rule.rules) {\n        newRule.rules = RuleSet.normalizeRules(rule.rules, refs, \"\".concat(ident, \"-rules\"));\n      }\n\n      if (rule.oneOf) {\n        newRule.oneOf = RuleSet.normalizeRules(rule.oneOf, refs, \"\".concat(ident, \"-oneOf\"));\n      }\n\n      var keys = Object.keys(rule).filter(function (key) {\n        return ![\"resource\", \"resourceQuery\", \"compiler\", \"test\", \"include\", \"exclude\", \"issuer\", \"loader\", \"options\", \"query\", \"loaders\", \"use\", \"rules\", \"oneOf\"].includes(key);\n      });\n\n      var _iterator2 = _createForOfIteratorHelper(keys),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var key = _step2.value;\n          newRule[key] = rule[key];\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      if (Array.isArray(newRule.use)) {\n        var _iterator3 = _createForOfIteratorHelper(newRule.use),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var item = _step3.value;\n\n            if (item.ident) {\n              refs[item.ident] = item.options;\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n\n      return newRule;\n    }\n  }, {\n    key: \"buildErrorMessage\",\n    value: function buildErrorMessage(condition, error) {\n      var conditionAsText = JSON.stringify(condition, function (key, value) {\n        return value === undefined ? \"undefined\" : value;\n      }, 2);\n      return error.message + \" in \" + conditionAsText;\n    }\n  }, {\n    key: \"normalizeUse\",\n    value: function normalizeUse(use, ident) {\n      if (typeof use === \"function\") {\n        return function (data) {\n          return RuleSet.normalizeUse(use(data), ident);\n        };\n      }\n\n      if (Array.isArray(use)) {\n        return use.map(function (item, idx) {\n          return RuleSet.normalizeUse(item, \"\".concat(ident, \"-\").concat(idx));\n        }).reduce(function (arr, items) {\n          return arr.concat(items);\n        }, []);\n      }\n\n      return [RuleSet.normalizeUseItem(use, ident)];\n    }\n  }, {\n    key: \"normalizeUseItemString\",\n    value: function normalizeUseItemString(useItemString) {\n      var idx = useItemString.indexOf(\"?\");\n\n      if (idx >= 0) {\n        return {\n          loader: useItemString.substr(0, idx),\n          options: useItemString.substr(idx + 1)\n        };\n      }\n\n      return {\n        loader: useItemString,\n        options: undefined\n      };\n    }\n  }, {\n    key: \"normalizeUseItem\",\n    value: function normalizeUseItem(item, ident) {\n      if (typeof item === \"string\") {\n        return RuleSet.normalizeUseItemString(item);\n      }\n\n      var newItem = {};\n\n      if (item.options && item.query) {\n        throw new Error(\"Provided options and query in use\");\n      }\n\n      if (!item.loader) {\n        throw new Error(\"No loader specified\");\n      }\n\n      newItem.options = item.options || item.query;\n\n      if (_typeof(newItem.options) === \"object\" && newItem.options) {\n        if (newItem.options.ident) {\n          newItem.ident = newItem.options.ident;\n        } else {\n          newItem.ident = ident;\n        }\n      }\n\n      var keys = Object.keys(item).filter(function (key) {\n        return ![\"options\", \"query\"].includes(key);\n      });\n\n      var _iterator4 = _createForOfIteratorHelper(keys),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var key = _step4.value;\n          newItem[key] = item[key];\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return newItem;\n    }\n  }, {\n    key: \"normalizeCondition\",\n    value: function normalizeCondition(condition) {\n      if (!condition) throw new Error(\"Expected condition but got falsy value\");\n\n      if (typeof condition === \"string\") {\n        return function (str) {\n          return str.indexOf(condition) === 0;\n        };\n      }\n\n      if (typeof condition === \"function\") {\n        return condition;\n      }\n\n      if (condition instanceof RegExp) {\n        return condition.test.bind(condition);\n      }\n\n      if (Array.isArray(condition)) {\n        var items = condition.map(function (c) {\n          return RuleSet.normalizeCondition(c);\n        });\n        return orMatcher(items);\n      }\n\n      if (_typeof(condition) !== \"object\") {\n        throw Error(\"Unexcepted \" + _typeof(condition) + \" when condition was expected (\" + condition + \")\");\n      }\n\n      var matchers = [];\n      Object.keys(condition).forEach(function (key) {\n        var value = condition[key];\n\n        switch (key) {\n          case \"or\":\n          case \"include\":\n          case \"test\":\n            if (value) matchers.push(RuleSet.normalizeCondition(value));\n            break;\n\n          case \"and\":\n            if (value) {\n              var _items = value.map(function (c) {\n                return RuleSet.normalizeCondition(c);\n              });\n\n              matchers.push(andMatcher(_items));\n            }\n\n            break;\n\n          case \"not\":\n          case \"exclude\":\n            if (value) {\n              var matcher = RuleSet.normalizeCondition(value);\n              matchers.push(notMatcher(matcher));\n            }\n\n            break;\n\n          default:\n            throw new Error(\"Unexcepted property \" + key + \" in condition\");\n        }\n      });\n\n      if (matchers.length === 0) {\n        throw new Error(\"Excepted condition but got \" + condition);\n      }\n\n      if (matchers.length === 1) {\n        return matchers[0];\n      }\n\n      return andMatcher(matchers);\n    }\n  }]);\n\n  return RuleSet;\n}();","map":null,"metadata":{},"sourceType":"module"}