{"ast":null,"code":"var fs = require('fs');\n\nvar path = require('path');\n\nvar util = require('util');\n\nfunction Y18N(opts) {\n  // configurable options.\n  opts = opts || {};\n  this.directory = opts.directory || './locales';\n  this.updateFiles = typeof opts.updateFiles === 'boolean' ? opts.updateFiles : true;\n  this.locale = opts.locale || 'en';\n  this.fallbackToLanguage = typeof opts.fallbackToLanguage === 'boolean' ? opts.fallbackToLanguage : true; // internal stuff.\n\n  this.cache = Object.create(null);\n  this.writeQueue = [];\n}\n\nY18N.prototype.__ = function () {\n  if (typeof arguments[0] !== 'string') {\n    return this._taggedLiteral.apply(this, arguments);\n  }\n\n  var args = Array.prototype.slice.call(arguments);\n  var str = args.shift();\n\n  var cb = function cb() {}; // start with noop.\n\n\n  if (typeof args[args.length - 1] === 'function') cb = args.pop();\n\n  cb = cb || function () {}; // noop.\n\n\n  if (!this.cache[this.locale]) this._readLocaleFile(); // we've observed a new string, update the language file.\n\n  if (!this.cache[this.locale][str] && this.updateFiles) {\n    this.cache[this.locale][str] = str; // include the current directory and locale,\n    // since these values could change before the\n    // write is performed.\n\n    this._enqueueWrite([this.directory, this.locale, cb]);\n  } else {\n    cb();\n  }\n\n  return util.format.apply(util, [this.cache[this.locale][str] || str].concat(args));\n};\n\nY18N.prototype._taggedLiteral = function (parts) {\n  var args = arguments;\n  var str = '';\n  parts.forEach(function (part, i) {\n    var arg = args[i + 1];\n    str += part;\n\n    if (typeof arg !== 'undefined') {\n      str += '%s';\n    }\n  });\n  return this.__.apply(null, [str].concat([].slice.call(arguments, 1)));\n};\n\nY18N.prototype._enqueueWrite = function (work) {\n  this.writeQueue.push(work);\n  if (this.writeQueue.length === 1) this._processWriteQueue();\n};\n\nY18N.prototype._processWriteQueue = function () {\n  var _this = this;\n\n  var work = this.writeQueue[0]; // destructure the enqueued work.\n\n  var directory = work[0];\n  var locale = work[1];\n  var cb = work[2];\n\n  var languageFile = this._resolveLocaleFile(directory, locale);\n\n  var serializedLocale = JSON.stringify(this.cache[locale], null, 2);\n  fs.writeFile(languageFile, serializedLocale, 'utf-8', function (err) {\n    _this.writeQueue.shift();\n\n    if (_this.writeQueue.length > 0) _this._processWriteQueue();\n    cb(err);\n  });\n};\n\nY18N.prototype._readLocaleFile = function () {\n  var localeLookup = {};\n\n  var languageFile = this._resolveLocaleFile(this.directory, this.locale);\n\n  try {\n    localeLookup = JSON.parse(fs.readFileSync(languageFile, 'utf-8'));\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      err.message = 'syntax error in ' + languageFile;\n    }\n\n    if (err.code === 'ENOENT') localeLookup = {};else throw err;\n  }\n\n  this.cache[this.locale] = localeLookup;\n};\n\nY18N.prototype._resolveLocaleFile = function (directory, locale) {\n  var file = path.resolve(directory, './', locale + '.json');\n\n  if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf('_')) {\n    // attempt fallback to language only\n    var languageFile = path.resolve(directory, './', locale.split('_')[0] + '.json');\n    if (this._fileExistsSync(languageFile)) file = languageFile;\n  }\n\n  return file;\n}; // this only exists because fs.existsSync() \"will be deprecated\"\n// see https://nodejs.org/api/fs.html#fs_fs_existssync_path\n\n\nY18N.prototype._fileExistsSync = function (file) {\n  try {\n    return fs.statSync(file).isFile();\n  } catch (err) {\n    return false;\n  }\n};\n\nY18N.prototype.__n = function () {\n  var args = Array.prototype.slice.call(arguments);\n  var singular = args.shift();\n  var plural = args.shift();\n  var quantity = args.shift();\n\n  var cb = function cb() {}; // start with noop.\n\n\n  if (typeof args[args.length - 1] === 'function') cb = args.pop();\n  if (!this.cache[this.locale]) this._readLocaleFile();\n  var str = quantity === 1 ? singular : plural;\n\n  if (this.cache[this.locale][singular]) {\n    str = this.cache[this.locale][singular][quantity === 1 ? 'one' : 'other'];\n  } // we've observed a new string, update the language file.\n\n\n  if (!this.cache[this.locale][singular] && this.updateFiles) {\n    this.cache[this.locale][singular] = {\n      one: singular,\n      other: plural\n    }; // include the current directory and locale,\n    // since these values could change before the\n    // write is performed.\n\n    this._enqueueWrite([this.directory, this.locale, cb]);\n  } else {\n    cb();\n  } // if a %d placeholder is provided, add quantity\n  // to the arguments expanded by util.format.\n\n\n  var values = [str];\n  if (~str.indexOf('%d')) values.push(quantity);\n  return util.format.apply(util, values.concat(args));\n};\n\nY18N.prototype.setLocale = function (locale) {\n  this.locale = locale;\n};\n\nY18N.prototype.getLocale = function () {\n  return this.locale;\n};\n\nY18N.prototype.updateLocale = function (obj) {\n  if (!this.cache[this.locale]) this._readLocaleFile();\n\n  for (var key in obj) {\n    this.cache[this.locale][key] = obj[key];\n  }\n};\n\nmodule.exports = function (opts) {\n  var y18n = new Y18N(opts); // bind all functions to y18n, so that\n  // they can be used in isolation.\n\n  for (var key in y18n) {\n    if (typeof y18n[key] === 'function') {\n      y18n[key] = y18n[key].bind(y18n);\n    }\n  }\n\n  return y18n;\n};","map":null,"metadata":{},"sourceType":"module"}