{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar OptionsApply = require(\"./OptionsApply\");\n\nvar JavascriptModulesPlugin = require(\"./JavascriptModulesPlugin\");\n\nvar JsonModulesPlugin = require(\"./JsonModulesPlugin\");\n\nvar WebAssemblyModulesPlugin = require(\"./wasm/WebAssemblyModulesPlugin\");\n\nvar LoaderTargetPlugin = require(\"./LoaderTargetPlugin\");\n\nvar FunctionModulePlugin = require(\"./FunctionModulePlugin\");\n\nvar EvalDevToolModulePlugin = require(\"./EvalDevToolModulePlugin\");\n\nvar SourceMapDevToolPlugin = require(\"./SourceMapDevToolPlugin\");\n\nvar EvalSourceMapDevToolPlugin = require(\"./EvalSourceMapDevToolPlugin\");\n\nvar EntryOptionPlugin = require(\"./EntryOptionPlugin\");\n\nvar RecordIdsPlugin = require(\"./RecordIdsPlugin\");\n\nvar APIPlugin = require(\"./APIPlugin\");\n\nvar ConstPlugin = require(\"./ConstPlugin\");\n\nvar CommonJsStuffPlugin = require(\"./CommonJsStuffPlugin\");\n\nvar CompatibilityPlugin = require(\"./CompatibilityPlugin\");\n\nvar TemplatedPathPlugin = require(\"./TemplatedPathPlugin\");\n\nvar WarnCaseSensitiveModulesPlugin = require(\"./WarnCaseSensitiveModulesPlugin\");\n\nvar UseStrictPlugin = require(\"./UseStrictPlugin\");\n\nvar LoaderPlugin = require(\"./dependencies/LoaderPlugin\");\n\nvar CommonJsPlugin = require(\"./dependencies/CommonJsPlugin\");\n\nvar HarmonyModulesPlugin = require(\"./dependencies/HarmonyModulesPlugin\");\n\nvar SystemPlugin = require(\"./dependencies/SystemPlugin\");\n\nvar ImportPlugin = require(\"./dependencies/ImportPlugin\");\n\nvar RequireContextPlugin = require(\"./dependencies/RequireContextPlugin\");\n\nvar RequireEnsurePlugin = require(\"./dependencies/RequireEnsurePlugin\");\n\nvar RequireIncludePlugin = require(\"./dependencies/RequireIncludePlugin\");\n\nvar _require = require(\"./util/cleverMerge\"),\n    cachedCleverMerge = _require.cachedCleverMerge;\n/** @typedef {import(\"../declarations/WebpackOptions\").WebpackOptions} WebpackOptions */\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n\nvar WebpackOptionsApply = /*#__PURE__*/function (_OptionsApply) {\n  _inherits(WebpackOptionsApply, _OptionsApply);\n\n  var _super = _createSuper(WebpackOptionsApply);\n\n  function WebpackOptionsApply() {\n    _classCallCheck(this, WebpackOptionsApply);\n\n    return _super.call(this);\n  }\n  /**\n   * @param {WebpackOptions} options options object\n   * @param {Compiler} compiler compiler object\n   * @returns {WebpackOptions} options object\n   */\n\n\n  _createClass(WebpackOptionsApply, [{\n    key: \"process\",\n    value: function process(options, compiler) {\n      var ExternalsPlugin;\n      compiler.outputPath = options.output.path;\n      compiler.recordsInputPath = options.recordsInputPath || options.recordsPath;\n      compiler.recordsOutputPath = options.recordsOutputPath || options.recordsPath;\n      compiler.name = options.name; // TODO webpack 5 refactor this to MultiCompiler.setDependencies() with a WeakMap\n      // @ts-ignore TODO\n\n      compiler.dependencies = options.dependencies;\n\n      if (typeof options.target === \"string\") {\n        var JsonpTemplatePlugin;\n        var FetchCompileWasmTemplatePlugin;\n        var ReadFileCompileWasmTemplatePlugin;\n        var NodeSourcePlugin;\n        var NodeTargetPlugin;\n        var NodeTemplatePlugin;\n\n        switch (options.target) {\n          case \"web\":\n            JsonpTemplatePlugin = require(\"./web/JsonpTemplatePlugin\");\n            FetchCompileWasmTemplatePlugin = require(\"./web/FetchCompileWasmTemplatePlugin\");\n            NodeSourcePlugin = require(\"./node/NodeSourcePlugin\");\n            new JsonpTemplatePlugin().apply(compiler);\n            new FetchCompileWasmTemplatePlugin({\n              mangleImports: options.optimization.mangleWasmImports\n            }).apply(compiler);\n            new FunctionModulePlugin().apply(compiler);\n            new NodeSourcePlugin(options.node).apply(compiler);\n            new LoaderTargetPlugin(options.target).apply(compiler);\n            break;\n\n          case \"webworker\":\n            {\n              var WebWorkerTemplatePlugin = require(\"./webworker/WebWorkerTemplatePlugin\");\n\n              FetchCompileWasmTemplatePlugin = require(\"./web/FetchCompileWasmTemplatePlugin\");\n              NodeSourcePlugin = require(\"./node/NodeSourcePlugin\");\n              new WebWorkerTemplatePlugin().apply(compiler);\n              new FetchCompileWasmTemplatePlugin({\n                mangleImports: options.optimization.mangleWasmImports\n              }).apply(compiler);\n              new FunctionModulePlugin().apply(compiler);\n              new NodeSourcePlugin(options.node).apply(compiler);\n              new LoaderTargetPlugin(options.target).apply(compiler);\n              break;\n            }\n\n          case \"node\":\n          case \"async-node\":\n            NodeTemplatePlugin = require(\"./node/NodeTemplatePlugin\");\n            ReadFileCompileWasmTemplatePlugin = require(\"./node/ReadFileCompileWasmTemplatePlugin\");\n            NodeTargetPlugin = require(\"./node/NodeTargetPlugin\");\n            new NodeTemplatePlugin({\n              asyncChunkLoading: options.target === \"async-node\"\n            }).apply(compiler);\n            new ReadFileCompileWasmTemplatePlugin({\n              mangleImports: options.optimization.mangleWasmImports\n            }).apply(compiler);\n            new FunctionModulePlugin().apply(compiler);\n            new NodeTargetPlugin().apply(compiler);\n            new LoaderTargetPlugin(\"node\").apply(compiler);\n            break;\n\n          case \"node-webkit\":\n            JsonpTemplatePlugin = require(\"./web/JsonpTemplatePlugin\");\n            NodeTargetPlugin = require(\"./node/NodeTargetPlugin\");\n            ExternalsPlugin = require(\"./ExternalsPlugin\");\n            new JsonpTemplatePlugin().apply(compiler);\n            new FunctionModulePlugin().apply(compiler);\n            new NodeTargetPlugin().apply(compiler);\n            new ExternalsPlugin(\"commonjs\", \"nw.gui\").apply(compiler);\n            new LoaderTargetPlugin(options.target).apply(compiler);\n            break;\n\n          case \"electron-main\":\n            NodeTemplatePlugin = require(\"./node/NodeTemplatePlugin\");\n            NodeTargetPlugin = require(\"./node/NodeTargetPlugin\");\n            ExternalsPlugin = require(\"./ExternalsPlugin\");\n            new NodeTemplatePlugin({\n              asyncChunkLoading: true\n            }).apply(compiler);\n            new FunctionModulePlugin().apply(compiler);\n            new NodeTargetPlugin().apply(compiler);\n            new ExternalsPlugin(\"commonjs\", [\"app\", \"auto-updater\", \"browser-window\", \"clipboard\", \"content-tracing\", \"crash-reporter\", \"dialog\", \"electron\", \"global-shortcut\", \"ipc\", \"ipc-main\", \"menu\", \"menu-item\", \"native-image\", \"original-fs\", \"power-monitor\", \"power-save-blocker\", \"protocol\", \"screen\", \"session\", \"shell\", \"tray\", \"web-contents\"]).apply(compiler);\n            new LoaderTargetPlugin(options.target).apply(compiler);\n            break;\n\n          case \"electron-renderer\":\n          case \"electron-preload\":\n            FetchCompileWasmTemplatePlugin = require(\"./web/FetchCompileWasmTemplatePlugin\");\n            NodeTargetPlugin = require(\"./node/NodeTargetPlugin\");\n            ExternalsPlugin = require(\"./ExternalsPlugin\");\n\n            if (options.target === \"electron-renderer\") {\n              JsonpTemplatePlugin = require(\"./web/JsonpTemplatePlugin\");\n              new JsonpTemplatePlugin().apply(compiler);\n            } else if (options.target === \"electron-preload\") {\n              NodeTemplatePlugin = require(\"./node/NodeTemplatePlugin\");\n              new NodeTemplatePlugin({\n                asyncChunkLoading: true\n              }).apply(compiler);\n            }\n\n            new FetchCompileWasmTemplatePlugin({\n              mangleImports: options.optimization.mangleWasmImports\n            }).apply(compiler);\n            new FunctionModulePlugin().apply(compiler);\n            new NodeTargetPlugin().apply(compiler);\n            new ExternalsPlugin(\"commonjs\", [\"clipboard\", \"crash-reporter\", \"desktop-capturer\", \"electron\", \"ipc\", \"ipc-renderer\", \"native-image\", \"original-fs\", \"remote\", \"screen\", \"shell\", \"web-frame\"]).apply(compiler);\n            new LoaderTargetPlugin(options.target).apply(compiler);\n            break;\n\n          default:\n            throw new Error(\"Unsupported target '\" + options.target + \"'.\");\n        }\n      } // @ts-ignore This is always true, which is good this way\n      else if (options.target !== false) {\n          options.target(compiler);\n        } else {\n          throw new Error(\"Unsupported target '\" + options.target + \"'.\");\n        }\n\n      if (options.output.library || options.output.libraryTarget !== \"var\") {\n        var LibraryTemplatePlugin = require(\"./LibraryTemplatePlugin\");\n\n        new LibraryTemplatePlugin(options.output.library, options.output.libraryTarget, options.output.umdNamedDefine, options.output.auxiliaryComment || \"\", options.output.libraryExport).apply(compiler);\n      }\n\n      if (options.externals) {\n        ExternalsPlugin = require(\"./ExternalsPlugin\");\n        new ExternalsPlugin(options.output.libraryTarget, options.externals).apply(compiler);\n      }\n\n      var noSources;\n      var legacy;\n      var modern;\n      var comment;\n\n      if (options.devtool && (options.devtool.includes(\"sourcemap\") || options.devtool.includes(\"source-map\"))) {\n        var hidden = options.devtool.includes(\"hidden\");\n        var inline = options.devtool.includes(\"inline\");\n        var evalWrapped = options.devtool.includes(\"eval\");\n        var cheap = options.devtool.includes(\"cheap\");\n        var moduleMaps = options.devtool.includes(\"module\");\n        noSources = options.devtool.includes(\"nosources\");\n        legacy = options.devtool.includes(\"@\");\n        modern = options.devtool.includes(\"#\");\n        comment = legacy && modern ? \"\\n/*\\n//@ source\" + \"MappingURL=[url]\\n//# source\" + \"MappingURL=[url]\\n*/\" : legacy ? \"\\n/*\\n//@ source\" + \"MappingURL=[url]\\n*/\" : modern ? \"\\n//# source\" + \"MappingURL=[url]\" : null;\n        var Plugin = evalWrapped ? EvalSourceMapDevToolPlugin : SourceMapDevToolPlugin;\n        new Plugin({\n          filename: inline ? null : options.output.sourceMapFilename,\n          moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate,\n          fallbackModuleFilenameTemplate: options.output.devtoolFallbackModuleFilenameTemplate,\n          append: hidden ? false : comment,\n          module: moduleMaps ? true : cheap ? false : true,\n          columns: cheap ? false : true,\n          lineToLine: options.output.devtoolLineToLine,\n          noSources: noSources,\n          namespace: options.output.devtoolNamespace\n        }).apply(compiler);\n      } else if (options.devtool && options.devtool.includes(\"eval\")) {\n        legacy = options.devtool.includes(\"@\");\n        modern = options.devtool.includes(\"#\");\n        comment = legacy && modern ? \"\\n//@ sourceURL=[url]\\n//# sourceURL=[url]\" : legacy ? \"\\n//@ sourceURL=[url]\" : modern ? \"\\n//# sourceURL=[url]\" : null;\n        new EvalDevToolModulePlugin({\n          sourceUrlComment: comment,\n          moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate,\n          namespace: options.output.devtoolNamespace\n        }).apply(compiler);\n      }\n\n      new JavascriptModulesPlugin().apply(compiler);\n      new JsonModulesPlugin().apply(compiler);\n      new WebAssemblyModulesPlugin({\n        mangleImports: options.optimization.mangleWasmImports\n      }).apply(compiler);\n      new EntryOptionPlugin().apply(compiler);\n      compiler.hooks.entryOption.call(options.context, options.entry);\n      new CompatibilityPlugin().apply(compiler);\n      new HarmonyModulesPlugin(options.module).apply(compiler);\n\n      if (options.amd !== false) {\n        var AMDPlugin = require(\"./dependencies/AMDPlugin\");\n\n        var RequireJsStuffPlugin = require(\"./RequireJsStuffPlugin\");\n\n        new AMDPlugin(options.module, options.amd || {}).apply(compiler);\n        new RequireJsStuffPlugin().apply(compiler);\n      }\n\n      new CommonJsPlugin(options.module).apply(compiler);\n      new LoaderPlugin().apply(compiler);\n\n      if (options.node !== false) {\n        var NodeStuffPlugin = require(\"./NodeStuffPlugin\");\n\n        new NodeStuffPlugin(options.node).apply(compiler);\n      }\n\n      new CommonJsStuffPlugin().apply(compiler);\n      new APIPlugin().apply(compiler);\n      new ConstPlugin().apply(compiler);\n      new UseStrictPlugin().apply(compiler);\n      new RequireIncludePlugin().apply(compiler);\n      new RequireEnsurePlugin().apply(compiler);\n      new RequireContextPlugin(options.resolve.modules, options.resolve.extensions, options.resolve.mainFiles).apply(compiler);\n      new ImportPlugin(options.module).apply(compiler);\n      new SystemPlugin(options.module).apply(compiler);\n\n      if (typeof options.mode !== \"string\") {\n        var WarnNoModeSetPlugin = require(\"./WarnNoModeSetPlugin\");\n\n        new WarnNoModeSetPlugin().apply(compiler);\n      }\n\n      var EnsureChunkConditionsPlugin = require(\"./optimize/EnsureChunkConditionsPlugin\");\n\n      new EnsureChunkConditionsPlugin().apply(compiler);\n\n      if (options.optimization.removeAvailableModules) {\n        var RemoveParentModulesPlugin = require(\"./optimize/RemoveParentModulesPlugin\");\n\n        new RemoveParentModulesPlugin().apply(compiler);\n      }\n\n      if (options.optimization.removeEmptyChunks) {\n        var RemoveEmptyChunksPlugin = require(\"./optimize/RemoveEmptyChunksPlugin\");\n\n        new RemoveEmptyChunksPlugin().apply(compiler);\n      }\n\n      if (options.optimization.mergeDuplicateChunks) {\n        var MergeDuplicateChunksPlugin = require(\"./optimize/MergeDuplicateChunksPlugin\");\n\n        new MergeDuplicateChunksPlugin().apply(compiler);\n      }\n\n      if (options.optimization.flagIncludedChunks) {\n        var FlagIncludedChunksPlugin = require(\"./optimize/FlagIncludedChunksPlugin\");\n\n        new FlagIncludedChunksPlugin().apply(compiler);\n      }\n\n      if (options.optimization.sideEffects) {\n        var SideEffectsFlagPlugin = require(\"./optimize/SideEffectsFlagPlugin\");\n\n        new SideEffectsFlagPlugin().apply(compiler);\n      }\n\n      if (options.optimization.providedExports) {\n        var FlagDependencyExportsPlugin = require(\"./FlagDependencyExportsPlugin\");\n\n        new FlagDependencyExportsPlugin().apply(compiler);\n      }\n\n      if (options.optimization.usedExports) {\n        var FlagDependencyUsagePlugin = require(\"./FlagDependencyUsagePlugin\");\n\n        new FlagDependencyUsagePlugin().apply(compiler);\n      }\n\n      if (options.optimization.concatenateModules) {\n        var ModuleConcatenationPlugin = require(\"./optimize/ModuleConcatenationPlugin\");\n\n        new ModuleConcatenationPlugin().apply(compiler);\n      }\n\n      if (options.optimization.splitChunks) {\n        var SplitChunksPlugin = require(\"./optimize/SplitChunksPlugin\");\n\n        new SplitChunksPlugin(options.optimization.splitChunks).apply(compiler);\n      }\n\n      if (options.optimization.runtimeChunk) {\n        var RuntimeChunkPlugin = require(\"./optimize/RuntimeChunkPlugin\");\n\n        new RuntimeChunkPlugin(options.optimization.runtimeChunk).apply(compiler);\n      }\n\n      if (options.optimization.noEmitOnErrors) {\n        var NoEmitOnErrorsPlugin = require(\"./NoEmitOnErrorsPlugin\");\n\n        new NoEmitOnErrorsPlugin().apply(compiler);\n      }\n\n      if (options.optimization.checkWasmTypes) {\n        var WasmFinalizeExportsPlugin = require(\"./wasm/WasmFinalizeExportsPlugin\");\n\n        new WasmFinalizeExportsPlugin().apply(compiler);\n      }\n\n      var moduleIds = options.optimization.moduleIds;\n\n      if (moduleIds === undefined) {\n        // TODO webpack 5 remove all these options\n        if (options.optimization.occurrenceOrder) {\n          moduleIds = \"size\";\n        }\n\n        if (options.optimization.namedModules) {\n          moduleIds = \"named\";\n        }\n\n        if (options.optimization.hashedModuleIds) {\n          moduleIds = \"hashed\";\n        }\n\n        if (moduleIds === undefined) {\n          moduleIds = \"natural\";\n        }\n      }\n\n      if (moduleIds) {\n        var NamedModulesPlugin = require(\"./NamedModulesPlugin\");\n\n        var HashedModuleIdsPlugin = require(\"./HashedModuleIdsPlugin\");\n\n        var OccurrenceModuleOrderPlugin = require(\"./optimize/OccurrenceModuleOrderPlugin\");\n\n        switch (moduleIds) {\n          case \"natural\":\n            // TODO webpack 5: see hint in Compilation.sortModules\n            break;\n\n          case \"named\":\n            new NamedModulesPlugin().apply(compiler);\n            break;\n\n          case \"hashed\":\n            new HashedModuleIdsPlugin().apply(compiler);\n            break;\n\n          case \"size\":\n            new OccurrenceModuleOrderPlugin({\n              prioritiseInitial: true\n            }).apply(compiler);\n            break;\n\n          case \"total-size\":\n            new OccurrenceModuleOrderPlugin({\n              prioritiseInitial: false\n            }).apply(compiler);\n            break;\n\n          default:\n            throw new Error(\"webpack bug: moduleIds: \".concat(moduleIds, \" is not implemented\"));\n        }\n      }\n\n      var chunkIds = options.optimization.chunkIds;\n\n      if (chunkIds === undefined) {\n        // TODO webpack 5 remove all these options\n        if (options.optimization.occurrenceOrder) {\n          // This looks weird but it's for backward-compat\n          // This bug already existed before adding this feature\n          chunkIds = \"total-size\";\n        }\n\n        if (options.optimization.namedChunks) {\n          chunkIds = \"named\";\n        }\n\n        if (chunkIds === undefined) {\n          chunkIds = \"natural\";\n        }\n      }\n\n      if (chunkIds) {\n        var NaturalChunkOrderPlugin = require(\"./optimize/NaturalChunkOrderPlugin\");\n\n        var NamedChunksPlugin = require(\"./NamedChunksPlugin\");\n\n        var OccurrenceChunkOrderPlugin = require(\"./optimize/OccurrenceChunkOrderPlugin\");\n\n        switch (chunkIds) {\n          case \"natural\":\n            new NaturalChunkOrderPlugin().apply(compiler);\n            break;\n\n          case \"named\":\n            // TODO webapck 5: for backward-compat this need to have OccurrenceChunkOrderPlugin too\n            // The NamedChunksPlugin doesn't give every chunk a name\n            // This should be fixed, and the OccurrenceChunkOrderPlugin should be removed here.\n            new OccurrenceChunkOrderPlugin({\n              prioritiseInitial: false\n            }).apply(compiler);\n            new NamedChunksPlugin().apply(compiler);\n            break;\n\n          case \"size\":\n            new OccurrenceChunkOrderPlugin({\n              prioritiseInitial: true\n            }).apply(compiler);\n            break;\n\n          case \"total-size\":\n            new OccurrenceChunkOrderPlugin({\n              prioritiseInitial: false\n            }).apply(compiler);\n            break;\n\n          default:\n            throw new Error(\"webpack bug: chunkIds: \".concat(chunkIds, \" is not implemented\"));\n        }\n      }\n\n      if (options.optimization.nodeEnv) {\n        var DefinePlugin = require(\"./DefinePlugin\");\n\n        new DefinePlugin({\n          \"process.env.NODE_ENV\": JSON.stringify(options.optimization.nodeEnv)\n        }).apply(compiler);\n      }\n\n      if (options.optimization.minimize) {\n        var _iterator = _createForOfIteratorHelper(options.optimization.minimizer),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var minimizer = _step.value;\n\n            if (typeof minimizer === \"function\") {\n              minimizer.call(compiler, compiler);\n            } else {\n              minimizer.apply(compiler);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      if (options.performance) {\n        var SizeLimitsPlugin = require(\"./performance/SizeLimitsPlugin\");\n\n        new SizeLimitsPlugin(options.performance).apply(compiler);\n      }\n\n      new TemplatedPathPlugin().apply(compiler);\n      new RecordIdsPlugin({\n        portableIds: options.optimization.portableRecords\n      }).apply(compiler);\n      new WarnCaseSensitiveModulesPlugin().apply(compiler);\n\n      if (options.cache) {\n        var CachePlugin = require(\"./CachePlugin\");\n\n        new CachePlugin(_typeof(options.cache) === \"object\" ? options.cache : null).apply(compiler);\n      }\n\n      compiler.hooks.afterPlugins.call(compiler);\n\n      if (!compiler.inputFileSystem) {\n        throw new Error(\"No input filesystem provided\");\n      }\n\n      compiler.resolverFactory.hooks.resolveOptions[\"for\"](\"normal\").tap(\"WebpackOptionsApply\", function (resolveOptions) {\n        return Object.assign({\n          fileSystem: compiler.inputFileSystem\n        }, cachedCleverMerge(options.resolve, resolveOptions));\n      });\n      compiler.resolverFactory.hooks.resolveOptions[\"for\"](\"context\").tap(\"WebpackOptionsApply\", function (resolveOptions) {\n        return Object.assign({\n          fileSystem: compiler.inputFileSystem,\n          resolveToContext: true\n        }, cachedCleverMerge(options.resolve, resolveOptions));\n      });\n      compiler.resolverFactory.hooks.resolveOptions[\"for\"](\"loader\").tap(\"WebpackOptionsApply\", function (resolveOptions) {\n        return Object.assign({\n          fileSystem: compiler.inputFileSystem\n        }, cachedCleverMerge(options.resolveLoader, resolveOptions));\n      });\n      compiler.hooks.afterResolvers.call(compiler);\n      return options;\n    }\n  }]);\n\n  return WebpackOptionsApply;\n}(OptionsApply);\n\nmodule.exports = WebpackOptionsApply;","map":null,"metadata":{},"sourceType":"module"}