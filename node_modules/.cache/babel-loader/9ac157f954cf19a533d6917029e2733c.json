{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar AsyncDependencyToInitialChunkError = require(\"./AsyncDependencyToInitialChunkError\");\n\nvar GraphHelpers = require(\"./GraphHelpers\");\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n\n/** @typedef {import(\"./Compilation\")} Compilation */\n\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n\n/** @typedef {import(\"./Dependency\")} Dependency */\n\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/**\n * @typedef {Object} QueueItem\n * @property {number} action\n * @property {DependenciesBlock} block\n * @property {Module} module\n * @property {Chunk} chunk\n * @property {ChunkGroup} chunkGroup\n */\n\n/**\n * @typedef {Object} ChunkGroupInfo\n * @property {ChunkGroup} chunkGroup the chunk group\n * @property {Set<Module>} minAvailableModules current minimal set of modules available at this point\n * @property {boolean} minAvailableModulesOwned true, if minAvailableModules is owned and can be modified\n * @property {Set<Module>[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules\n * @property {QueueItem[]} skippedItems queue items that were skipped because module is already available in parent chunks (need to reconsider when minAvailableModules is shrinking)\n * @property {Set<Module>} resultingAvailableModules set of modules available including modules from this chunk group\n * @property {Set<ChunkGroup>} children set of children chunk groups, that will be revisited when availableModules shrink\n */\n\n/**\n * @typedef {Object} BlockChunkGroupConnection\n * @property {ChunkGroupInfo} originChunkGroupInfo origin chunk group\n * @property {ChunkGroup} chunkGroup referenced chunk group\n */\n\n/**\n * @template T\n * @param {Set<T>} a first set\n * @param {Set<T>} b second set\n * @returns {number} cmp\n */\n\n\nvar bySetSize = function bySetSize(a, b) {\n  return b.size - a.size;\n};\n/**\n * Extracts simplified info from the modules and their dependencies\n * @param {Compilation} compilation the compilation\n * @returns {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} the mapping block to modules and inner blocks\n */\n\n\nvar extraceBlockInfoMap = function extraceBlockInfoMap(compilation) {\n  /** @type {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} */\n  var blockInfoMap = new Map();\n  /**\n   * @param {Dependency} d dependency to iterate over\n   * @returns {void}\n   */\n\n  var iteratorDependency = function iteratorDependency(d) {\n    // We skip Dependencies without Reference\n    var ref = compilation.getDependencyReference(currentModule, d);\n\n    if (!ref) {\n      return;\n    } // We skip Dependencies without Module pointer\n\n\n    var refModule = ref.module;\n\n    if (!refModule) {\n      return;\n    } // We skip weak Dependencies\n\n\n    if (ref.weak) {\n      return;\n    }\n\n    blockInfoModules.add(refModule);\n  };\n  /**\n   * @param {AsyncDependenciesBlock} b blocks to prepare\n   * @returns {void}\n   */\n\n\n  var iteratorBlockPrepare = function iteratorBlockPrepare(b) {\n    blockInfoBlocks.push(b);\n    blockQueue.push(b);\n  };\n  /** @type {Module} */\n\n\n  var currentModule;\n  /** @type {DependenciesBlock} */\n\n  var block;\n  /** @type {DependenciesBlock[]} */\n\n  var blockQueue;\n  /** @type {Set<Module>} */\n\n  var blockInfoModules;\n  /** @type {AsyncDependenciesBlock[]} */\n\n  var blockInfoBlocks;\n\n  var _iterator = _createForOfIteratorHelper(compilation.modules),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _module = _step.value;\n      blockQueue = [_module];\n      currentModule = _module;\n\n      while (blockQueue.length > 0) {\n        block = blockQueue.pop();\n        blockInfoModules = new Set();\n        blockInfoBlocks = [];\n\n        if (block.variables) {\n          var _iterator2 = _createForOfIteratorHelper(block.variables),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var variable = _step2.value;\n\n              var _iterator3 = _createForOfIteratorHelper(variable.dependencies),\n                  _step3;\n\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  var dep = _step3.value;\n                  iteratorDependency(dep);\n                }\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n\n        if (block.dependencies) {\n          var _iterator4 = _createForOfIteratorHelper(block.dependencies),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _dep = _step4.value;\n              iteratorDependency(_dep);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n\n        if (block.blocks) {\n          var _iterator5 = _createForOfIteratorHelper(block.blocks),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var b = _step5.value;\n              iteratorBlockPrepare(b);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n\n        var blockInfo = {\n          modules: blockInfoModules,\n          blocks: blockInfoBlocks\n        };\n        blockInfoMap.set(block, blockInfo);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return blockInfoMap;\n};\n/**\n *\n * @param {Compilation} compilation the compilation\n * @param {Entrypoint[]} inputChunkGroups input groups\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Set<ChunkGroup>} allCreatedChunkGroups filled with all chunk groups that are created here\n */\n\n\nvar visitModules = function visitModules(compilation, inputChunkGroups, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups) {\n  var logger = compilation.getLogger(\"webpack.buildChunkGraph.visitModules\");\n  var namedChunkGroups = compilation.namedChunkGroups;\n  logger.time(\"prepare\");\n  var blockInfoMap = extraceBlockInfoMap(compilation);\n  /** @type {Map<ChunkGroup, { index: number, index2: number }>} */\n\n  var chunkGroupCounters = new Map();\n\n  var _iterator6 = _createForOfIteratorHelper(inputChunkGroups),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var _chunkGroup3 = _step6.value;\n      chunkGroupCounters.set(_chunkGroup3, {\n        index: 0,\n        index2: 0\n      });\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  var nextFreeModuleIndex = 0;\n  var nextFreeModuleIndex2 = 0;\n  /** @type {Map<DependenciesBlock, ChunkGroup>} */\n\n  var blockChunkGroups = new Map();\n  var ADD_AND_ENTER_MODULE = 0;\n  var ENTER_MODULE = 1;\n  var PROCESS_BLOCK = 2;\n  var LEAVE_MODULE = 3;\n  /**\n   * @param {QueueItem[]} queue the queue array (will be mutated)\n   * @param {ChunkGroup} chunkGroup chunk group\n   * @returns {QueueItem[]} the queue array again\n   */\n\n  var reduceChunkGroupToQueueItem = function reduceChunkGroupToQueueItem(queue, chunkGroup) {\n    var _iterator7 = _createForOfIteratorHelper(chunkGroup.chunks),\n        _step7;\n\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var _chunk = _step7.value;\n        var _module2 = _chunk.entryModule;\n        queue.push({\n          action: ENTER_MODULE,\n          block: _module2,\n          module: _module2,\n          chunk: _chunk,\n          chunkGroup: chunkGroup\n        });\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n\n    chunkGroupInfoMap.set(chunkGroup, {\n      chunkGroup: chunkGroup,\n      minAvailableModules: new Set(),\n      minAvailableModulesOwned: true,\n      availableModulesToBeMerged: [],\n      skippedItems: [],\n      resultingAvailableModules: undefined,\n      children: undefined\n    });\n    return queue;\n  }; // Start with the provided modules/chunks\n\n  /** @type {QueueItem[]} */\n\n\n  var queue = inputChunkGroups.reduce(reduceChunkGroupToQueueItem, []).reverse();\n  /** @type {Map<ChunkGroup, Set<ChunkGroup>>} */\n\n  var queueConnect = new Map();\n  /** @type {Set<ChunkGroupInfo>} */\n\n  var outdatedChunkGroupInfo = new Set();\n  /** @type {QueueItem[]} */\n\n  var queueDelayed = [];\n  logger.timeEnd(\"prepare\");\n  /** @type {Module} */\n\n  var module;\n  /** @type {Chunk} */\n\n  var chunk;\n  /** @type {ChunkGroup} */\n\n  var chunkGroup;\n  /** @type {ChunkGroupInfo} */\n\n  var chunkGroupInfo;\n  /** @type {DependenciesBlock} */\n\n  var block;\n  /** @type {Set<Module>} */\n\n  var minAvailableModules;\n  /** @type {QueueItem[]} */\n\n  var skippedItems; // For each async Block in graph\n\n  /**\n   * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock\n   * @returns {void}\n   */\n\n  var iteratorBlock = function iteratorBlock(b) {\n    // 1. We create a chunk for this Block\n    // but only once (blockChunkGroups map)\n    var c = blockChunkGroups.get(b);\n\n    if (c === undefined) {\n      c = namedChunkGroups.get(b.chunkName);\n\n      if (c && c.isInitial()) {\n        compilation.errors.push(new AsyncDependencyToInitialChunkError(b.chunkName, module, b.loc));\n        c = chunkGroup;\n      } else {\n        c = compilation.addChunkInGroup(b.groupOptions || b.chunkName, module, b.loc, b.request);\n        chunkGroupCounters.set(c, {\n          index: 0,\n          index2: 0\n        });\n        blockChunkGroups.set(b, c);\n        allCreatedChunkGroups.add(c);\n      }\n\n      blockConnections.set(b, []);\n    } else {\n      // TODO webpack 5 remove addOptions check\n      if (c.addOptions) c.addOptions(b.groupOptions);\n      c.addOrigin(module, b.loc, b.request);\n    } // 2. We store the connection for the block\n    // to connect it later if needed\n\n\n    blockConnections.get(b).push({\n      originChunkGroupInfo: chunkGroupInfo,\n      chunkGroup: c\n    }); // 3. We create/update the chunk group info\n\n    var connectList = queueConnect.get(chunkGroup);\n\n    if (connectList === undefined) {\n      connectList = new Set();\n      queueConnect.set(chunkGroup, connectList);\n    }\n\n    connectList.add(c); // 4. We enqueue the DependenciesBlock for traversal\n\n    queueDelayed.push({\n      action: PROCESS_BLOCK,\n      block: b,\n      module: module,\n      chunk: c.chunks[0],\n      chunkGroup: c\n    });\n  }; // Iterative traversal of the Module graph\n  // Recursive would be simpler to write but could result in Stack Overflows\n\n\n  while (queue.length) {\n    logger.time(\"visiting\");\n\n    while (queue.length) {\n      var queueItem = queue.pop();\n      module = queueItem.module;\n      block = queueItem.block;\n      chunk = queueItem.chunk;\n\n      if (chunkGroup !== queueItem.chunkGroup) {\n        chunkGroup = queueItem.chunkGroup;\n        chunkGroupInfo = chunkGroupInfoMap.get(chunkGroup);\n        minAvailableModules = chunkGroupInfo.minAvailableModules;\n        skippedItems = chunkGroupInfo.skippedItems;\n      }\n\n      switch (queueItem.action) {\n        case ADD_AND_ENTER_MODULE:\n          {\n            if (minAvailableModules.has(module)) {\n              // already in parent chunks\n              // skip it for now, but enqueue for rechecking when minAvailableModules shrinks\n              skippedItems.push(queueItem);\n              break;\n            } // We connect Module and Chunk when not already done\n\n\n            if (chunk.addModule(module)) {\n              module.addChunk(chunk);\n            } else {\n              // already connected, skip it\n              break;\n            }\n          }\n        // fallthrough\n\n        case ENTER_MODULE:\n          {\n            if (chunkGroup !== undefined) {\n              var index = chunkGroup.getModuleIndex(module);\n\n              if (index === undefined) {\n                chunkGroup.setModuleIndex(module, chunkGroupCounters.get(chunkGroup).index++);\n              }\n            }\n\n            if (module.index === null) {\n              module.index = nextFreeModuleIndex++;\n            }\n\n            queue.push({\n              action: LEAVE_MODULE,\n              block: block,\n              module: module,\n              chunk: chunk,\n              chunkGroup: chunkGroup\n            });\n          }\n        // fallthrough\n\n        case PROCESS_BLOCK:\n          {\n            // get prepared block info\n            var blockInfo = blockInfoMap.get(block); // Buffer items because order need to be reverse to get indicies correct\n\n            var skipBuffer = [];\n            var queueBuffer = []; // Traverse all referenced modules\n\n            var _iterator8 = _createForOfIteratorHelper(blockInfo.modules),\n                _step8;\n\n            try {\n              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                var refModule = _step8.value;\n\n                if (chunk.containsModule(refModule)) {\n                  // skip early if already connected\n                  continue;\n                }\n\n                if (minAvailableModules.has(refModule)) {\n                  // already in parent chunks, skip it for now\n                  skipBuffer.push({\n                    action: ADD_AND_ENTER_MODULE,\n                    block: refModule,\n                    module: refModule,\n                    chunk: chunk,\n                    chunkGroup: chunkGroup\n                  });\n                  continue;\n                } // enqueue the add and enter to enter in the correct order\n                // this is relevant with circular dependencies\n\n\n                queueBuffer.push({\n                  action: ADD_AND_ENTER_MODULE,\n                  block: refModule,\n                  module: refModule,\n                  chunk: chunk,\n                  chunkGroup: chunkGroup\n                });\n              } // Add buffered items in reversed order\n\n            } catch (err) {\n              _iterator8.e(err);\n            } finally {\n              _iterator8.f();\n            }\n\n            for (var i = skipBuffer.length - 1; i >= 0; i--) {\n              skippedItems.push(skipBuffer[i]);\n            }\n\n            for (var _i = queueBuffer.length - 1; _i >= 0; _i--) {\n              queue.push(queueBuffer[_i]);\n            } // Traverse all Blocks\n\n\n            var _iterator9 = _createForOfIteratorHelper(blockInfo.blocks),\n                _step9;\n\n            try {\n              for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                var _block = _step9.value;\n                iteratorBlock(_block);\n              }\n            } catch (err) {\n              _iterator9.e(err);\n            } finally {\n              _iterator9.f();\n            }\n\n            if (blockInfo.blocks.length > 0 && module !== block) {\n              blocksWithNestedBlocks.add(block);\n            }\n\n            break;\n          }\n\n        case LEAVE_MODULE:\n          {\n            if (chunkGroup !== undefined) {\n              var _index = chunkGroup.getModuleIndex2(module);\n\n              if (_index === undefined) {\n                chunkGroup.setModuleIndex2(module, chunkGroupCounters.get(chunkGroup).index2++);\n              }\n            }\n\n            if (module.index2 === null) {\n              module.index2 = nextFreeModuleIndex2++;\n            }\n\n            break;\n          }\n      }\n    }\n\n    logger.timeEnd(\"visiting\");\n\n    while (queueConnect.size > 0) {\n      logger.time(\"calculating available modules\"); // Figure out new parents for chunk groups\n      // to get new available modules for these children\n\n      var _iterator10 = _createForOfIteratorHelper(queueConnect),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var _ref3 = _step10.value;\n\n          var _ref2 = _slicedToArray(_ref3, 2);\n\n          var _chunkGroup2 = _ref2[0];\n          var targets = _ref2[1];\n\n          var _info = chunkGroupInfoMap.get(_chunkGroup2);\n\n          var _minAvailableModules = _info.minAvailableModules; // 1. Create a new Set of available modules at this points\n\n          var resultingAvailableModules = new Set(_minAvailableModules);\n\n          var _iterator17 = _createForOfIteratorHelper(_chunkGroup2.chunks),\n              _step17;\n\n          try {\n            for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n              var _chunk2 = _step17.value;\n\n              var _iterator20 = _createForOfIteratorHelper(_chunk2.modulesIterable),\n                  _step20;\n\n              try {\n                for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n                  var _m2 = _step20.value;\n                  resultingAvailableModules.add(_m2);\n                }\n              } catch (err) {\n                _iterator20.e(err);\n              } finally {\n                _iterator20.f();\n              }\n            }\n          } catch (err) {\n            _iterator17.e(err);\n          } finally {\n            _iterator17.f();\n          }\n\n          _info.resultingAvailableModules = resultingAvailableModules;\n\n          if (_info.children === undefined) {\n            _info.children = targets;\n          } else {\n            var _iterator18 = _createForOfIteratorHelper(targets),\n                _step18;\n\n            try {\n              for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n                var target = _step18.value;\n\n                _info.children.add(target);\n              }\n            } catch (err) {\n              _iterator18.e(err);\n            } finally {\n              _iterator18.f();\n            }\n          } // 2. Update chunk group info\n\n\n          var _iterator19 = _createForOfIteratorHelper(targets),\n              _step19;\n\n          try {\n            for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n              var _target = _step19.value;\n\n              var _chunkGroupInfo = chunkGroupInfoMap.get(_target);\n\n              if (_chunkGroupInfo === undefined) {\n                _chunkGroupInfo = {\n                  chunkGroup: _target,\n                  minAvailableModules: undefined,\n                  minAvailableModulesOwned: undefined,\n                  availableModulesToBeMerged: [],\n                  skippedItems: [],\n                  resultingAvailableModules: undefined,\n                  children: undefined\n                };\n                chunkGroupInfoMap.set(_target, _chunkGroupInfo);\n              }\n\n              _chunkGroupInfo.availableModulesToBeMerged.push(resultingAvailableModules);\n\n              outdatedChunkGroupInfo.add(_chunkGroupInfo);\n            }\n          } catch (err) {\n            _iterator19.e(err);\n          } finally {\n            _iterator19.f();\n          }\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n\n      queueConnect.clear();\n      logger.timeEnd(\"calculating available modules\");\n\n      if (outdatedChunkGroupInfo.size > 0) {\n        logger.time(\"merging available modules\"); // Execute the merge\n\n        var _iterator11 = _createForOfIteratorHelper(outdatedChunkGroupInfo),\n            _step11;\n\n        try {\n          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n            var info = _step11.value;\n            var availableModulesToBeMerged = info.availableModulesToBeMerged;\n            var cachedMinAvailableModules = info.minAvailableModules; // 1. Get minimal available modules\n            // It doesn't make sense to traverse a chunk again with more available modules.\n            // This step calculates the minimal available modules and skips traversal when\n            // the list didn't shrink.\n\n            if (availableModulesToBeMerged.length > 1) {\n              availableModulesToBeMerged.sort(bySetSize);\n            }\n\n            var changed = false;\n\n            var _iterator12 = _createForOfIteratorHelper(availableModulesToBeMerged),\n                _step12;\n\n            try {\n              for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n                var availableModules = _step12.value;\n\n                if (cachedMinAvailableModules === undefined) {\n                  cachedMinAvailableModules = availableModules;\n                  info.minAvailableModules = cachedMinAvailableModules;\n                  info.minAvailableModulesOwned = false;\n                  changed = true;\n                } else {\n                  if (info.minAvailableModulesOwned) {\n                    // We own it and can modify it\n                    var _iterator15 = _createForOfIteratorHelper(cachedMinAvailableModules),\n                        _step15;\n\n                    try {\n                      for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n                        var m = _step15.value;\n\n                        if (!availableModules.has(m)) {\n                          cachedMinAvailableModules[\"delete\"](m);\n                          changed = true;\n                        }\n                      }\n                    } catch (err) {\n                      _iterator15.e(err);\n                    } finally {\n                      _iterator15.f();\n                    }\n                  } else {\n                    var _iterator16 = _createForOfIteratorHelper(cachedMinAvailableModules),\n                        _step16;\n\n                    try {\n                      for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n                        var _m = _step16.value;\n\n                        if (!availableModules.has(_m)) {\n                          // cachedMinAvailableModules need to be modified\n                          // but we don't own it\n                          // construct a new Set as intersection of cachedMinAvailableModules and availableModules\n\n                          /** @type {Set<Module>} */\n                          var newSet = new Set();\n                          var iterator = cachedMinAvailableModules[Symbol.iterator]();\n                          /** @type {IteratorResult<Module>} */\n\n                          var it = void 0;\n\n                          while (!(it = iterator.next()).done) {\n                            var _module3 = it.value;\n                            if (_module3 === _m) break;\n                            newSet.add(_module3);\n                          }\n\n                          while (!(it = iterator.next()).done) {\n                            var _module4 = it.value;\n\n                            if (availableModules.has(_module4)) {\n                              newSet.add(_module4);\n                            }\n                          }\n\n                          cachedMinAvailableModules = newSet;\n                          info.minAvailableModulesOwned = true;\n                          info.minAvailableModules = newSet; // Update the cache from the first queue\n                          // if the chunkGroup is currently cached\n\n                          if (chunkGroup === info.chunkGroup) {\n                            minAvailableModules = cachedMinAvailableModules;\n                          }\n\n                          changed = true;\n                          break;\n                        }\n                      }\n                    } catch (err) {\n                      _iterator16.e(err);\n                    } finally {\n                      _iterator16.f();\n                    }\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator12.e(err);\n            } finally {\n              _iterator12.f();\n            }\n\n            availableModulesToBeMerged.length = 0;\n            if (!changed) continue; // 2. Reconsider skipped items\n\n            var _iterator13 = _createForOfIteratorHelper(info.skippedItems),\n                _step13;\n\n            try {\n              for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n                var _queueItem = _step13.value;\n                queue.push(_queueItem);\n              }\n            } catch (err) {\n              _iterator13.e(err);\n            } finally {\n              _iterator13.f();\n            }\n\n            info.skippedItems.length = 0; // 3. Reconsider children chunk groups\n\n            if (info.children !== undefined) {\n              var _chunkGroup = info.chunkGroup;\n\n              var _iterator14 = _createForOfIteratorHelper(info.children),\n                  _step14;\n\n              try {\n                for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n                  var c = _step14.value;\n                  var connectList = queueConnect.get(_chunkGroup);\n\n                  if (connectList === undefined) {\n                    connectList = new Set();\n                    queueConnect.set(_chunkGroup, connectList);\n                  }\n\n                  connectList.add(c);\n                }\n              } catch (err) {\n                _iterator14.e(err);\n              } finally {\n                _iterator14.f();\n              }\n            }\n          }\n        } catch (err) {\n          _iterator11.e(err);\n        } finally {\n          _iterator11.f();\n        }\n\n        outdatedChunkGroupInfo.clear();\n        logger.timeEnd(\"merging available modules\");\n      }\n    } // Run queueDelayed when all items of the queue are processed\n    // This is important to get the global indicing correct\n    // Async blocks should be processed after all sync blocks are processed\n\n\n    if (queue.length === 0) {\n      var tempQueue = queue;\n      queue = queueDelayed.reverse();\n      queueDelayed = tempQueue;\n    }\n  }\n};\n/**\n *\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n */\n\n\nvar connectChunkGroups = function connectChunkGroups(blocksWithNestedBlocks, blockConnections, chunkGroupInfoMap) {\n  /**\n   * Helper function to check if all modules of a chunk are available\n   *\n   * @param {ChunkGroup} chunkGroup the chunkGroup to scan\n   * @param {Set<Module>} availableModules the comparitor set\n   * @returns {boolean} return true if all modules of a chunk are available\n   */\n  var areModulesAvailable = function areModulesAvailable(chunkGroup, availableModules) {\n    var _iterator21 = _createForOfIteratorHelper(chunkGroup.chunks),\n        _step21;\n\n    try {\n      for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n        var chunk = _step21.value;\n\n        var _iterator22 = _createForOfIteratorHelper(chunk.modulesIterable),\n            _step22;\n\n        try {\n          for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n            var _module5 = _step22.value;\n            if (!availableModules.has(_module5)) return false;\n          }\n        } catch (err) {\n          _iterator22.e(err);\n        } finally {\n          _iterator22.f();\n        }\n      }\n    } catch (err) {\n      _iterator21.e(err);\n    } finally {\n      _iterator21.f();\n    }\n\n    return true;\n  }; // For each edge in the basic chunk graph\n\n\n  var _iterator23 = _createForOfIteratorHelper(blockConnections),\n      _step23;\n\n  try {\n    for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n      var _ref6 = _step23.value;\n\n      var _ref5 = _slicedToArray(_ref6, 2);\n\n      var block = _ref5[0];\n      var connections = _ref5[1];\n\n      // 1. Check if connection is needed\n      // When none of the dependencies need to be connected\n      // we can skip all of them\n      // It's not possible to filter each item so it doesn't create inconsistent\n      // connections and modules can only create one version\n      // TODO maybe decide this per runtime\n      if ( // TODO is this needed?\n      !blocksWithNestedBlocks.has(block) && connections.every(function (_ref7) {\n        var chunkGroup = _ref7.chunkGroup,\n            originChunkGroupInfo = _ref7.originChunkGroupInfo;\n        return areModulesAvailable(chunkGroup, originChunkGroupInfo.resultingAvailableModules);\n      })) {\n        continue;\n      } // 2. Foreach edge\n\n\n      for (var i = 0; i < connections.length; i++) {\n        var _connections$i = connections[i],\n            chunkGroup = _connections$i.chunkGroup,\n            originChunkGroupInfo = _connections$i.originChunkGroupInfo; // 3. Connect block with chunk\n\n        GraphHelpers.connectDependenciesBlockAndChunkGroup(block, chunkGroup); // 4. Connect chunk with parent\n\n        GraphHelpers.connectChunkGroupParentAndChild(originChunkGroupInfo.chunkGroup, chunkGroup);\n      }\n    }\n  } catch (err) {\n    _iterator23.e(err);\n  } finally {\n    _iterator23.f();\n  }\n};\n/**\n * Remove all unconnected chunk groups\n * @param {Compilation} compilation the compilation\n * @param {Iterable<ChunkGroup>} allCreatedChunkGroups all chunk groups that where created before\n */\n\n\nvar cleanupUnconnectedGroups = function cleanupUnconnectedGroups(compilation, allCreatedChunkGroups) {\n  var _iterator24 = _createForOfIteratorHelper(allCreatedChunkGroups),\n      _step24;\n\n  try {\n    for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n      var chunkGroup = _step24.value;\n\n      if (chunkGroup.getNumberOfParents() === 0) {\n        var _iterator25 = _createForOfIteratorHelper(chunkGroup.chunks),\n            _step25;\n\n        try {\n          for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n            var chunk = _step25.value;\n            var idx = compilation.chunks.indexOf(chunk);\n            if (idx >= 0) compilation.chunks.splice(idx, 1);\n            chunk.remove(\"unconnected\");\n          }\n        } catch (err) {\n          _iterator25.e(err);\n        } finally {\n          _iterator25.f();\n        }\n\n        chunkGroup.remove(\"unconnected\");\n      }\n    }\n  } catch (err) {\n    _iterator24.e(err);\n  } finally {\n    _iterator24.f();\n  }\n};\n/**\n * This method creates the Chunk graph from the Module graph\n * @param {Compilation} compilation the compilation\n * @param {Entrypoint[]} inputChunkGroups chunk groups which are processed\n * @returns {void}\n */\n\n\nvar buildChunkGraph = function buildChunkGraph(compilation, inputChunkGroups) {\n  // SHARED STATE\n\n  /** @type {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} */\n  var blockConnections = new Map();\n  /** @type {Set<ChunkGroup>} */\n\n  var allCreatedChunkGroups = new Set();\n  /** @type {Map<ChunkGroup, ChunkGroupInfo>} */\n\n  var chunkGroupInfoMap = new Map();\n  /** @type {Set<DependenciesBlock>} */\n\n  var blocksWithNestedBlocks = new Set(); // PART ONE\n\n  visitModules(compilation, inputChunkGroups, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups); // PART TWO\n\n  connectChunkGroups(blocksWithNestedBlocks, blockConnections, chunkGroupInfoMap); // Cleaup work\n\n  cleanupUnconnectedGroups(compilation, allCreatedChunkGroups);\n};\n\nmodule.exports = buildChunkGraph;","map":null,"metadata":{},"sourceType":"module"}