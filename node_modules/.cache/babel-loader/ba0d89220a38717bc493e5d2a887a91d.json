{"ast":null,"code":"'use strict';\n\nvar Node = require('snapdragon-node');\n\nvar utils = require('./utils');\n/**\n * Braces parsers\n */\n\n\nmodule.exports = function (braces, options) {\n  braces.parser.set('bos', function () {\n    if (!this.parsed) {\n      this.ast = this.nodes[0] = new Node(this.ast);\n    }\n  })\n  /**\n   * Character parsers\n   */\n  .set('escape', function () {\n    var pos = this.position();\n    var m = this.match(/^(?:\\\\(.)|\\$\\{)/);\n    if (!m) return;\n    var prev = this.prev();\n    var last = utils.last(prev.nodes);\n    var node = pos(new Node({\n      type: 'text',\n      multiplier: 1,\n      val: m[0]\n    }));\n\n    if (node.val === '\\\\\\\\') {\n      return node;\n    }\n\n    if (node.val === '${') {\n      var str = this.input;\n      var idx = -1;\n      var ch;\n\n      while (ch = str[++idx]) {\n        this.consume(1);\n        node.val += ch;\n\n        if (ch === '\\\\') {\n          node.val += str[++idx];\n          continue;\n        }\n\n        if (ch === '}') {\n          break;\n        }\n      }\n    }\n\n    if (this.options.unescape !== false) {\n      node.val = node.val.replace(/\\\\([{}])/g, '$1');\n    }\n\n    if (last.val === '\"' && this.input.charAt(0) === '\"') {\n      last.val = node.val;\n      this.consume(1);\n      return;\n    }\n\n    return concatNodes.call(this, pos, node, prev, options);\n  })\n  /**\n   * Brackets: \"[...]\" (basic, this is overridden by\n   * other parsers in more advanced implementations)\n   */\n  .set('bracket', function () {\n    var isInside = this.isInside('brace');\n    var pos = this.position();\n    var m = this.match(/^(?:\\[([!^]?)([^\\]]{2,}|\\]-)(\\]|[^*+?]+)|\\[)/);\n    if (!m) return;\n    var prev = this.prev();\n    var val = m[0];\n    var negated = m[1] ? '^' : '';\n    var inner = m[2] || '';\n    var close = m[3] || '';\n\n    if (isInside && prev.type === 'brace') {\n      prev.text = prev.text || '';\n      prev.text += val;\n    }\n\n    var esc = this.input.slice(0, 2);\n\n    if (inner === '' && esc === '\\\\]') {\n      inner += esc;\n      this.consume(2);\n      var str = this.input;\n      var idx = -1;\n      var ch;\n\n      while (ch = str[++idx]) {\n        this.consume(1);\n\n        if (ch === ']') {\n          close = ch;\n          break;\n        }\n\n        inner += ch;\n      }\n    }\n\n    return pos(new Node({\n      type: 'bracket',\n      val: val,\n      escaped: close !== ']',\n      negated: negated,\n      inner: inner,\n      close: close\n    }));\n  })\n  /**\n   * Empty braces (we capture these early to\n   * speed up processing in the compiler)\n   */\n  .set('multiplier', function () {\n    var isInside = this.isInside('brace');\n    var pos = this.position();\n    var m = this.match(/^\\{((?:,|\\{,+\\})+)\\}/);\n    if (!m) return;\n    this.multiplier = true;\n    var prev = this.prev();\n    var val = m[0];\n\n    if (isInside && prev.type === 'brace') {\n      prev.text = prev.text || '';\n      prev.text += val;\n    }\n\n    var node = pos(new Node({\n      type: 'text',\n      multiplier: 1,\n      match: m,\n      val: val\n    }));\n    return concatNodes.call(this, pos, node, prev, options);\n  })\n  /**\n   * Open\n   */\n  .set('brace.open', function () {\n    var pos = this.position();\n    var m = this.match(/^\\{(?!(?:[^\\\\}]?|,+)\\})/);\n    if (!m) return;\n    var prev = this.prev();\n    var last = utils.last(prev.nodes); // if the last parsed character was an extglob character\n    // we need to _not optimize_ the brace pattern because\n    // it might be mistaken for an extglob by a downstream parser\n\n    if (last && last.val && isExtglobChar(last.val.slice(-1))) {\n      last.optimize = false;\n    }\n\n    var open = pos(new Node({\n      type: 'brace.open',\n      val: m[0]\n    }));\n    var node = pos(new Node({\n      type: 'brace',\n      nodes: []\n    }));\n    node.push(open);\n    prev.push(node);\n    this.push('brace', node);\n  })\n  /**\n   * Close\n   */\n  .set('brace.close', function () {\n    var pos = this.position();\n    var m = this.match(/^\\}/);\n    if (!m || !m[0]) return;\n    var brace = this.pop('brace');\n    var node = pos(new Node({\n      type: 'brace.close',\n      val: m[0]\n    }));\n\n    if (!this.isType(brace, 'brace')) {\n      if (this.options.strict) {\n        throw new Error('missing opening \"{\"');\n      }\n\n      node.type = 'text';\n      node.multiplier = 0;\n      node.escaped = true;\n      return node;\n    }\n\n    var prev = this.prev();\n    var last = utils.last(prev.nodes);\n\n    if (last.text) {\n      var lastNode = utils.last(last.nodes);\n\n      if (lastNode.val === ')' && /[!@*?+]\\(/.test(last.text)) {\n        var open = last.nodes[0];\n        var text = last.nodes[1];\n\n        if (open.type === 'brace.open' && text && text.type === 'text') {\n          text.optimize = false;\n        }\n      }\n    }\n\n    if (brace.nodes.length > 2) {\n      var first = brace.nodes[1];\n\n      if (first.type === 'text' && first.val === ',') {\n        brace.nodes.splice(1, 1);\n        brace.nodes.push(first);\n      }\n    }\n\n    brace.push(node);\n  })\n  /**\n   * Capture boundary characters\n   */\n  .set('boundary', function () {\n    var pos = this.position();\n    var m = this.match(/^[$^](?!\\{)/);\n    if (!m) return;\n    return pos(new Node({\n      type: 'text',\n      val: m[0]\n    }));\n  })\n  /**\n   * One or zero, non-comma characters wrapped in braces\n   */\n  .set('nobrace', function () {\n    var isInside = this.isInside('brace');\n    var pos = this.position();\n    var m = this.match(/^\\{[^,]?\\}/);\n    if (!m) return;\n    var prev = this.prev();\n    var val = m[0];\n\n    if (isInside && prev.type === 'brace') {\n      prev.text = prev.text || '';\n      prev.text += val;\n    }\n\n    return pos(new Node({\n      type: 'text',\n      multiplier: 0,\n      val: val\n    }));\n  })\n  /**\n   * Text\n   */\n  .set('text', function () {\n    var isInside = this.isInside('brace');\n    var pos = this.position();\n    var m = this.match(/^((?!\\\\)[^${}[\\]])+/);\n    if (!m) return;\n    var prev = this.prev();\n    var val = m[0];\n\n    if (isInside && prev.type === 'brace') {\n      prev.text = prev.text || '';\n      prev.text += val;\n    }\n\n    var node = pos(new Node({\n      type: 'text',\n      multiplier: 1,\n      val: val\n    }));\n    return concatNodes.call(this, pos, node, prev, options);\n  });\n};\n/**\n * Returns true if the character is an extglob character.\n */\n\n\nfunction isExtglobChar(ch) {\n  return ch === '!' || ch === '@' || ch === '*' || ch === '?' || ch === '+';\n}\n/**\n * Combine text nodes, and calculate empty sets (`{,,}`)\n * @param {Function} `pos` Function to calculate node position\n * @param {Object} `node` AST node\n * @return {Object}\n */\n\n\nfunction concatNodes(pos, node, parent, options) {\n  node.orig = node.val;\n  var prev = this.prev();\n  var last = utils.last(prev.nodes);\n  var isEscaped = false;\n\n  if (node.val.length > 1) {\n    var a = node.val.charAt(0);\n    var b = node.val.slice(-1);\n    isEscaped = a === '\"' && b === '\"' || a === \"'\" && b === \"'\" || a === '`' && b === '`';\n  }\n\n  if (isEscaped && options.unescape !== false) {\n    node.val = node.val.slice(1, node.val.length - 1);\n    node.escaped = true;\n  }\n\n  if (node.match) {\n    var match = node.match[1];\n\n    if (!match || match.indexOf('}') === -1) {\n      match = node.match[0];\n    } // replace each set with a single \",\"\n\n\n    var val = match.replace(/\\{/g, ',').replace(/\\}/g, '');\n    node.multiplier *= val.length;\n    node.val = '';\n  }\n\n  var simpleText = last.type === 'text' && last.multiplier === 1 && node.multiplier === 1 && node.val;\n\n  if (simpleText) {\n    last.val += node.val;\n    return;\n  }\n\n  prev.push(node);\n}","map":null,"metadata":{},"sourceType":"module"}