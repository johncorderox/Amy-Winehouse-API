{"ast":null,"code":"import Long from \"@xtuc/long\";\nimport parseHexFloat from \"@webassemblyjs/floating-point-hex-parser\";\nimport { CompileError } from \"@webassemblyjs/helper-api-error\";\nexport function parse32F(sourceString) {\n  if (isHexLiteral(sourceString)) {\n    return parseHexFloat(sourceString);\n  }\n\n  if (isInfLiteral(sourceString)) {\n    return sourceString[0] === \"-\" ? -1 : 1;\n  }\n\n  if (isNanLiteral(sourceString)) {\n    return (sourceString[0] === \"-\" ? -1 : 1) * (sourceString.includes(\":\") ? parseInt(sourceString.substring(sourceString.indexOf(\":\") + 1), 16) : 0x400000);\n  }\n\n  return parseFloat(sourceString);\n}\nexport function parse64F(sourceString) {\n  if (isHexLiteral(sourceString)) {\n    return parseHexFloat(sourceString);\n  }\n\n  if (isInfLiteral(sourceString)) {\n    return sourceString[0] === \"-\" ? -1 : 1;\n  }\n\n  if (isNanLiteral(sourceString)) {\n    return (sourceString[0] === \"-\" ? -1 : 1) * (sourceString.includes(\":\") ? parseInt(sourceString.substring(sourceString.indexOf(\":\") + 1), 16) : 0x8000000000000);\n  }\n\n  if (isHexLiteral(sourceString)) {\n    return parseHexFloat(sourceString);\n  }\n\n  return parseFloat(sourceString);\n}\nexport function parse32I(sourceString) {\n  var value = 0;\n\n  if (isHexLiteral(sourceString)) {\n    value = ~~parseInt(sourceString, 16);\n  } else if (isDecimalExponentLiteral(sourceString)) {\n    throw new Error(\"This number literal format is yet to be implemented.\");\n  } else {\n    value = parseInt(sourceString, 10);\n  }\n\n  return value;\n}\nexport function parseU32(sourceString) {\n  var value = parse32I(sourceString);\n\n  if (value < 0) {\n    throw new CompileError(\"Illegal value for u32: \" + sourceString);\n  }\n\n  return value;\n}\nexport function parse64I(sourceString) {\n  var _long;\n\n  if (isHexLiteral(sourceString)) {\n    _long = Long.fromString(sourceString, false, 16);\n  } else if (isDecimalExponentLiteral(sourceString)) {\n    throw new Error(\"This number literal format is yet to be implemented.\");\n  } else {\n    _long = Long.fromString(sourceString);\n  }\n\n  return {\n    high: _long.high,\n    low: _long.low\n  };\n}\nvar NAN_WORD = /^\\+?-?nan/;\nvar INF_WORD = /^\\+?-?inf/;\nexport function isInfLiteral(sourceString) {\n  return INF_WORD.test(sourceString.toLowerCase());\n}\nexport function isNanLiteral(sourceString) {\n  return NAN_WORD.test(sourceString.toLowerCase());\n}\n\nfunction isDecimalExponentLiteral(sourceString) {\n  return !isHexLiteral(sourceString) && sourceString.toUpperCase().includes(\"E\");\n}\n\nfunction isHexLiteral(sourceString) {\n  return sourceString.substring(0, 2).toUpperCase() === \"0X\" || sourceString.substring(0, 3).toUpperCase() === \"-0X\";\n}","map":null,"metadata":{},"sourceType":"module"}