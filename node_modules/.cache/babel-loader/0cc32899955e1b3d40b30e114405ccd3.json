{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Source = require(\"./Source\");\n\nvar SourceNode = require(\"source-map\").SourceNode;\n\nvar Replacement = function Replacement(start, end, content, insertIndex, name) {\n  _classCallCheck(this, Replacement);\n\n  this.start = start;\n  this.end = end;\n  this.content = content;\n  this.insertIndex = insertIndex;\n  this.name = name;\n};\n\nvar ReplaceSource = /*#__PURE__*/function (_Source) {\n  _inherits(ReplaceSource, _Source);\n\n  var _super = _createSuper(ReplaceSource);\n\n  function ReplaceSource(source, name) {\n    var _this;\n\n    _classCallCheck(this, ReplaceSource);\n\n    _this = _super.call(this);\n    _this._source = source;\n    _this._name = name;\n    /** @type {Replacement[]} */\n\n    _this.replacements = [];\n    return _this;\n  }\n\n  _createClass(ReplaceSource, [{\n    key: \"replace\",\n    value: function replace(start, end, newValue, name) {\n      if (typeof newValue !== \"string\") throw new Error(\"insertion must be a string, but is a \" + _typeof(newValue));\n      this.replacements.push(new Replacement(start, end, newValue, this.replacements.length, name));\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(pos, newValue, name) {\n      if (typeof newValue !== \"string\") throw new Error(\"insertion must be a string, but is a \" + _typeof(newValue) + \": \" + newValue);\n      this.replacements.push(new Replacement(pos, pos - 1, newValue, this.replacements.length, name));\n    }\n  }, {\n    key: \"source\",\n    value: function source(options) {\n      return this._replaceString(this._source.source());\n    }\n  }, {\n    key: \"original\",\n    value: function original() {\n      return this._source;\n    }\n  }, {\n    key: \"_sortReplacements\",\n    value: function _sortReplacements() {\n      this.replacements.sort(function (a, b) {\n        var diff = b.end - a.end;\n        if (diff !== 0) return diff;\n        diff = b.start - a.start;\n        if (diff !== 0) return diff;\n        return b.insertIndex - a.insertIndex;\n      });\n    }\n  }, {\n    key: \"_replaceString\",\n    value: function _replaceString(str) {\n      if (typeof str !== \"string\") throw new Error(\"str must be a string, but is a \" + _typeof(str) + \": \" + str);\n\n      this._sortReplacements();\n\n      var result = [str];\n      this.replacements.forEach(function (repl) {\n        var remSource = result.pop();\n\n        var splitted1 = this._splitString(remSource, Math.floor(repl.end + 1));\n\n        var splitted2 = this._splitString(splitted1[0], Math.floor(repl.start));\n\n        result.push(splitted1[1], repl.content, splitted2[0]);\n      }, this); // write out result array in reverse order\n\n      var resultStr = \"\";\n\n      for (var i = result.length - 1; i >= 0; --i) {\n        resultStr += result[i];\n      }\n\n      return resultStr;\n    }\n  }, {\n    key: \"node\",\n    value: function node(options) {\n      var node = this._source.node(options);\n\n      if (this.replacements.length === 0) {\n        return node;\n      }\n\n      this._sortReplacements();\n\n      var replace = new ReplacementEnumerator(this.replacements);\n      var output = [];\n      var position = 0;\n      var sources = Object.create(null);\n      var sourcesInLines = Object.create(null); // We build a new list of SourceNodes in \"output\"\n      // from the original mapping data\n\n      var result = new SourceNode(); // We need to add source contents manually\n      // because \"walk\" will not handle it\n\n      node.walkSourceContents(function (sourceFile, sourceContent) {\n        result.setSourceContent(sourceFile, sourceContent);\n        sources[\"$\" + sourceFile] = sourceContent;\n      });\n\n      var replaceInStringNode = this._replaceInStringNode.bind(this, output, replace, function getOriginalSource(mapping) {\n        var key = \"$\" + mapping.source;\n        var lines = sourcesInLines[key];\n\n        if (!lines) {\n          var source = sources[key];\n          if (!source) return null;\n          lines = source.split(\"\\n\").map(function (line) {\n            return line + \"\\n\";\n          });\n          sourcesInLines[key] = lines;\n        } // line is 1-based\n\n\n        if (mapping.line > lines.length) return null;\n        var line = lines[mapping.line - 1];\n        return line.substr(mapping.column);\n      });\n\n      node.walk(function (chunk, mapping) {\n        position = replaceInStringNode(chunk, position, mapping);\n      }); // If any replacements occur after the end of the original file, then we append them\n      // directly to the end of the output\n\n      var remaining = replace.footer();\n\n      if (remaining) {\n        output.push(remaining);\n      }\n\n      result.add(output);\n      return result;\n    }\n  }, {\n    key: \"listMap\",\n    value: function listMap(options) {\n      this._sortReplacements();\n\n      var map = this._source.listMap(options);\n\n      var currentIndex = 0;\n      var replacements = this.replacements;\n      var idxReplacement = replacements.length - 1;\n      var removeChars = 0;\n      map = map.mapGeneratedCode(function (str) {\n        var newCurrentIndex = currentIndex + str.length;\n\n        if (removeChars > str.length) {\n          removeChars -= str.length;\n          str = \"\";\n        } else {\n          if (removeChars > 0) {\n            str = str.substr(removeChars);\n            currentIndex += removeChars;\n            removeChars = 0;\n          }\n\n          var finalStr = \"\";\n\n          while (idxReplacement >= 0 && replacements[idxReplacement].start < newCurrentIndex) {\n            var repl = replacements[idxReplacement];\n            var start = Math.floor(repl.start);\n            var end = Math.floor(repl.end + 1);\n            var before = str.substr(0, Math.max(0, start - currentIndex));\n\n            if (end <= newCurrentIndex) {\n              var after = str.substr(Math.max(0, end - currentIndex));\n              finalStr += before + repl.content;\n              str = after;\n              currentIndex = Math.max(currentIndex, end);\n            } else {\n              finalStr += before + repl.content;\n              str = \"\";\n              removeChars = end - newCurrentIndex;\n            }\n\n            idxReplacement--;\n          }\n\n          str = finalStr + str;\n        }\n\n        currentIndex = newCurrentIndex;\n        return str;\n      });\n      var extraCode = \"\";\n\n      while (idxReplacement >= 0) {\n        extraCode += replacements[idxReplacement].content;\n        idxReplacement--;\n      }\n\n      if (extraCode) {\n        map.add(extraCode);\n      }\n\n      return map;\n    }\n  }, {\n    key: \"_splitString\",\n    value: function _splitString(str, position) {\n      return position <= 0 ? [\"\", str] : [str.substr(0, position), str.substr(position)];\n    }\n  }, {\n    key: \"_replaceInStringNode\",\n    value: function _replaceInStringNode(output, replace, getOriginalSource, node, position, mapping) {\n      var original = undefined;\n\n      do {\n        var splitPosition = replace.position - position; // If multiple replaces occur in the same location then the splitPosition may be\n        // before the current position for the subsequent splits. Ensure it is >= 0\n\n        if (splitPosition < 0) {\n          splitPosition = 0;\n        }\n\n        if (splitPosition >= node.length || replace.done) {\n          if (replace.emit) {\n            var nodeEnd = new SourceNode(mapping.line, mapping.column, mapping.source, node, mapping.name);\n            output.push(nodeEnd);\n          }\n\n          return position + node.length;\n        }\n\n        var originalColumn = mapping.column; // Try to figure out if generated code matches original code of this segement\n        // If this is the case we assume that it's allowed to move mapping.column\n        // Because getOriginalSource can be expensive we only do it when neccessary\n\n        var nodePart;\n\n        if (splitPosition > 0) {\n          nodePart = node.slice(0, splitPosition);\n\n          if (original === undefined) {\n            original = getOriginalSource(mapping);\n          }\n\n          if (original && original.length >= splitPosition && original.startsWith(nodePart)) {\n            mapping.column += splitPosition;\n            original = original.substr(splitPosition);\n          }\n        }\n\n        var emit = replace.next();\n\n        if (!emit) {\n          // Stop emitting when we have found the beginning of the string to replace.\n          // Emit the part of the string before splitPosition\n          if (splitPosition > 0) {\n            var nodeStart = new SourceNode(mapping.line, originalColumn, mapping.source, nodePart, mapping.name);\n            output.push(nodeStart);\n          } // Emit the replacement value\n\n\n          if (replace.value) {\n            output.push(new SourceNode(mapping.line, mapping.column, mapping.source, replace.value, mapping.name || replace.name));\n          }\n        } // Recurse with remainder of the string as there may be multiple replaces within a single node\n\n\n        node = node.substr(splitPosition);\n        position += splitPosition;\n      } while (true);\n    }\n  }]);\n\n  return ReplaceSource;\n}(Source);\n\nvar ReplacementEnumerator = /*#__PURE__*/function () {\n  /**\n   * @param {Replacement[]} replacements list of replacements\n   */\n  function ReplacementEnumerator(replacements) {\n    _classCallCheck(this, ReplacementEnumerator);\n\n    this.replacements = replacements || [];\n    this.index = this.replacements.length;\n    this.done = false;\n    this.emit = false; // Set initial start position\n\n    this.next();\n  }\n\n  _createClass(ReplacementEnumerator, [{\n    key: \"next\",\n    value: function next() {\n      if (this.done) return true;\n\n      if (this.emit) {\n        // Start point found. stop emitting. set position to find end\n        var repl = this.replacements[this.index];\n        var end = Math.floor(repl.end + 1);\n        this.position = end;\n        this.value = repl.content;\n        this.name = repl.name;\n      } else {\n        // End point found. start emitting. set position to find next start\n        this.index--;\n\n        if (this.index < 0) {\n          this.done = true;\n        } else {\n          var nextRepl = this.replacements[this.index];\n          var start = Math.floor(nextRepl.start);\n          this.position = start;\n        }\n      }\n\n      if (this.position < 0) this.position = 0;\n      this.emit = !this.emit;\n      return this.emit;\n    }\n  }, {\n    key: \"footer\",\n    value: function footer() {\n      if (!this.done && !this.emit) this.next(); // If we finished _replaceInNode mid emit we advance to next entry\n\n      if (this.done) {\n        return [];\n      } else {\n        var resultStr = \"\";\n\n        for (var i = this.index; i >= 0; i--) {\n          var repl = this.replacements[i]; // this doesn't need to handle repl.name, because in SourceMaps generated code\n          // without pointer to original source can't have a name\n\n          resultStr += repl.content;\n        }\n\n        return resultStr;\n      }\n    }\n  }]);\n\n  return ReplacementEnumerator;\n}();\n\nrequire(\"./SourceAndMapMixin\")(ReplaceSource.prototype);\n\nmodule.exports = ReplaceSource;","map":null,"metadata":{},"sourceType":"module"}