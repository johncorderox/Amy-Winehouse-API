{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n// Copyright 2014 Simon Lydell\n// X11 (“MIT”) Licensed. (See LICENSE.)\nvoid function (root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define(factory);\n  } else if ((typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === \"object\") {\n    module.exports = factory();\n  } else {\n    root.sourceMappingURL = factory();\n  }\n}(this, function () {\n  var innerRegex = /[#@] sourceMappingURL=([^\\s'\"]*)/;\n  var regex = RegExp(\"(?:\" + \"/\\\\*\" + \"(?:\\\\s*\\r?\\n(?://)?)?\" + \"(?:\" + innerRegex.source + \")\" + \"\\\\s*\" + \"\\\\*/\" + \"|\" + \"//(?:\" + innerRegex.source + \")\" + \")\" + \"\\\\s*\");\n  return {\n    regex: regex,\n    _innerRegex: innerRegex,\n    getFrom: function getFrom(code) {\n      var match = code.match(regex);\n      return match ? match[1] || match[2] || \"\" : null;\n    },\n    existsIn: function existsIn(code) {\n      return regex.test(code);\n    },\n    removeFrom: function removeFrom(code) {\n      return code.replace(regex, \"\");\n    },\n    insertBefore: function insertBefore(code, string) {\n      var match = code.match(regex);\n\n      if (match) {\n        return code.slice(0, match.index) + string + code.slice(match.index);\n      } else {\n        return code + string;\n      }\n    }\n  };\n});","map":null,"metadata":{},"sourceType":"module"}