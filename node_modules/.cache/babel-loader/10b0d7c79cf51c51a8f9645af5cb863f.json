{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Gajus Kuizinas @gajus\n*/\n\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar WebpackError = require(\"./WebpackError\");\n\nvar webpackOptionsSchema = require(\"../schemas/WebpackOptions.json\");\n\nvar getSchemaPart = function getSchemaPart(path, parents, additionalPath) {\n  parents = parents || 0;\n  path = path.split(\"/\");\n  path = path.slice(0, path.length - parents);\n\n  if (additionalPath) {\n    additionalPath = additionalPath.split(\"/\");\n    path = path.concat(additionalPath);\n  }\n\n  var schemaPart = webpackOptionsSchema;\n\n  for (var i = 1; i < path.length; i++) {\n    var inner = schemaPart[path[i]];\n    if (inner) schemaPart = inner;\n  }\n\n  return schemaPart;\n};\n\nvar getSchemaPartText = function getSchemaPartText(schemaPart, additionalPath) {\n  if (additionalPath) {\n    for (var i = 0; i < additionalPath.length; i++) {\n      var inner = schemaPart[additionalPath[i]];\n      if (inner) schemaPart = inner;\n    }\n  }\n\n  while (schemaPart.$ref) {\n    schemaPart = getSchemaPart(schemaPart.$ref);\n  }\n\n  var schemaText = WebpackOptionsValidationError.formatSchema(schemaPart);\n\n  if (schemaPart.description) {\n    schemaText += \"\\n-> \".concat(schemaPart.description);\n  }\n\n  return schemaText;\n};\n\nvar getSchemaPartDescription = function getSchemaPartDescription(schemaPart) {\n  while (schemaPart.$ref) {\n    schemaPart = getSchemaPart(schemaPart.$ref);\n  }\n\n  if (schemaPart.description) {\n    return \"\\n-> \".concat(schemaPart.description);\n  }\n\n  return \"\";\n};\n\nvar SPECIFICITY = {\n  type: 1,\n  oneOf: 1,\n  anyOf: 1,\n  allOf: 1,\n  additionalProperties: 2,\n  \"enum\": 1,\n  \"instanceof\": 1,\n  required: 2,\n  minimum: 2,\n  uniqueItems: 2,\n  minLength: 2,\n  minItems: 2,\n  minProperties: 2,\n  absolutePath: 2\n};\n\nvar filterMax = function filterMax(array, fn) {\n  var max = array.reduce(function (max, item) {\n    return Math.max(max, fn(item));\n  }, 0);\n  return array.filter(function (item) {\n    return fn(item) === max;\n  });\n};\n\nvar filterChildren = function filterChildren(children) {\n  children = filterMax(children, function (err) {\n    return err.dataPath ? err.dataPath.length : 0;\n  });\n  children = filterMax(children, function (err) {\n    return SPECIFICITY[err.keyword] || 2;\n  });\n  return children;\n};\n\nvar indent = function indent(str, prefix, firstLine) {\n  if (firstLine) {\n    return prefix + str.replace(/\\n(?!$)/g, \"\\n\" + prefix);\n  } else {\n    return str.replace(/\\n(?!$)/g, \"\\n\".concat(prefix));\n  }\n};\n\nvar WebpackOptionsValidationError = /*#__PURE__*/function (_WebpackError) {\n  _inherits(WebpackOptionsValidationError, _WebpackError);\n\n  var _super = _createSuper(WebpackOptionsValidationError);\n\n  function WebpackOptionsValidationError(validationErrors) {\n    var _this;\n\n    _classCallCheck(this, WebpackOptionsValidationError);\n\n    _this = _super.call(this, \"Invalid configuration object. \" + \"Webpack has been initialised using a configuration object that does not match the API schema.\\n\" + validationErrors.map(function (err) {\n      return \" - \" + indent(WebpackOptionsValidationError.formatValidationError(err), \"   \", false);\n    }).join(\"\\n\"));\n    _this.name = \"WebpackOptionsValidationError\";\n    _this.validationErrors = validationErrors;\n    Error.captureStackTrace(_assertThisInitialized(_this), _this.constructor);\n    return _this;\n  }\n\n  _createClass(WebpackOptionsValidationError, null, [{\n    key: \"formatSchema\",\n    value: function formatSchema(schema, prevSchemas) {\n      prevSchemas = prevSchemas || [];\n\n      var formatInnerSchema = function formatInnerSchema(innerSchema, addSelf) {\n        if (!addSelf) {\n          return WebpackOptionsValidationError.formatSchema(innerSchema, prevSchemas);\n        }\n\n        if (prevSchemas.includes(innerSchema)) {\n          return \"(recursive)\";\n        }\n\n        return WebpackOptionsValidationError.formatSchema(innerSchema, prevSchemas.concat(schema));\n      };\n\n      if (schema.type === \"string\") {\n        if (schema.minLength === 1) {\n          return \"non-empty string\";\n        }\n\n        if (schema.minLength > 1) {\n          return \"string (min length \".concat(schema.minLength, \")\");\n        }\n\n        return \"string\";\n      }\n\n      if (schema.type === \"boolean\") {\n        return \"boolean\";\n      }\n\n      if (schema.type === \"number\") {\n        return \"number\";\n      }\n\n      if (schema.type === \"object\") {\n        if (schema.properties) {\n          var required = schema.required || [];\n          return \"object { \".concat(Object.keys(schema.properties).map(function (property) {\n            if (!required.includes(property)) return property + \"?\";\n            return property;\n          }).concat(schema.additionalProperties ? [\"â€¦\"] : []).join(\", \"), \" }\");\n        }\n\n        if (schema.additionalProperties) {\n          return \"object { <key>: \".concat(formatInnerSchema(schema.additionalProperties), \" }\");\n        }\n\n        return \"object\";\n      }\n\n      if (schema.type === \"array\") {\n        return \"[\".concat(formatInnerSchema(schema.items), \"]\");\n      }\n\n      switch (schema[\"instanceof\"]) {\n        case \"Function\":\n          return \"function\";\n\n        case \"RegExp\":\n          return \"RegExp\";\n      }\n\n      if (schema[\"enum\"]) {\n        return schema[\"enum\"].map(function (item) {\n          return JSON.stringify(item);\n        }).join(\" | \");\n      }\n\n      if (schema.$ref) {\n        return formatInnerSchema(getSchemaPart(schema.$ref), true);\n      }\n\n      if (schema.allOf) {\n        return schema.allOf.map(formatInnerSchema).join(\" & \");\n      }\n\n      if (schema.oneOf) {\n        return schema.oneOf.map(formatInnerSchema).join(\" | \");\n      }\n\n      if (schema.anyOf) {\n        return schema.anyOf.map(formatInnerSchema).join(\" | \");\n      }\n\n      return JSON.stringify(schema, null, 2);\n    }\n  }, {\n    key: \"formatValidationError\",\n    value: function formatValidationError(err) {\n      var dataPath = \"configuration\".concat(err.dataPath);\n\n      if (err.keyword === \"additionalProperties\") {\n        var baseMessage = \"\".concat(dataPath, \" has an unknown property '\").concat(err.params.additionalProperty, \"'. These properties are valid:\\n\").concat(getSchemaPartText(err.parentSchema));\n\n        if (!err.dataPath) {\n          switch (err.params.additionalProperty) {\n            case \"debug\":\n              return \"\".concat(baseMessage, \"\\n\") + \"The 'debug' property was removed in webpack 2.0.0.\\n\" + \"Loaders should be updated to allow passing this option via loader options in module.rules.\\n\" + \"Until loaders are updated one can use the LoaderOptionsPlugin to switch loaders into debug mode:\\n\" + \"plugins: [\\n\" + \"  new webpack.LoaderOptionsPlugin({\\n\" + \"    debug: true\\n\" + \"  })\\n\" + \"]\";\n          }\n\n          return \"\".concat(baseMessage, \"\\n\") + \"For typos: please correct them.\\n\" + \"For loader options: webpack >= v2.0.0 no longer allows custom properties in configuration.\\n\" + \"  Loaders should be updated to allow passing options via loader options in module.rules.\\n\" + \"  Until loaders are updated one can use the LoaderOptionsPlugin to pass these options to the loader:\\n\" + \"  plugins: [\\n\" + \"    new webpack.LoaderOptionsPlugin({\\n\" + \"      // test: /\\\\.xxx$/, // may apply this only for some modules\\n\" + \"      options: {\\n\" + \"        \".concat(err.params.additionalProperty, \": \\u2026\\n\") + \"      }\\n\" + \"    })\\n\" + \"  ]\";\n        }\n\n        return baseMessage;\n      } else if (err.keyword === \"oneOf\" || err.keyword === \"anyOf\") {\n        if (err.children && err.children.length > 0) {\n          if (err.schema.length === 1) {\n            var lastChild = err.children[err.children.length - 1];\n            var remainingChildren = err.children.slice(0, err.children.length - 1);\n            return WebpackOptionsValidationError.formatValidationError(Object.assign({}, lastChild, {\n              children: remainingChildren,\n              parentSchema: Object.assign({}, err.parentSchema, lastChild.parentSchema)\n            }));\n          }\n\n          var children = filterChildren(err.children);\n\n          if (children.length === 1) {\n            return WebpackOptionsValidationError.formatValidationError(children[0]);\n          }\n\n          return \"\".concat(dataPath, \" should be one of these:\\n\").concat(getSchemaPartText(err.parentSchema), \"\\n\") + \"Details:\\n\".concat(children.map(function (err) {\n            return \" * \" + indent(WebpackOptionsValidationError.formatValidationError(err), \"   \", false);\n          }).join(\"\\n\"));\n        }\n\n        return \"\".concat(dataPath, \" should be one of these:\\n\").concat(getSchemaPartText(err.parentSchema));\n      } else if (err.keyword === \"enum\") {\n        if (err.parentSchema && err.parentSchema[\"enum\"] && err.parentSchema[\"enum\"].length === 1) {\n          return \"\".concat(dataPath, \" should be \").concat(getSchemaPartText(err.parentSchema));\n        }\n\n        return \"\".concat(dataPath, \" should be one of these:\\n\").concat(getSchemaPartText(err.parentSchema));\n      } else if (err.keyword === \"allOf\") {\n        return \"\".concat(dataPath, \" should be:\\n\").concat(getSchemaPartText(err.parentSchema));\n      } else if (err.keyword === \"type\") {\n        switch (err.params.type) {\n          case \"object\":\n            return \"\".concat(dataPath, \" should be an object.\").concat(getSchemaPartDescription(err.parentSchema));\n\n          case \"string\":\n            return \"\".concat(dataPath, \" should be a string.\").concat(getSchemaPartDescription(err.parentSchema));\n\n          case \"boolean\":\n            return \"\".concat(dataPath, \" should be a boolean.\").concat(getSchemaPartDescription(err.parentSchema));\n\n          case \"number\":\n            return \"\".concat(dataPath, \" should be a number.\").concat(getSchemaPartDescription(err.parentSchema));\n\n          case \"array\":\n            return \"\".concat(dataPath, \" should be an array:\\n\").concat(getSchemaPartText(err.parentSchema));\n        }\n\n        return \"\".concat(dataPath, \" should be \").concat(err.params.type, \":\\n\").concat(getSchemaPartText(err.parentSchema));\n      } else if (err.keyword === \"instanceof\") {\n        return \"\".concat(dataPath, \" should be an instance of \").concat(getSchemaPartText(err.parentSchema));\n      } else if (err.keyword === \"required\") {\n        var missingProperty = err.params.missingProperty.replace(/^\\./, \"\");\n        return \"\".concat(dataPath, \" misses the property '\").concat(missingProperty, \"'.\\n\").concat(getSchemaPartText(err.parentSchema, [\"properties\", missingProperty]));\n      } else if (err.keyword === \"minimum\") {\n        return \"\".concat(dataPath, \" \").concat(err.message, \".\").concat(getSchemaPartDescription(err.parentSchema));\n      } else if (err.keyword === \"uniqueItems\") {\n        return \"\".concat(dataPath, \" should not contain the item '\").concat(err.data[err.params.i], \"' twice.\").concat(getSchemaPartDescription(err.parentSchema));\n      } else if (err.keyword === \"minLength\" || err.keyword === \"minItems\" || err.keyword === \"minProperties\") {\n        if (err.params.limit === 1) {\n          switch (err.keyword) {\n            case \"minLength\":\n              return \"\".concat(dataPath, \" should be an non-empty string.\").concat(getSchemaPartDescription(err.parentSchema));\n\n            case \"minItems\":\n              return \"\".concat(dataPath, \" should be an non-empty array.\").concat(getSchemaPartDescription(err.parentSchema));\n\n            case \"minProperties\":\n              return \"\".concat(dataPath, \" should be an non-empty object.\").concat(getSchemaPartDescription(err.parentSchema));\n          }\n\n          return \"\".concat(dataPath, \" should be not empty.\").concat(getSchemaPartDescription(err.parentSchema));\n        } else {\n          return \"\".concat(dataPath, \" \").concat(err.message).concat(getSchemaPartDescription(err.parentSchema));\n        }\n      } else if (err.keyword === \"not\") {\n        return \"\".concat(dataPath, \" should not be \").concat(getSchemaPartText(err.schema), \"\\n\").concat(getSchemaPartText(err.parentSchema));\n      } else if (err.keyword === \"absolutePath\") {\n        var _baseMessage = \"\".concat(dataPath, \": \").concat(err.message).concat(getSchemaPartDescription(err.parentSchema));\n\n        if (dataPath === \"configuration.output.filename\") {\n          return \"\".concat(_baseMessage, \"\\n\") + \"Please use output.path to specify absolute path and output.filename for the file name.\";\n        }\n\n        return _baseMessage;\n      } else {\n        return \"\".concat(dataPath, \" \").concat(err.message, \" (\").concat(JSON.stringify(err, null, 2), \").\\n\").concat(getSchemaPartText(err.parentSchema));\n      }\n    }\n  }]);\n\n  return WebpackOptionsValidationError;\n}(WebpackError);\n\nmodule.exports = WebpackOptionsValidationError;","map":null,"metadata":{},"sourceType":"module"}