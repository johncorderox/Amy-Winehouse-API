{"ast":null,"code":"'use strict';\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar pify = require('pify');\n\nvar semver = require('semver');\n\nvar defaults = {\n  mode: 511 & ~process.umask(),\n  fs: fs\n};\nvar useNativeRecursiveOption = semver.satisfies(process.version, '>=10.12.0'); // https://github.com/nodejs/node/issues/8987\n// https://github.com/libuv/libuv/pull/1088\n\nvar checkPath = function checkPath(pth) {\n  if (process.platform === 'win32') {\n    var pathHasInvalidWinCharacters = /[<>:\"|?*]/.test(pth.replace(path.parse(pth).root, ''));\n\n    if (pathHasInvalidWinCharacters) {\n      var error = new Error(\"Path contains invalid characters: \".concat(pth));\n      error.code = 'EINVAL';\n      throw error;\n    }\n  }\n};\n\nvar permissionError = function permissionError(pth) {\n  // This replicates the exception of `fs.mkdir` with native the\n  // `recusive` option when run on an invalid drive under Windows.\n  var error = new Error(\"operation not permitted, mkdir '\".concat(pth, \"'\"));\n  error.code = 'EPERM';\n  error.errno = -4048;\n  error.path = pth;\n  error.syscall = 'mkdir';\n  return error;\n};\n\nvar makeDir = function makeDir(input, options) {\n  return Promise.resolve().then(function () {\n    checkPath(input);\n    options = Object.assign({}, defaults, options); // TODO: Use util.promisify when targeting Node.js 8\n\n    var mkdir = pify(options.fs.mkdir);\n    var stat = pify(options.fs.stat);\n\n    if (useNativeRecursiveOption && options.fs.mkdir === fs.mkdir) {\n      var pth = path.resolve(input);\n      return mkdir(pth, {\n        mode: options.mode,\n        recursive: true\n      }).then(function () {\n        return pth;\n      });\n    }\n\n    var make = function make(pth) {\n      return mkdir(pth, options.mode).then(function () {\n        return pth;\n      })[\"catch\"](function (error) {\n        if (error.code === 'EPERM') {\n          throw error;\n        }\n\n        if (error.code === 'ENOENT') {\n          if (path.dirname(pth) === pth) {\n            throw permissionError(pth);\n          }\n\n          if (error.message.includes('null bytes')) {\n            throw error;\n          }\n\n          return make(path.dirname(pth)).then(function () {\n            return make(pth);\n          });\n        }\n\n        return stat(pth).then(function (stats) {\n          return stats.isDirectory() ? pth : Promise.reject();\n        })[\"catch\"](function () {\n          throw error;\n        });\n      });\n    };\n\n    return make(path.resolve(input));\n  });\n};\n\nmodule.exports = makeDir;\nmodule.exports[\"default\"] = makeDir;\n\nmodule.exports.sync = function (input, options) {\n  checkPath(input);\n  options = Object.assign({}, defaults, options);\n\n  if (useNativeRecursiveOption && options.fs.mkdirSync === fs.mkdirSync) {\n    var pth = path.resolve(input);\n    fs.mkdirSync(pth, {\n      mode: options.mode,\n      recursive: true\n    });\n    return pth;\n  }\n\n  var make = function make(pth) {\n    try {\n      options.fs.mkdirSync(pth, options.mode);\n    } catch (error) {\n      if (error.code === 'EPERM') {\n        throw error;\n      }\n\n      if (error.code === 'ENOENT') {\n        if (path.dirname(pth) === pth) {\n          throw permissionError(pth);\n        }\n\n        if (error.message.includes('null bytes')) {\n          throw error;\n        }\n\n        make(path.dirname(pth));\n        return make(pth);\n      }\n\n      try {\n        if (!options.fs.statSync(pth).isDirectory()) {\n          throw new Error('The path is not a directory');\n        }\n      } catch (_) {\n        throw error;\n      }\n    }\n\n    return pth;\n  };\n\n  return make(path.resolve(input));\n};","map":null,"metadata":{},"sourceType":"module"}