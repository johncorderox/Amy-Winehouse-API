{"ast":null,"code":"/*\n MIT License http://www.opensource.org/licenses/mit-license.php\n Author Tobias Koppers @sokra\n */\n\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar path = require(\"path\");\n\nvar asyncLib = require(\"neo-async\");\n\nvar _require = require(\"tapable\"),\n    Tapable = _require.Tapable,\n    AsyncSeriesWaterfallHook = _require.AsyncSeriesWaterfallHook,\n    SyncWaterfallHook = _require.SyncWaterfallHook,\n    SyncBailHook = _require.SyncBailHook,\n    SyncHook = _require.SyncHook,\n    HookMap = _require.HookMap;\n\nvar NormalModule = require(\"./NormalModule\");\n\nvar RawModule = require(\"./RawModule\");\n\nvar RuleSet = require(\"./RuleSet\");\n\nvar _require2 = require(\"./util/cleverMerge\"),\n    cachedCleverMerge = _require2.cachedCleverMerge;\n\nvar EMPTY_RESOLVE_OPTIONS = {};\nvar MATCH_RESOURCE_REGEX = /^([^!]+)!=!/;\n\nvar loaderToIdent = function loaderToIdent(data) {\n  if (!data.options) {\n    return data.loader;\n  }\n\n  if (typeof data.options === \"string\") {\n    return data.loader + \"?\" + data.options;\n  }\n\n  if (_typeof(data.options) !== \"object\") {\n    throw new Error(\"loader options must be string or object\");\n  }\n\n  if (data.ident) {\n    return data.loader + \"??\" + data.ident;\n  }\n\n  return data.loader + \"?\" + JSON.stringify(data.options);\n};\n\nvar identToLoaderRequest = function identToLoaderRequest(resultString) {\n  var idx = resultString.indexOf(\"?\");\n\n  if (idx >= 0) {\n    var loader = resultString.substr(0, idx);\n    var options = resultString.substr(idx + 1);\n    return {\n      loader: loader,\n      options: options\n    };\n  } else {\n    return {\n      loader: resultString,\n      options: undefined\n    };\n  }\n};\n\nvar dependencyCache = new WeakMap();\n\nvar NormalModuleFactory = /*#__PURE__*/function (_Tapable) {\n  _inherits(NormalModuleFactory, _Tapable);\n\n  var _super = _createSuper(NormalModuleFactory);\n\n  function NormalModuleFactory(context, resolverFactory, options) {\n    var _this;\n\n    _classCallCheck(this, NormalModuleFactory);\n\n    _this = _super.call(this);\n    _this.hooks = {\n      resolver: new SyncWaterfallHook([\"resolver\"]),\n      factory: new SyncWaterfallHook([\"factory\"]),\n      beforeResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n      afterResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n      createModule: new SyncBailHook([\"data\"]),\n      module: new SyncWaterfallHook([\"module\", \"data\"]),\n      createParser: new HookMap(function () {\n        return new SyncBailHook([\"parserOptions\"]);\n      }),\n      parser: new HookMap(function () {\n        return new SyncHook([\"parser\", \"parserOptions\"]);\n      }),\n      createGenerator: new HookMap(function () {\n        return new SyncBailHook([\"generatorOptions\"]);\n      }),\n      generator: new HookMap(function () {\n        return new SyncHook([\"generator\", \"generatorOptions\"]);\n      })\n    };\n\n    _this._pluginCompat.tap(\"NormalModuleFactory\", function (options) {\n      switch (options.name) {\n        case \"before-resolve\":\n        case \"after-resolve\":\n          options.async = true;\n          break;\n\n        case \"parser\":\n          _this.hooks.parser[\"for\"](\"javascript/auto\").tap(options.fn.name || \"unnamed compat plugin\", options.fn);\n\n          return true;\n      }\n\n      var match;\n      match = /^parser (.+)$/.exec(options.name);\n\n      if (match) {\n        _this.hooks.parser[\"for\"](match[1]).tap(options.fn.name || \"unnamed compat plugin\", options.fn.bind(_assertThisInitialized(_this)));\n\n        return true;\n      }\n\n      match = /^create-parser (.+)$/.exec(options.name);\n\n      if (match) {\n        _this.hooks.createParser[\"for\"](match[1]).tap(options.fn.name || \"unnamed compat plugin\", options.fn.bind(_assertThisInitialized(_this)));\n\n        return true;\n      }\n    });\n\n    _this.resolverFactory = resolverFactory;\n    _this.ruleSet = new RuleSet(options.defaultRules.concat(options.rules));\n    _this.cachePredicate = typeof options.unsafeCache === \"function\" ? options.unsafeCache : Boolean.bind(null, options.unsafeCache);\n    _this.context = context || \"\";\n    _this.parserCache = Object.create(null);\n    _this.generatorCache = Object.create(null);\n\n    _this.hooks.factory.tap(\"NormalModuleFactory\", function () {\n      return function (result, callback) {\n        var resolver = _this.hooks.resolver.call(null); // Ignored\n\n\n        if (!resolver) return callback();\n        resolver(result, function (err, data) {\n          if (err) return callback(err); // Ignored\n\n          if (!data) return callback(); // direct module\n\n          if (typeof data.source === \"function\") return callback(null, data);\n\n          _this.hooks.afterResolve.callAsync(data, function (err, result) {\n            if (err) return callback(err); // Ignored\n\n            if (!result) return callback();\n\n            var createdModule = _this.hooks.createModule.call(result);\n\n            if (!createdModule) {\n              if (!result.request) {\n                return callback(new Error(\"Empty dependency (no request)\"));\n              }\n\n              createdModule = new NormalModule(result);\n            }\n\n            createdModule = _this.hooks.module.call(createdModule, result);\n            return callback(null, createdModule);\n          });\n        });\n      };\n    });\n\n    _this.hooks.resolver.tap(\"NormalModuleFactory\", function () {\n      return function (data, callback) {\n        var contextInfo = data.contextInfo;\n        var context = data.context;\n        var request = data.request;\n\n        var loaderResolver = _this.getResolver(\"loader\");\n\n        var normalResolver = _this.getResolver(\"normal\", data.resolveOptions);\n\n        var matchResource = undefined;\n        var requestWithoutMatchResource = request;\n        var matchResourceMatch = MATCH_RESOURCE_REGEX.exec(request);\n\n        if (matchResourceMatch) {\n          matchResource = matchResourceMatch[1];\n\n          if (/^\\.\\.?\\//.test(matchResource)) {\n            matchResource = path.join(context, matchResource);\n          }\n\n          requestWithoutMatchResource = request.substr(matchResourceMatch[0].length);\n        }\n\n        var noPreAutoLoaders = requestWithoutMatchResource.startsWith(\"-!\");\n        var noAutoLoaders = noPreAutoLoaders || requestWithoutMatchResource.startsWith(\"!\");\n        var noPrePostAutoLoaders = requestWithoutMatchResource.startsWith(\"!!\");\n        var elements = requestWithoutMatchResource.replace(/^-?!+/, \"\").replace(/!!+/g, \"!\").split(\"!\");\n        var resource = elements.pop();\n        elements = elements.map(identToLoaderRequest);\n        asyncLib.parallel([function (callback) {\n          return _this.resolveRequestArray(contextInfo, context, elements, loaderResolver, callback);\n        }, function (callback) {\n          if (resource === \"\" || resource[0] === \"?\") {\n            return callback(null, {\n              resource: resource\n            });\n          }\n\n          normalResolver.resolve(contextInfo, context, resource, {}, function (err, resource, resourceResolveData) {\n            if (err) return callback(err);\n            callback(null, {\n              resourceResolveData: resourceResolveData,\n              resource: resource\n            });\n          });\n        }], function (err, results) {\n          if (err) return callback(err);\n          var loaders = results[0];\n          var resourceResolveData = results[1].resourceResolveData;\n          resource = results[1].resource; // translate option idents\n\n          try {\n            var _iterator = _createForOfIteratorHelper(loaders),\n                _step;\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var item = _step.value;\n\n                if (typeof item.options === \"string\" && item.options[0] === \"?\") {\n                  var ident = item.options.substr(1);\n                  item.options = _this.ruleSet.findOptionsByIdent(ident);\n                  item.ident = ident;\n                }\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n          } catch (e) {\n            return callback(e);\n          }\n\n          if (resource === false) {\n            // ignored\n            return callback(null, new RawModule(\"/* (ignored) */\", \"ignored \".concat(context, \" \").concat(request), \"\".concat(request, \" (ignored)\")));\n          }\n\n          var userRequest = (matchResource !== undefined ? \"\".concat(matchResource, \"!=!\") : \"\") + loaders.map(loaderToIdent).concat([resource]).join(\"!\");\n          var resourcePath = matchResource !== undefined ? matchResource : resource;\n          var resourceQuery = \"\";\n          var queryIndex = resourcePath.indexOf(\"?\");\n\n          if (queryIndex >= 0) {\n            resourceQuery = resourcePath.substr(queryIndex);\n            resourcePath = resourcePath.substr(0, queryIndex);\n          }\n\n          var result = _this.ruleSet.exec({\n            resource: resourcePath,\n            realResource: matchResource !== undefined ? resource.replace(/\\?.*/, \"\") : resourcePath,\n            resourceQuery: resourceQuery,\n            issuer: contextInfo.issuer,\n            compiler: contextInfo.compiler\n          });\n\n          var settings = {};\n          var useLoadersPost = [];\n          var useLoaders = [];\n          var useLoadersPre = [];\n\n          var _iterator2 = _createForOfIteratorHelper(result),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var r = _step2.value;\n\n              if (r.type === \"use\") {\n                if (r.enforce === \"post\" && !noPrePostAutoLoaders) {\n                  useLoadersPost.push(r.value);\n                } else if (r.enforce === \"pre\" && !noPreAutoLoaders && !noPrePostAutoLoaders) {\n                  useLoadersPre.push(r.value);\n                } else if (!r.enforce && !noAutoLoaders && !noPrePostAutoLoaders) {\n                  useLoaders.push(r.value);\n                }\n              } else if (_typeof(r.value) === \"object\" && r.value !== null && _typeof(settings[r.type]) === \"object\" && settings[r.type] !== null) {\n                settings[r.type] = cachedCleverMerge(settings[r.type], r.value);\n              } else {\n                settings[r.type] = r.value;\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n\n          asyncLib.parallel([_this.resolveRequestArray.bind(_assertThisInitialized(_this), contextInfo, _this.context, useLoadersPost, loaderResolver), _this.resolveRequestArray.bind(_assertThisInitialized(_this), contextInfo, _this.context, useLoaders, loaderResolver), _this.resolveRequestArray.bind(_assertThisInitialized(_this), contextInfo, _this.context, useLoadersPre, loaderResolver)], function (err, results) {\n            if (err) return callback(err);\n\n            if (matchResource === undefined) {\n              loaders = results[0].concat(loaders, results[1], results[2]);\n            } else {\n              loaders = results[0].concat(results[1], loaders, results[2]);\n            }\n\n            process.nextTick(function () {\n              var type = settings.type;\n              var resolveOptions = settings.resolve;\n              callback(null, {\n                context: context,\n                request: loaders.map(loaderToIdent).concat([resource]).join(\"!\"),\n                dependencies: data.dependencies,\n                userRequest: userRequest,\n                rawRequest: request,\n                loaders: loaders,\n                resource: resource,\n                matchResource: matchResource,\n                resourceResolveData: resourceResolveData,\n                settings: settings,\n                type: type,\n                parser: _this.getParser(type, settings.parser),\n                generator: _this.getGenerator(type, settings.generator),\n                resolveOptions: resolveOptions\n              });\n            });\n          });\n        });\n      };\n    });\n\n    return _this;\n  }\n\n  _createClass(NormalModuleFactory, [{\n    key: \"create\",\n    value: function create(data, callback) {\n      var _this2 = this;\n\n      var dependencies = data.dependencies;\n      var cacheEntry = dependencyCache.get(dependencies[0]);\n      if (cacheEntry) return callback(null, cacheEntry);\n      var context = data.context || this.context;\n      var resolveOptions = data.resolveOptions || EMPTY_RESOLVE_OPTIONS;\n      var request = dependencies[0].request;\n      var contextInfo = data.contextInfo || {};\n      this.hooks.beforeResolve.callAsync({\n        contextInfo: contextInfo,\n        resolveOptions: resolveOptions,\n        context: context,\n        request: request,\n        dependencies: dependencies\n      }, function (err, result) {\n        if (err) return callback(err); // Ignored\n\n        if (!result) return callback();\n\n        var factory = _this2.hooks.factory.call(null); // Ignored\n\n\n        if (!factory) return callback();\n        factory(result, function (err, module) {\n          if (err) return callback(err);\n\n          if (module && _this2.cachePredicate(module)) {\n            var _iterator3 = _createForOfIteratorHelper(dependencies),\n                _step3;\n\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var d = _step3.value;\n                dependencyCache.set(d, module);\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n          }\n\n          callback(null, module);\n        });\n      });\n    }\n  }, {\n    key: \"resolveRequestArray\",\n    value: function resolveRequestArray(contextInfo, context, array, resolver, callback) {\n      if (array.length === 0) return callback(null, []);\n      asyncLib.map(array, function (item, callback) {\n        resolver.resolve(contextInfo, context, item.loader, {}, function (err, result) {\n          if (err && /^[^/]*$/.test(item.loader) && !/-loader$/.test(item.loader)) {\n            return resolver.resolve(contextInfo, context, item.loader + \"-loader\", {}, function (err2) {\n              if (!err2) {\n                err.message = err.message + \"\\n\" + \"BREAKING CHANGE: It's no longer allowed to omit the '-loader' suffix when using loaders.\\n\" + \"                 You need to specify '\".concat(item.loader, \"-loader' instead of '\").concat(item.loader, \"',\\n\") + \"                 see https://webpack.js.org/migrate/3/#automatic-loader-module-name-extension-removed\";\n              }\n\n              callback(err);\n            });\n          }\n\n          if (err) return callback(err);\n          var optionsOnly = item.options ? {\n            options: item.options\n          } : undefined;\n          return callback(null, Object.assign({}, item, identToLoaderRequest(result), optionsOnly));\n        });\n      }, callback);\n    }\n  }, {\n    key: \"getParser\",\n    value: function getParser(type, parserOptions) {\n      var ident = type;\n\n      if (parserOptions) {\n        if (parserOptions.ident) {\n          ident = \"\".concat(type, \"|\").concat(parserOptions.ident);\n        } else {\n          ident = JSON.stringify([type, parserOptions]);\n        }\n      }\n\n      if (ident in this.parserCache) {\n        return this.parserCache[ident];\n      }\n\n      return this.parserCache[ident] = this.createParser(type, parserOptions);\n    }\n  }, {\n    key: \"createParser\",\n    value: function createParser(type) {\n      var parserOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var parser = this.hooks.createParser[\"for\"](type).call(parserOptions);\n\n      if (!parser) {\n        throw new Error(\"No parser registered for \".concat(type));\n      }\n\n      this.hooks.parser[\"for\"](type).call(parser, parserOptions);\n      return parser;\n    }\n  }, {\n    key: \"getGenerator\",\n    value: function getGenerator(type, generatorOptions) {\n      var ident = type;\n\n      if (generatorOptions) {\n        if (generatorOptions.ident) {\n          ident = \"\".concat(type, \"|\").concat(generatorOptions.ident);\n        } else {\n          ident = JSON.stringify([type, generatorOptions]);\n        }\n      }\n\n      if (ident in this.generatorCache) {\n        return this.generatorCache[ident];\n      }\n\n      return this.generatorCache[ident] = this.createGenerator(type, generatorOptions);\n    }\n  }, {\n    key: \"createGenerator\",\n    value: function createGenerator(type) {\n      var generatorOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var generator = this.hooks.createGenerator[\"for\"](type).call(generatorOptions);\n\n      if (!generator) {\n        throw new Error(\"No generator registered for \".concat(type));\n      }\n\n      this.hooks.generator[\"for\"](type).call(generator, generatorOptions);\n      return generator;\n    }\n  }, {\n    key: \"getResolver\",\n    value: function getResolver(type, resolveOptions) {\n      return this.resolverFactory.get(type, resolveOptions || EMPTY_RESOLVE_OPTIONS);\n    }\n  }]);\n\n  return NormalModuleFactory;\n}(Tapable);\n\nmodule.exports = NormalModuleFactory;","map":null,"metadata":{},"sourceType":"module"}