{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar HookCodeFactory = /*#__PURE__*/function () {\n  function HookCodeFactory(config) {\n    _classCallCheck(this, HookCodeFactory);\n\n    this.config = config;\n    this.options = undefined;\n    this._args = undefined;\n  }\n\n  _createClass(HookCodeFactory, [{\n    key: \"create\",\n    value: function create(options) {\n      this.init(options);\n      var fn;\n\n      switch (this.options.type) {\n        case \"sync\":\n          fn = new Function(this.args(), '\"use strict\";\\n' + this.header() + this.content({\n            onError: function onError(err) {\n              return \"throw \".concat(err, \";\\n\");\n            },\n            onResult: function onResult(result) {\n              return \"return \".concat(result, \";\\n\");\n            },\n            resultReturns: true,\n            onDone: function onDone() {\n              return \"\";\n            },\n            rethrowIfPossible: true\n          }));\n          break;\n\n        case \"async\":\n          fn = new Function(this.args({\n            after: \"_callback\"\n          }), '\"use strict\";\\n' + this.header() + this.content({\n            onError: function onError(err) {\n              return \"_callback(\".concat(err, \");\\n\");\n            },\n            onResult: function onResult(result) {\n              return \"_callback(null, \".concat(result, \");\\n\");\n            },\n            onDone: function onDone() {\n              return \"_callback();\\n\";\n            }\n          }));\n          break;\n\n        case \"promise\":\n          var errorHelperUsed = false;\n          var content = this.content({\n            onError: function onError(err) {\n              errorHelperUsed = true;\n              return \"_error(\".concat(err, \");\\n\");\n            },\n            onResult: function onResult(result) {\n              return \"_resolve(\".concat(result, \");\\n\");\n            },\n            onDone: function onDone() {\n              return \"_resolve();\\n\";\n            }\n          });\n          var code = \"\";\n          code += '\"use strict\";\\n';\n          code += \"return new Promise((_resolve, _reject) => {\\n\";\n\n          if (errorHelperUsed) {\n            code += \"var _sync = true;\\n\";\n            code += \"function _error(_err) {\\n\";\n            code += \"if(_sync)\\n\";\n            code += \"_resolve(Promise.resolve().then(() => { throw _err; }));\\n\";\n            code += \"else\\n\";\n            code += \"_reject(_err);\\n\";\n            code += \"};\\n\";\n          }\n\n          code += this.header();\n          code += content;\n\n          if (errorHelperUsed) {\n            code += \"_sync = false;\\n\";\n          }\n\n          code += \"});\\n\";\n          fn = new Function(this.args(), code);\n          break;\n      }\n\n      this.deinit();\n      return fn;\n    }\n  }, {\n    key: \"setup\",\n    value: function setup(instance, options) {\n      instance._x = options.taps.map(function (t) {\n        return t.fn;\n      });\n    }\n    /**\n     * @param {{ type: \"sync\" | \"promise\" | \"async\", taps: Array<Tap>, interceptors: Array<Interceptor> }} options\n     */\n\n  }, {\n    key: \"init\",\n    value: function init(options) {\n      this.options = options;\n      this._args = options.args.slice();\n    }\n  }, {\n    key: \"deinit\",\n    value: function deinit() {\n      this.options = undefined;\n      this._args = undefined;\n    }\n  }, {\n    key: \"header\",\n    value: function header() {\n      var code = \"\";\n\n      if (this.needContext()) {\n        code += \"var _context = {};\\n\";\n      } else {\n        code += \"var _context;\\n\";\n      }\n\n      code += \"var _x = this._x;\\n\";\n\n      if (this.options.interceptors.length > 0) {\n        code += \"var _taps = this.taps;\\n\";\n        code += \"var _interceptors = this.interceptors;\\n\";\n      }\n\n      for (var i = 0; i < this.options.interceptors.length; i++) {\n        var interceptor = this.options.interceptors[i];\n\n        if (interceptor.call) {\n          code += \"\".concat(this.getInterceptor(i), \".call(\").concat(this.args({\n            before: interceptor.context ? \"_context\" : undefined\n          }), \");\\n\");\n        }\n      }\n\n      return code;\n    }\n  }, {\n    key: \"needContext\",\n    value: function needContext() {\n      var _iterator = _createForOfIteratorHelper(this.options.taps),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var tap = _step.value;\n          if (tap.context) return true;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return false;\n    }\n  }, {\n    key: \"callTap\",\n    value: function callTap(tapIndex, _ref) {\n      var onError = _ref.onError,\n          onResult = _ref.onResult,\n          onDone = _ref.onDone,\n          rethrowIfPossible = _ref.rethrowIfPossible;\n      var code = \"\";\n      var hasTapCached = false;\n\n      for (var i = 0; i < this.options.interceptors.length; i++) {\n        var interceptor = this.options.interceptors[i];\n\n        if (interceptor.tap) {\n          if (!hasTapCached) {\n            code += \"var _tap\".concat(tapIndex, \" = \").concat(this.getTap(tapIndex), \";\\n\");\n            hasTapCached = true;\n          }\n\n          code += \"\".concat(this.getInterceptor(i), \".tap(\").concat(interceptor.context ? \"_context, \" : \"\", \"_tap\").concat(tapIndex, \");\\n\");\n        }\n      }\n\n      code += \"var _fn\".concat(tapIndex, \" = \").concat(this.getTapFn(tapIndex), \";\\n\");\n      var tap = this.options.taps[tapIndex];\n\n      switch (tap.type) {\n        case \"sync\":\n          if (!rethrowIfPossible) {\n            code += \"var _hasError\".concat(tapIndex, \" = false;\\n\");\n            code += \"try {\\n\";\n          }\n\n          if (onResult) {\n            code += \"var _result\".concat(tapIndex, \" = _fn\").concat(tapIndex, \"(\").concat(this.args({\n              before: tap.context ? \"_context\" : undefined\n            }), \");\\n\");\n          } else {\n            code += \"_fn\".concat(tapIndex, \"(\").concat(this.args({\n              before: tap.context ? \"_context\" : undefined\n            }), \");\\n\");\n          }\n\n          if (!rethrowIfPossible) {\n            code += \"} catch(_err) {\\n\";\n            code += \"_hasError\".concat(tapIndex, \" = true;\\n\");\n            code += onError(\"_err\");\n            code += \"}\\n\";\n            code += \"if(!_hasError\".concat(tapIndex, \") {\\n\");\n          }\n\n          if (onResult) {\n            code += onResult(\"_result\".concat(tapIndex));\n          }\n\n          if (onDone) {\n            code += onDone();\n          }\n\n          if (!rethrowIfPossible) {\n            code += \"}\\n\";\n          }\n\n          break;\n\n        case \"async\":\n          var cbCode = \"\";\n          if (onResult) cbCode += \"(_err\".concat(tapIndex, \", _result\").concat(tapIndex, \") => {\\n\");else cbCode += \"_err\".concat(tapIndex, \" => {\\n\");\n          cbCode += \"if(_err\".concat(tapIndex, \") {\\n\");\n          cbCode += onError(\"_err\".concat(tapIndex));\n          cbCode += \"} else {\\n\";\n\n          if (onResult) {\n            cbCode += onResult(\"_result\".concat(tapIndex));\n          }\n\n          if (onDone) {\n            cbCode += onDone();\n          }\n\n          cbCode += \"}\\n\";\n          cbCode += \"}\";\n          code += \"_fn\".concat(tapIndex, \"(\").concat(this.args({\n            before: tap.context ? \"_context\" : undefined,\n            after: cbCode\n          }), \");\\n\");\n          break;\n\n        case \"promise\":\n          code += \"var _hasResult\".concat(tapIndex, \" = false;\\n\");\n          code += \"var _promise\".concat(tapIndex, \" = _fn\").concat(tapIndex, \"(\").concat(this.args({\n            before: tap.context ? \"_context\" : undefined\n          }), \");\\n\");\n          code += \"if (!_promise\".concat(tapIndex, \" || !_promise\").concat(tapIndex, \".then)\\n\");\n          code += \"  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise\".concat(tapIndex, \" + ')');\\n\");\n          code += \"_promise\".concat(tapIndex, \".then(_result\").concat(tapIndex, \" => {\\n\");\n          code += \"_hasResult\".concat(tapIndex, \" = true;\\n\");\n\n          if (onResult) {\n            code += onResult(\"_result\".concat(tapIndex));\n          }\n\n          if (onDone) {\n            code += onDone();\n          }\n\n          code += \"}, _err\".concat(tapIndex, \" => {\\n\");\n          code += \"if(_hasResult\".concat(tapIndex, \") throw _err\").concat(tapIndex, \";\\n\");\n          code += onError(\"_err\".concat(tapIndex));\n          code += \"});\\n\";\n          break;\n      }\n\n      return code;\n    }\n  }, {\n    key: \"callTapsSeries\",\n    value: function callTapsSeries(_ref2) {\n      var _this = this;\n\n      var _onError = _ref2.onError,\n          onResult = _ref2.onResult,\n          resultReturns = _ref2.resultReturns,\n          onDone = _ref2.onDone,\n          doneReturns = _ref2.doneReturns,\n          rethrowIfPossible = _ref2.rethrowIfPossible;\n      if (this.options.taps.length === 0) return onDone();\n      var firstAsync = this.options.taps.findIndex(function (t) {\n        return t.type !== \"sync\";\n      });\n      var somethingReturns = resultReturns || doneReturns || false;\n      var code = \"\";\n      var current = onDone;\n\n      var _loop = function _loop(j) {\n        var i = j;\n        var unroll = current !== onDone && _this.options.taps[i].type !== \"sync\";\n\n        if (unroll) {\n          code += \"function _next\".concat(i, \"() {\\n\");\n          code += current();\n          code += \"}\\n\";\n\n          current = function current() {\n            return \"\".concat(somethingReturns ? \"return \" : \"\", \"_next\").concat(i, \"();\\n\");\n          };\n        }\n\n        var done = current;\n\n        var doneBreak = function doneBreak(skipDone) {\n          if (skipDone) return \"\";\n          return onDone();\n        };\n\n        var content = _this.callTap(i, {\n          onError: function onError(error) {\n            return _onError(i, error, done, doneBreak);\n          },\n          onResult: onResult && function (result) {\n            return onResult(i, result, done, doneBreak);\n          },\n          onDone: !onResult && done,\n          rethrowIfPossible: rethrowIfPossible && (firstAsync < 0 || i < firstAsync)\n        });\n\n        current = function current() {\n          return content;\n        };\n      };\n\n      for (var j = this.options.taps.length - 1; j >= 0; j--) {\n        _loop(j);\n      }\n\n      code += current();\n      return code;\n    }\n  }, {\n    key: \"callTapsLooping\",\n    value: function callTapsLooping(_ref3) {\n      var onError = _ref3.onError,\n          onDone = _ref3.onDone,\n          rethrowIfPossible = _ref3.rethrowIfPossible;\n      if (this.options.taps.length === 0) return onDone();\n      var syncOnly = this.options.taps.every(function (t) {\n        return t.type === \"sync\";\n      });\n      var code = \"\";\n\n      if (!syncOnly) {\n        code += \"var _looper = () => {\\n\";\n        code += \"var _loopAsync = false;\\n\";\n      }\n\n      code += \"var _loop;\\n\";\n      code += \"do {\\n\";\n      code += \"_loop = false;\\n\";\n\n      for (var i = 0; i < this.options.interceptors.length; i++) {\n        var interceptor = this.options.interceptors[i];\n\n        if (interceptor.loop) {\n          code += \"\".concat(this.getInterceptor(i), \".loop(\").concat(this.args({\n            before: interceptor.context ? \"_context\" : undefined\n          }), \");\\n\");\n        }\n      }\n\n      code += this.callTapsSeries({\n        onError: onError,\n        onResult: function onResult(i, result, next, doneBreak) {\n          var code = \"\";\n          code += \"if(\".concat(result, \" !== undefined) {\\n\");\n          code += \"_loop = true;\\n\";\n          if (!syncOnly) code += \"if(_loopAsync) _looper();\\n\";\n          code += doneBreak(true);\n          code += \"} else {\\n\";\n          code += next();\n          code += \"}\\n\";\n          return code;\n        },\n        onDone: onDone && function () {\n          var code = \"\";\n          code += \"if(!_loop) {\\n\";\n          code += onDone();\n          code += \"}\\n\";\n          return code;\n        },\n        rethrowIfPossible: rethrowIfPossible && syncOnly\n      });\n      code += \"} while(_loop);\\n\";\n\n      if (!syncOnly) {\n        code += \"_loopAsync = true;\\n\";\n        code += \"};\\n\";\n        code += \"_looper();\\n\";\n      }\n\n      return code;\n    }\n  }, {\n    key: \"callTapsParallel\",\n    value: function callTapsParallel(_ref4) {\n      var _this2 = this;\n\n      var _onError2 = _ref4.onError,\n          onResult = _ref4.onResult,\n          onDone = _ref4.onDone,\n          rethrowIfPossible = _ref4.rethrowIfPossible,\n          _ref4$onTap = _ref4.onTap,\n          onTap = _ref4$onTap === void 0 ? function (i, run) {\n        return run();\n      } : _ref4$onTap;\n\n      if (this.options.taps.length <= 1) {\n        return this.callTapsSeries({\n          onError: _onError2,\n          onResult: onResult,\n          onDone: onDone,\n          rethrowIfPossible: rethrowIfPossible\n        });\n      }\n\n      var code = \"\";\n      code += \"do {\\n\";\n      code += \"var _counter = \".concat(this.options.taps.length, \";\\n\");\n\n      if (onDone) {\n        code += \"var _done = () => {\\n\";\n        code += onDone();\n        code += \"};\\n\";\n      }\n\n      var _loop2 = function _loop2(i) {\n        var done = function done() {\n          if (onDone) return \"if(--_counter === 0) _done();\\n\";else return \"--_counter;\";\n        };\n\n        var doneBreak = function doneBreak(skipDone) {\n          if (skipDone || !onDone) return \"_counter = 0;\\n\";else return \"_counter = 0;\\n_done();\\n\";\n        };\n\n        code += \"if(_counter <= 0) break;\\n\";\n        code += onTap(i, function () {\n          return _this2.callTap(i, {\n            onError: function onError(error) {\n              var code = \"\";\n              code += \"if(_counter > 0) {\\n\";\n              code += _onError2(i, error, done, doneBreak);\n              code += \"}\\n\";\n              return code;\n            },\n            onResult: onResult && function (result) {\n              var code = \"\";\n              code += \"if(_counter > 0) {\\n\";\n              code += onResult(i, result, done, doneBreak);\n              code += \"}\\n\";\n              return code;\n            },\n            onDone: !onResult && function () {\n              return done();\n            },\n            rethrowIfPossible: rethrowIfPossible\n          });\n        }, done, doneBreak);\n      };\n\n      for (var i = 0; i < this.options.taps.length; i++) {\n        _loop2(i);\n      }\n\n      code += \"} while(false);\\n\";\n      return code;\n    }\n  }, {\n    key: \"args\",\n    value: function args() {\n      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          before = _ref5.before,\n          after = _ref5.after;\n\n      var allArgs = this._args;\n      if (before) allArgs = [before].concat(allArgs);\n      if (after) allArgs = allArgs.concat(after);\n\n      if (allArgs.length === 0) {\n        return \"\";\n      } else {\n        return allArgs.join(\", \");\n      }\n    }\n  }, {\n    key: \"getTapFn\",\n    value: function getTapFn(idx) {\n      return \"_x[\".concat(idx, \"]\");\n    }\n  }, {\n    key: \"getTap\",\n    value: function getTap(idx) {\n      return \"_taps[\".concat(idx, \"]\");\n    }\n  }, {\n    key: \"getInterceptor\",\n    value: function getInterceptor(idx) {\n      return \"_interceptors[\".concat(idx, \"]\");\n    }\n  }]);\n\n  return HookCodeFactory;\n}();\n\nmodule.exports = HookCodeFactory;","map":null,"metadata":{},"sourceType":"module"}