{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Storage = /*#__PURE__*/function () {\n  function Storage(duration) {\n    _classCallCheck(this, Storage);\n\n    this.duration = duration;\n    this.running = new Map();\n    this.data = new Map();\n    this.levels = [];\n\n    if (duration > 0) {\n      this.levels.push(new Set(), new Set(), new Set(), new Set(), new Set(), new Set(), new Set(), new Set(), new Set());\n\n      for (var i = 8000; i < duration; i += 500) {\n        this.levels.push(new Set());\n      }\n    }\n\n    this.count = 0;\n    this.interval = null;\n    this.needTickCheck = false;\n    this.nextTick = null;\n    this.passive = true;\n    this.tick = this.tick.bind(this);\n  }\n\n  _createClass(Storage, [{\n    key: \"ensureTick\",\n    value: function ensureTick() {\n      if (!this.interval && this.duration > 0 && !this.nextTick) this.interval = setInterval(this.tick, Math.floor(this.duration / this.levels.length));\n    }\n  }, {\n    key: \"finished\",\n    value: function finished(name, err, result) {\n      var callbacks = this.running.get(name);\n      this.running[\"delete\"](name);\n\n      if (this.duration > 0) {\n        this.data.set(name, [err, result]);\n        var levelData = this.levels[0];\n        this.count -= levelData.size;\n        levelData.add(name);\n        this.count += levelData.size;\n        this.ensureTick();\n      }\n\n      for (var i = 0; i < callbacks.length; i++) {\n        callbacks[i](err, result);\n      }\n    }\n  }, {\n    key: \"finishedSync\",\n    value: function finishedSync(name, err, result) {\n      if (this.duration > 0) {\n        this.data.set(name, [err, result]);\n        var levelData = this.levels[0];\n        this.count -= levelData.size;\n        levelData.add(name);\n        this.count += levelData.size;\n        this.ensureTick();\n      }\n    }\n  }, {\n    key: \"provide\",\n    value: function provide(name, provider, callback) {\n      var _this = this;\n\n      if (typeof name !== \"string\") {\n        callback(new TypeError(\"path must be a string\"));\n        return;\n      }\n\n      var running = this.running.get(name);\n\n      if (running) {\n        running.push(callback);\n        return;\n      }\n\n      if (this.duration > 0) {\n        this.checkTicks();\n        var data = this.data.get(name);\n\n        if (data) {\n          return process.nextTick(function () {\n            callback.apply(null, data);\n          });\n        }\n      }\n\n      this.running.set(name, running = [callback]);\n      provider(name, function (err, result) {\n        _this.finished(name, err, result);\n      });\n    }\n  }, {\n    key: \"provideSync\",\n    value: function provideSync(name, provider) {\n      if (typeof name !== \"string\") {\n        throw new TypeError(\"path must be a string\");\n      }\n\n      if (this.duration > 0) {\n        this.checkTicks();\n        var data = this.data.get(name);\n\n        if (data) {\n          if (data[0]) throw data[0];\n          return data[1];\n        }\n      }\n\n      var result;\n\n      try {\n        result = provider(name);\n      } catch (e) {\n        this.finishedSync(name, e);\n        throw e;\n      }\n\n      this.finishedSync(name, null, result);\n      return result;\n    }\n  }, {\n    key: \"tick\",\n    value: function tick() {\n      var decay = this.levels.pop();\n\n      var _iterator = _createForOfIteratorHelper(decay),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n          this.data[\"delete\"](item);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.count -= decay.size;\n      decay.clear();\n      this.levels.unshift(decay);\n\n      if (this.count === 0) {\n        clearInterval(this.interval);\n        this.interval = null;\n        this.nextTick = null;\n        return true;\n      } else if (this.nextTick) {\n        this.nextTick += Math.floor(this.duration / this.levels.length);\n        var time = new Date().getTime();\n\n        if (this.nextTick > time) {\n          this.nextTick = null;\n          this.interval = setInterval(this.tick, Math.floor(this.duration / this.levels.length));\n          return true;\n        }\n      } else if (this.passive) {\n        clearInterval(this.interval);\n        this.interval = null;\n        this.nextTick = new Date().getTime() + Math.floor(this.duration / this.levels.length);\n      } else {\n        this.passive = true;\n      }\n    }\n  }, {\n    key: \"checkTicks\",\n    value: function checkTicks() {\n      this.passive = false;\n\n      if (this.nextTick) {\n        while (!this.tick()) {\n          ;\n        }\n      }\n    }\n  }, {\n    key: \"purge\",\n    value: function purge(what) {\n      if (!what) {\n        this.count = 0;\n        clearInterval(this.interval);\n        this.nextTick = null;\n        this.data.clear();\n        this.levels.forEach(function (level) {\n          level.clear();\n        });\n      } else if (typeof what === \"string\") {\n        var _iterator2 = _createForOfIteratorHelper(this.data.keys()),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var key = _step2.value;\n            if (key.startsWith(what)) this.data[\"delete\"](key);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      } else {\n        for (var i = what.length - 1; i >= 0; i--) {\n          this.purge(what[i]);\n        }\n      }\n    }\n  }]);\n\n  return Storage;\n}();\n\nmodule.exports = /*#__PURE__*/function () {\n  function CachedInputFileSystem(fileSystem, duration) {\n    var _this2 = this;\n\n    _classCallCheck(this, CachedInputFileSystem);\n\n    this.fileSystem = fileSystem;\n    this._statStorage = new Storage(duration);\n    this._readdirStorage = new Storage(duration);\n    this._readFileStorage = new Storage(duration);\n    this._readJsonStorage = new Storage(duration);\n    this._readlinkStorage = new Storage(duration);\n    this._stat = this.fileSystem.stat ? this.fileSystem.stat.bind(this.fileSystem) : null;\n    if (!this._stat) this.stat = null;\n    this._statSync = this.fileSystem.statSync ? this.fileSystem.statSync.bind(this.fileSystem) : null;\n    if (!this._statSync) this.statSync = null;\n    this._readdir = this.fileSystem.readdir ? this.fileSystem.readdir.bind(this.fileSystem) : null;\n    if (!this._readdir) this.readdir = null;\n    this._readdirSync = this.fileSystem.readdirSync ? this.fileSystem.readdirSync.bind(this.fileSystem) : null;\n    if (!this._readdirSync) this.readdirSync = null;\n    this._readFile = this.fileSystem.readFile ? this.fileSystem.readFile.bind(this.fileSystem) : null;\n    if (!this._readFile) this.readFile = null;\n    this._readFileSync = this.fileSystem.readFileSync ? this.fileSystem.readFileSync.bind(this.fileSystem) : null;\n    if (!this._readFileSync) this.readFileSync = null;\n\n    if (this.fileSystem.readJson) {\n      this._readJson = this.fileSystem.readJson.bind(this.fileSystem);\n    } else if (this.readFile) {\n      this._readJson = function (path, callback) {\n        _this2.readFile(path, function (err, buffer) {\n          if (err) return callback(err);\n          var data;\n\n          try {\n            data = JSON.parse(buffer.toString(\"utf-8\"));\n          } catch (e) {\n            return callback(e);\n          }\n\n          callback(null, data);\n        });\n      };\n    } else {\n      this.readJson = null;\n    }\n\n    if (this.fileSystem.readJsonSync) {\n      this._readJsonSync = this.fileSystem.readJsonSync.bind(this.fileSystem);\n    } else if (this.readFileSync) {\n      this._readJsonSync = function (path) {\n        var buffer = _this2.readFileSync(path);\n\n        var data = JSON.parse(buffer.toString(\"utf-8\"));\n        return data;\n      };\n    } else {\n      this.readJsonSync = null;\n    }\n\n    this._readlink = this.fileSystem.readlink ? this.fileSystem.readlink.bind(this.fileSystem) : null;\n    if (!this._readlink) this.readlink = null;\n    this._readlinkSync = this.fileSystem.readlinkSync ? this.fileSystem.readlinkSync.bind(this.fileSystem) : null;\n    if (!this._readlinkSync) this.readlinkSync = null;\n  }\n\n  _createClass(CachedInputFileSystem, [{\n    key: \"stat\",\n    value: function stat(path, callback) {\n      this._statStorage.provide(path, this._stat, callback);\n    }\n  }, {\n    key: \"readdir\",\n    value: function readdir(path, callback) {\n      this._readdirStorage.provide(path, this._readdir, callback);\n    }\n  }, {\n    key: \"readFile\",\n    value: function readFile(path, callback) {\n      this._readFileStorage.provide(path, this._readFile, callback);\n    }\n  }, {\n    key: \"readJson\",\n    value: function readJson(path, callback) {\n      this._readJsonStorage.provide(path, this._readJson, callback);\n    }\n  }, {\n    key: \"readlink\",\n    value: function readlink(path, callback) {\n      this._readlinkStorage.provide(path, this._readlink, callback);\n    }\n  }, {\n    key: \"statSync\",\n    value: function statSync(path) {\n      return this._statStorage.provideSync(path, this._statSync);\n    }\n  }, {\n    key: \"readdirSync\",\n    value: function readdirSync(path) {\n      return this._readdirStorage.provideSync(path, this._readdirSync);\n    }\n  }, {\n    key: \"readFileSync\",\n    value: function readFileSync(path) {\n      return this._readFileStorage.provideSync(path, this._readFileSync);\n    }\n  }, {\n    key: \"readJsonSync\",\n    value: function readJsonSync(path) {\n      return this._readJsonStorage.provideSync(path, this._readJsonSync);\n    }\n  }, {\n    key: \"readlinkSync\",\n    value: function readlinkSync(path) {\n      return this._readlinkStorage.provideSync(path, this._readlinkSync);\n    }\n  }, {\n    key: \"purge\",\n    value: function purge(what) {\n      this._statStorage.purge(what);\n\n      this._readdirStorage.purge(what);\n\n      this._readFileStorage.purge(what);\n\n      this._readlinkStorage.purge(what);\n\n      this._readJsonStorage.purge(what);\n    }\n  }]);\n\n  return CachedInputFileSystem;\n}();","map":null,"metadata":{},"sourceType":"module"}