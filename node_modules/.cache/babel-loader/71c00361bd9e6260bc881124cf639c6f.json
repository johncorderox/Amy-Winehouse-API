{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar validateOptions = require(\"schema-utils\");\n\nvar schema = require(\"../../schemas/plugins/optimize/MinChunkSizePlugin.json\");\n/** @typedef {import(\"../../declarations/plugins/optimize/MinChunkSizePlugin\").MinChunkSizePluginOptions} MinChunkSizePluginOptions */\n\n\nvar MinChunkSizePlugin = /*#__PURE__*/function () {\n  /**\n   * @param {MinChunkSizePluginOptions} options options object\n   */\n  function MinChunkSizePlugin(options) {\n    _classCallCheck(this, MinChunkSizePlugin);\n\n    validateOptions(schema, options, \"Min Chunk Size Plugin\");\n    this.options = options;\n  }\n\n  _createClass(MinChunkSizePlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var options = this.options;\n      var minChunkSize = options.minChunkSize;\n      compiler.hooks.compilation.tap(\"MinChunkSizePlugin\", function (compilation) {\n        compilation.hooks.optimizeChunksAdvanced.tap(\"MinChunkSizePlugin\", function (chunks) {\n          var equalOptions = {\n            chunkOverhead: 1,\n            entryChunkMultiplicator: 1\n          };\n          var sortedSizeFilteredExtendedPairCombinations = chunks.reduce(function (combinations, a, idx) {\n            // create combination pairs\n            for (var i = 0; i < idx; i++) {\n              var b = chunks[i];\n              combinations.push([b, a]);\n            }\n\n            return combinations;\n          }, []).filter(function (pair) {\n            // check if one of the chunks sizes is smaller than the minChunkSize\n            var p0SmallerThanMinChunkSize = pair[0].size(equalOptions) < minChunkSize;\n            var p1SmallerThanMinChunkSize = pair[1].size(equalOptions) < minChunkSize;\n            return p0SmallerThanMinChunkSize || p1SmallerThanMinChunkSize;\n          }).map(function (pair) {\n            // extend combination pairs with size and integrated size\n            var a = pair[0].size(options);\n            var b = pair[1].size(options);\n            var ab = pair[0].integratedSize(pair[1], options);\n            return [a + b - ab, ab, pair[0], pair[1]];\n          }).filter(function (pair) {\n            // filter pairs that do not have an integratedSize\n            // meaning they can NOT be integrated!\n            return pair[1] !== false;\n          }).sort(function (a, b) {\n            // sadly javascript does an inplace sort here\n            // sort by size\n            var diff = b[0] - a[0];\n            if (diff !== 0) return diff;\n            return a[1] - b[1];\n          });\n          if (sortedSizeFilteredExtendedPairCombinations.length === 0) return;\n          var pair = sortedSizeFilteredExtendedPairCombinations[0];\n          pair[2].integrate(pair[3], \"min-size\");\n          chunks.splice(chunks.indexOf(pair[3]), 1);\n          return true;\n        });\n      });\n    }\n  }]);\n\n  return MinChunkSizePlugin;\n}();\n\nmodule.exports = MinChunkSizePlugin;","map":null,"metadata":{},"sourceType":"module"}