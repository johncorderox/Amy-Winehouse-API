{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar validateOptions = require(\"schema-utils\");\n\nvar schema = require(\"../schemas/plugins/ProgressPlugin.json\");\n/** @typedef {import(\"../declarations/plugins/ProgressPlugin\").ProgressPluginArgument} ProgressPluginArgument */\n\n/** @typedef {import(\"../declarations/plugins/ProgressPlugin\").ProgressPluginOptions} ProgressPluginOptions */\n\n\nvar createDefaultHandler = function createDefaultHandler(profile, logger) {\n  var lastState;\n  var lastStateTime;\n\n  var defaultHandler = function defaultHandler(percentage, msg) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    logger.status.apply(logger, [\"\".concat(Math.floor(percentage * 100), \"%\"), msg].concat(args));\n\n    if (profile) {\n      var state = msg;\n      state = state.replace(/^\\d+\\/\\d+\\s+/, \"\");\n\n      if (percentage === 0) {\n        lastState = null;\n        lastStateTime = Date.now();\n      } else if (state !== lastState || percentage === 1) {\n        var now = Date.now();\n\n        if (lastState) {\n          var diff = now - lastStateTime;\n          var stateMsg = \"\".concat(diff, \"ms \").concat(lastState);\n\n          if (diff > 1000) {\n            logger.warn(stateMsg);\n          } else if (diff > 10) {\n            logger.info(stateMsg);\n          } else if (diff > 0) {\n            logger.log(stateMsg);\n          } else {\n            logger.debug(stateMsg);\n          }\n        }\n\n        lastState = state;\n        lastStateTime = now;\n      }\n    }\n\n    if (percentage === 1) logger.status();\n  };\n\n  return defaultHandler;\n};\n\nvar ProgressPlugin = /*#__PURE__*/function () {\n  /**\n   * @param {ProgressPluginArgument} options options\n   */\n  function ProgressPlugin(options) {\n    _classCallCheck(this, ProgressPlugin);\n\n    if (typeof options === \"function\") {\n      options = {\n        handler: options\n      };\n    }\n\n    options = options || {};\n    validateOptions(schema, options, \"Progress Plugin\");\n    options = Object.assign({}, ProgressPlugin.defaultOptions, options);\n    this.profile = options.profile;\n    this.handler = options.handler;\n    this.modulesCount = options.modulesCount;\n    this.showEntries = options.entries;\n    this.showModules = options.modules;\n    this.showActiveModules = options.activeModules;\n  }\n\n  _createClass(ProgressPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var modulesCount = this.modulesCount;\n      var handler = this.handler || createDefaultHandler(this.profile, compiler.getInfrastructureLogger(\"webpack.Progress\"));\n      var showEntries = this.showEntries;\n      var showModules = this.showModules;\n      var showActiveModules = this.showActiveModules;\n\n      if (compiler.compilers) {\n        var states = new Array(compiler.compilers.length);\n        compiler.compilers.forEach(function (compiler, idx) {\n          new ProgressPlugin(function (p, msg) {\n            for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n              args[_key2 - 2] = arguments[_key2];\n            }\n\n            states[idx] = [p, msg].concat(args);\n            handler.apply(void 0, [states.map(function (state) {\n              return state && state[0] || 0;\n            }).reduce(function (a, b) {\n              return a + b;\n            }) / states.length, \"[\".concat(idx, \"] \").concat(msg)].concat(args));\n          }).apply(compiler);\n        });\n      } else {\n        var lastModulesCount = 0;\n        var lastEntriesCount = 0;\n        var moduleCount = modulesCount;\n        var entriesCount = 1;\n        var doneModules = 0;\n        var doneEntries = 0;\n        var activeModules = new Set();\n        var lastActiveModule = \"\";\n\n        var update = function update() {\n          var percentByModules = doneModules / Math.max(lastModulesCount, moduleCount);\n          var percentByEntries = doneEntries / Math.max(lastEntriesCount, entriesCount);\n          var items = [0.1 + Math.max(percentByModules, percentByEntries) * 0.6, \"building\"];\n\n          if (showEntries) {\n            items.push(\"\".concat(doneEntries, \"/\").concat(entriesCount, \" entries\"));\n          }\n\n          if (showModules) {\n            items.push(\"\".concat(doneModules, \"/\").concat(moduleCount, \" modules\"));\n          }\n\n          if (showActiveModules) {\n            items.push(\"\".concat(activeModules.size, \" active\"));\n            items.push(lastActiveModule);\n          }\n\n          handler.apply(void 0, items);\n        };\n\n        var moduleAdd = function moduleAdd(module) {\n          moduleCount++;\n\n          if (showActiveModules) {\n            var ident = module.identifier();\n\n            if (ident) {\n              activeModules.add(ident);\n              lastActiveModule = ident;\n            }\n          }\n\n          update();\n        };\n\n        var entryAdd = function entryAdd(entry, name) {\n          entriesCount++;\n          update();\n        };\n\n        var moduleDone = function moduleDone(module) {\n          doneModules++;\n\n          if (showActiveModules) {\n            var ident = module.identifier();\n\n            if (ident) {\n              activeModules[\"delete\"](ident);\n\n              if (lastActiveModule === ident) {\n                lastActiveModule = \"\";\n\n                var _iterator = _createForOfIteratorHelper(activeModules),\n                    _step;\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    var m = _step.value;\n                    lastActiveModule = m;\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n              }\n            }\n          }\n\n          update();\n        };\n\n        var entryDone = function entryDone(entry, name) {\n          doneEntries++;\n          update();\n        };\n\n        compiler.hooks.compilation.tap(\"ProgressPlugin\", function (compilation) {\n          if (compilation.compiler.isChild()) return;\n          lastModulesCount = moduleCount;\n          lastEntriesCount = entriesCount;\n          moduleCount = entriesCount = 0;\n          doneModules = doneEntries = 0;\n          handler(0, \"compiling\");\n          compilation.hooks.buildModule.tap(\"ProgressPlugin\", moduleAdd);\n          compilation.hooks.failedModule.tap(\"ProgressPlugin\", moduleDone);\n          compilation.hooks.succeedModule.tap(\"ProgressPlugin\", moduleDone);\n          compilation.hooks.addEntry.tap(\"ProgressPlugin\", entryAdd);\n          compilation.hooks.failedEntry.tap(\"ProgressPlugin\", entryDone);\n          compilation.hooks.succeedEntry.tap(\"ProgressPlugin\", entryDone);\n          var hooks = {\n            finishModules: \"finish module graph\",\n            seal: \"sealing\",\n            beforeChunks: \"chunk graph\",\n            afterChunks: \"after chunk graph\",\n            optimizeDependenciesBasic: \"basic dependencies optimization\",\n            optimizeDependencies: \"dependencies optimization\",\n            optimizeDependenciesAdvanced: \"advanced dependencies optimization\",\n            afterOptimizeDependencies: \"after dependencies optimization\",\n            optimize: \"optimizing\",\n            optimizeModulesBasic: \"basic module optimization\",\n            optimizeModules: \"module optimization\",\n            optimizeModulesAdvanced: \"advanced module optimization\",\n            afterOptimizeModules: \"after module optimization\",\n            optimizeChunksBasic: \"basic chunk optimization\",\n            optimizeChunks: \"chunk optimization\",\n            optimizeChunksAdvanced: \"advanced chunk optimization\",\n            afterOptimizeChunks: \"after chunk optimization\",\n            optimizeTree: \"module and chunk tree optimization\",\n            afterOptimizeTree: \"after module and chunk tree optimization\",\n            optimizeChunkModulesBasic: \"basic chunk modules optimization\",\n            optimizeChunkModules: \"chunk modules optimization\",\n            optimizeChunkModulesAdvanced: \"advanced chunk modules optimization\",\n            afterOptimizeChunkModules: \"after chunk modules optimization\",\n            reviveModules: \"module reviving\",\n            optimizeModuleOrder: \"module order optimization\",\n            advancedOptimizeModuleOrder: \"advanced module order optimization\",\n            beforeModuleIds: \"before module ids\",\n            moduleIds: \"module ids\",\n            optimizeModuleIds: \"module id optimization\",\n            afterOptimizeModuleIds: \"module id optimization\",\n            reviveChunks: \"chunk reviving\",\n            optimizeChunkOrder: \"chunk order optimization\",\n            beforeChunkIds: \"before chunk ids\",\n            optimizeChunkIds: \"chunk id optimization\",\n            afterOptimizeChunkIds: \"after chunk id optimization\",\n            recordModules: \"record modules\",\n            recordChunks: \"record chunks\",\n            beforeHash: \"hashing\",\n            afterHash: \"after hashing\",\n            recordHash: \"record hash\",\n            beforeModuleAssets: \"module assets processing\",\n            beforeChunkAssets: \"chunk assets processing\",\n            additionalChunkAssets: \"additional chunk assets processing\",\n            record: \"recording\",\n            additionalAssets: \"additional asset processing\",\n            optimizeChunkAssets: \"chunk asset optimization\",\n            afterOptimizeChunkAssets: \"after chunk asset optimization\",\n            optimizeAssets: \"asset optimization\",\n            afterOptimizeAssets: \"after asset optimization\",\n            afterSeal: \"after seal\"\n          };\n          var numberOfHooks = Object.keys(hooks).length;\n          Object.keys(hooks).forEach(function (name, idx) {\n            var title = hooks[name];\n            var percentage = idx / numberOfHooks * 0.25 + 0.7;\n            compilation.hooks[name].intercept({\n              name: \"ProgressPlugin\",\n              context: true,\n              call: function call() {\n                handler(percentage, title);\n              },\n              tap: function tap(context, _tap) {\n                if (context) {\n                  // p is percentage from 0 to 1\n                  // args is any number of messages in a hierarchical matter\n                  context.reportProgress = function (p) {\n                    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n                      args[_key3 - 1] = arguments[_key3];\n                    }\n\n                    handler.apply(void 0, [percentage, title, _tap.name].concat(args));\n                  };\n                }\n\n                handler(percentage, title, _tap.name);\n              }\n            });\n          });\n        });\n        compiler.hooks.emit.intercept({\n          name: \"ProgressPlugin\",\n          context: true,\n          call: function call() {\n            handler(0.95, \"emitting\");\n          },\n          tap: function tap(context, _tap2) {\n            if (context) {\n              context.reportProgress = function (p) {\n                for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n                  args[_key4 - 1] = arguments[_key4];\n                }\n\n                handler.apply(void 0, [0.95, \"emitting\", _tap2.name].concat(args));\n              };\n            }\n\n            handler(0.95, \"emitting\", _tap2.name);\n          }\n        });\n        compiler.hooks.afterEmit.intercept({\n          name: \"ProgressPlugin\",\n          context: true,\n          call: function call() {\n            handler(0.98, \"after emitting\");\n          },\n          tap: function tap(context, _tap3) {\n            if (context) {\n              context.reportProgress = function (p) {\n                for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n                  args[_key5 - 1] = arguments[_key5];\n                }\n\n                handler.apply(void 0, [0.98, \"after emitting\", _tap3.name].concat(args));\n              };\n            }\n\n            handler(0.98, \"after emitting\", _tap3.name);\n          }\n        });\n        compiler.hooks.done.tap(\"ProgressPlugin\", function () {\n          handler(1, \"\");\n        });\n      }\n    }\n  }]);\n\n  return ProgressPlugin;\n}();\n\nProgressPlugin.defaultOptions = {\n  profile: false,\n  modulesCount: 500,\n  modules: true,\n  activeModules: true,\n  // TODO webpack 5 default this to true\n  entries: false\n};\nmodule.exports = ProgressPlugin;","map":null,"metadata":{},"sourceType":"module"}