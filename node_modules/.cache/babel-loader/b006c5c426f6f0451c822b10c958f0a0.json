{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar CodeNode = require(\"./CodeNode\");\n\nvar SourceNode = require(\"./SourceNode\");\n\nvar MappingsContext = require(\"./MappingsContext\");\n\nvar getNumberOfLines = require(\"./helpers\").getNumberOfLines;\n\nvar SourceListMap = /*#__PURE__*/function () {\n  function SourceListMap(generatedCode, source, originalSource) {\n    _classCallCheck(this, SourceListMap);\n\n    if (Array.isArray(generatedCode)) {\n      this.children = generatedCode;\n    } else {\n      this.children = [];\n      if (generatedCode || source) this.add(generatedCode, source, originalSource);\n    }\n  }\n\n  _createClass(SourceListMap, [{\n    key: \"add\",\n    value: function add(generatedCode, source, originalSource) {\n      if (typeof generatedCode === \"string\") {\n        if (source) {\n          this.children.push(new SourceNode(generatedCode, source, originalSource));\n        } else if (this.children.length > 0 && this.children[this.children.length - 1] instanceof CodeNode) {\n          this.children[this.children.length - 1].addGeneratedCode(generatedCode);\n        } else {\n          this.children.push(new CodeNode(generatedCode));\n        }\n      } else if (generatedCode.getMappings && generatedCode.getGeneratedCode) {\n        this.children.push(generatedCode);\n      } else if (generatedCode.children) {\n        generatedCode.children.forEach(function (sln) {\n          this.children.push(sln);\n        }, this);\n      } else {\n        throw new Error(\"Invalid arguments to SourceListMap.protfotype.add: Expected string, Node or SourceListMap\");\n      }\n    }\n  }, {\n    key: \"preprend\",\n    value: function preprend(generatedCode, source, originalSource) {\n      if (typeof generatedCode === \"string\") {\n        if (source) {\n          this.children.unshift(new SourceNode(generatedCode, source, originalSource));\n        } else if (this.children.length > 0 && this.children[this.children.length - 1].preprendGeneratedCode) {\n          this.children[this.children.length - 1].preprendGeneratedCode(generatedCode);\n        } else {\n          this.children.unshift(new CodeNode(generatedCode));\n        }\n      } else if (generatedCode.getMappings && generatedCode.getGeneratedCode) {\n        this.children.unshift(generatedCode);\n      } else if (generatedCode.children) {\n        generatedCode.children.slice().reverse().forEach(function (sln) {\n          this.children.unshift(sln);\n        }, this);\n      } else {\n        throw new Error(\"Invalid arguments to SourceListMap.protfotype.prerend: Expected string, Node or SourceListMap\");\n      }\n    }\n  }, {\n    key: \"mapGeneratedCode\",\n    value: function mapGeneratedCode(fn) {\n      var normalizedNodes = [];\n      this.children.forEach(function (sln) {\n        sln.getNormalizedNodes().forEach(function (newNode) {\n          normalizedNodes.push(newNode);\n        });\n      });\n      var optimizedNodes = [];\n      normalizedNodes.forEach(function (sln) {\n        sln = sln.mapGeneratedCode(fn);\n\n        if (optimizedNodes.length === 0) {\n          optimizedNodes.push(sln);\n        } else {\n          var last = optimizedNodes[optimizedNodes.length - 1];\n          var mergedNode = last.merge(sln);\n\n          if (mergedNode) {\n            optimizedNodes[optimizedNodes.length - 1] = mergedNode;\n          } else {\n            optimizedNodes.push(sln);\n          }\n        }\n      });\n      return new SourceListMap(optimizedNodes);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.children.map(function (sln) {\n        return sln.getGeneratedCode();\n      }).join(\"\");\n    }\n  }, {\n    key: \"toStringWithSourceMap\",\n    value: function toStringWithSourceMap(options) {\n      var mappingsContext = new MappingsContext();\n      var source = this.children.map(function (sln) {\n        return sln.getGeneratedCode();\n      }).join(\"\");\n      var mappings = this.children.map(function (sln) {\n        return sln.getMappings(mappingsContext);\n      }).join(\"\");\n      var arrays = mappingsContext.getArrays();\n      return {\n        source: source,\n        map: {\n          version: 3,\n          file: options && options.file,\n          sources: arrays.sources,\n          sourcesContent: mappingsContext.hasSourceContent ? arrays.sourcesContent : undefined,\n          mappings: mappings\n        }\n      };\n    }\n  }]);\n\n  return SourceListMap;\n}();\n\nmodule.exports = SourceListMap;","map":null,"metadata":{},"sourceType":"module"}