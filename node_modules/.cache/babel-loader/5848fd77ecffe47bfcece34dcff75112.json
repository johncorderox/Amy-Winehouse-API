{"ast":null,"code":"var pump = require('pump');\n\nvar inherits = require('inherits');\n\nvar Duplexify = require('duplexify');\n\nvar toArray = function toArray(args) {\n  if (!args.length) return [];\n  return Array.isArray(args[0]) ? args[0] : Array.prototype.slice.call(args);\n};\n\nvar define = function define(opts) {\n  var Pumpify = function Pumpify() {\n    var streams = toArray(arguments);\n    if (!(this instanceof Pumpify)) return new Pumpify(streams);\n    Duplexify.call(this, null, null, opts);\n    if (streams.length) this.setPipeline(streams);\n  };\n\n  inherits(Pumpify, Duplexify);\n\n  Pumpify.prototype.setPipeline = function () {\n    var streams = toArray(arguments);\n    var self = this;\n    var ended = false;\n    var w = streams[0];\n    var r = streams[streams.length - 1];\n    r = r.readable ? r : null;\n    w = w.writable ? w : null;\n\n    var onclose = function onclose() {\n      streams[0].emit('error', new Error('stream was destroyed'));\n    };\n\n    this.on('close', onclose);\n    this.on('prefinish', function () {\n      if (!ended) self.cork();\n    });\n    pump(streams, function (err) {\n      self.removeListener('close', onclose);\n      if (err) return self.destroy(err.message === 'premature close' ? null : err);\n      ended = true; // pump ends after the last stream is not writable *but*\n      // pumpify still forwards the readable part so we need to catch errors\n      // still, so reenable autoDestroy in this case\n\n      if (self._autoDestroy === false) self._autoDestroy = true;\n      self.uncork();\n    });\n    if (this.destroyed) return onclose();\n    this.setWritable(w);\n    this.setReadable(r);\n  };\n\n  return Pumpify;\n};\n\nmodule.exports = define({\n  autoDestroy: false,\n  destroy: false\n});\nmodule.exports.obj = define({\n  autoDestroy: false,\n  destroy: false,\n  objectMode: true,\n  highWaterMark: 16\n});\nmodule.exports.ctor = define;","map":null,"metadata":{},"sourceType":"module"}