{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar util = require(\"util\");\n\nvar Tapable = require(\"tapable/lib/Tapable\");\n\nvar SyncHook = require(\"tapable/lib/SyncHook\");\n\nvar AsyncSeriesBailHook = require(\"tapable/lib/AsyncSeriesBailHook\");\n\nvar AsyncSeriesHook = require(\"tapable/lib/AsyncSeriesHook\");\n\nvar createInnerContext = require(\"./createInnerContext\");\n\nvar REGEXP_NOT_MODULE = /^\\.$|^\\.[\\\\/]|^\\.\\.$|^\\.\\.[\\\\/]|^\\/|^[A-Z]:[\\\\/]/i;\nvar REGEXP_DIRECTORY = /[\\\\/]$/i;\n\nvar memoryFsJoin = require(\"memory-fs/lib/join\");\n\nvar memoizedJoin = new Map();\n\nvar memoryFsNormalize = require(\"memory-fs/lib/normalize\");\n\nfunction withName(name, hook) {\n  hook.name = name;\n  return hook;\n}\n\nfunction toCamelCase(str) {\n  return str.replace(/-([a-z])/g, function (str) {\n    return str.substr(1).toUpperCase();\n  });\n}\n\nvar deprecatedPushToMissing = util.deprecate(function (set, item) {\n  set.add(item);\n}, \"Resolver: 'missing' is now a Set. Use add instead of push.\");\nvar deprecatedResolveContextInCallback = util.deprecate(function (x) {\n  return x;\n}, \"Resolver: The callback argument was splitted into resolveContext and callback.\");\nvar deprecatedHookAsString = util.deprecate(function (x) {\n  return x;\n}, \"Resolver#doResolve: The type arguments (string) is now a hook argument (Hook). Pass a reference to the hook instead.\");\n\nvar Resolver = /*#__PURE__*/function (_Tapable) {\n  _inherits(Resolver, _Tapable);\n\n  var _super = _createSuper(Resolver);\n\n  function Resolver(fileSystem) {\n    var _this;\n\n    _classCallCheck(this, Resolver);\n\n    _this = _super.call(this);\n    _this.fileSystem = fileSystem;\n    _this.hooks = {\n      resolveStep: withName(\"resolveStep\", new SyncHook([\"hook\", \"request\"])),\n      noResolve: withName(\"noResolve\", new SyncHook([\"request\", \"error\"])),\n      resolve: withName(\"resolve\", new AsyncSeriesBailHook([\"request\", \"resolveContext\"])),\n      result: new AsyncSeriesHook([\"result\", \"resolveContext\"])\n    };\n\n    _this._pluginCompat.tap(\"Resolver: before/after\", function (options) {\n      if (/^before-/.test(options.name)) {\n        options.name = options.name.substr(7);\n        options.stage = -10;\n      } else if (/^after-/.test(options.name)) {\n        options.name = options.name.substr(6);\n        options.stage = 10;\n      }\n    });\n\n    _this._pluginCompat.tap(\"Resolver: step hooks\", function (options) {\n      var name = options.name;\n      var stepHook = !/^resolve(-s|S)tep$|^no(-r|R)esolve$/.test(name);\n\n      if (stepHook) {\n        options.async = true;\n\n        _this.ensureHook(name);\n\n        var fn = options.fn;\n\n        options.fn = function (request, resolverContext, callback) {\n          var innerCallback = function innerCallback(err, result) {\n            if (err) return callback(err);\n            if (result !== undefined) return callback(null, result);\n            callback();\n          };\n\n          for (var key in resolverContext) {\n            innerCallback[key] = resolverContext[key];\n          }\n\n          fn.call(_assertThisInitialized(_this), request, innerCallback);\n        };\n      }\n    });\n\n    return _this;\n  }\n\n  _createClass(Resolver, [{\n    key: \"ensureHook\",\n    value: function ensureHook(name) {\n      if (typeof name !== \"string\") return name;\n      name = toCamelCase(name);\n\n      if (/^before/.test(name)) {\n        return this.ensureHook(name[6].toLowerCase() + name.substr(7)).withOptions({\n          stage: -10\n        });\n      }\n\n      if (/^after/.test(name)) {\n        return this.ensureHook(name[5].toLowerCase() + name.substr(6)).withOptions({\n          stage: 10\n        });\n      }\n\n      var hook = this.hooks[name];\n\n      if (!hook) {\n        return this.hooks[name] = withName(name, new AsyncSeriesBailHook([\"request\", \"resolveContext\"]));\n      }\n\n      return hook;\n    }\n  }, {\n    key: \"getHook\",\n    value: function getHook(name) {\n      if (typeof name !== \"string\") return name;\n      name = toCamelCase(name);\n\n      if (/^before/.test(name)) {\n        return this.getHook(name[6].toLowerCase() + name.substr(7)).withOptions({\n          stage: -10\n        });\n      }\n\n      if (/^after/.test(name)) {\n        return this.getHook(name[5].toLowerCase() + name.substr(6)).withOptions({\n          stage: 10\n        });\n      }\n\n      var hook = this.hooks[name];\n\n      if (!hook) {\n        throw new Error(\"Hook \".concat(name, \" doesn't exist\"));\n      }\n\n      return hook;\n    }\n  }, {\n    key: \"resolveSync\",\n    value: function resolveSync(context, path, request) {\n      var err,\n          result,\n          sync = false;\n      this.resolve(context, path, request, {}, function (e, r) {\n        err = e;\n        result = r;\n        sync = true;\n      });\n      if (!sync) throw new Error(\"Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!\");\n      if (err) throw err;\n      return result;\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(context, path, request, resolveContext, callback) {\n      var _this2 = this;\n\n      // TODO remove in enhanced-resolve 5\n      // For backward compatiblity START\n      if (typeof callback !== \"function\") {\n        callback = deprecatedResolveContextInCallback(resolveContext); // resolveContext is a function containing additional properties\n        // It's now used for resolveContext and callback\n      } // END\n\n\n      var obj = {\n        context: context,\n        path: path,\n        request: request\n      };\n      var message = \"resolve '\" + request + \"' in '\" + path + \"'\"; // Try to resolve assuming there is no error\n      // We don't log stuff in this case\n\n      return this.doResolve(this.hooks.resolve, obj, message, {\n        missing: resolveContext.missing,\n        stack: resolveContext.stack\n      }, function (err, result) {\n        if (!err && result) {\n          return callback(null, result.path === false ? false : result.path + (result.query || \"\"), result);\n        }\n\n        var localMissing = new Set(); // TODO remove in enhanced-resolve 5\n\n        localMissing.push = function (item) {\n          return deprecatedPushToMissing(localMissing, item);\n        };\n\n        var _log = [];\n        return _this2.doResolve(_this2.hooks.resolve, obj, message, {\n          log: function log(msg) {\n            if (resolveContext.log) {\n              resolveContext.log(msg);\n            }\n\n            _log.push(msg);\n          },\n          missing: localMissing,\n          stack: resolveContext.stack\n        }, function (err, result) {\n          if (err) return callback(err);\n          var error = new Error(\"Can't \" + message);\n          error.details = _log.join(\"\\n\");\n          error.missing = Array.from(localMissing);\n\n          _this2.hooks.noResolve.call(obj, error);\n\n          return callback(error);\n        });\n      });\n    }\n  }, {\n    key: \"doResolve\",\n    value: function doResolve(hook, request, message, resolveContext, callback) {\n      // TODO remove in enhanced-resolve 5\n      // For backward compatiblity START\n      if (typeof callback !== \"function\") {\n        callback = deprecatedResolveContextInCallback(resolveContext); // resolveContext is a function containing additional properties\n        // It's now used for resolveContext and callback\n      }\n\n      if (typeof hook === \"string\") {\n        var name = toCamelCase(hook);\n        hook = deprecatedHookAsString(this.hooks[name]);\n\n        if (!hook) {\n          throw new Error(\"Hook \\\"\".concat(name, \"\\\" doesn't exist\"));\n        }\n      } // END\n\n\n      if (typeof callback !== \"function\") throw new Error(\"callback is not a function \" + Array.from(arguments));\n      if (!resolveContext) throw new Error(\"resolveContext is not an object \" + Array.from(arguments));\n      var stackLine = hook.name + \": (\" + request.path + \") \" + (request.request || \"\") + (request.query || \"\") + (request.directory ? \" directory\" : \"\") + (request.module ? \" module\" : \"\");\n      var newStack;\n\n      if (resolveContext.stack) {\n        newStack = new Set(resolveContext.stack);\n\n        if (resolveContext.stack.has(stackLine)) {\n          // Prevent recursion\n          var recursionError = new Error(\"Recursion in resolving\\nStack:\\n  \" + Array.from(newStack).join(\"\\n  \"));\n          recursionError.recursion = true;\n          if (resolveContext.log) resolveContext.log(\"abort resolving because of recursion\");\n          return callback(recursionError);\n        }\n\n        newStack.add(stackLine);\n      } else {\n        newStack = new Set([stackLine]);\n      }\n\n      this.hooks.resolveStep.call(hook, request);\n\n      if (hook.isUsed()) {\n        var innerContext = createInnerContext({\n          log: resolveContext.log,\n          missing: resolveContext.missing,\n          stack: newStack\n        }, message);\n        return hook.callAsync(request, innerContext, function (err, result) {\n          if (err) return callback(err);\n          if (result) return callback(null, result);\n          callback();\n        });\n      } else {\n        callback();\n      }\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(identifier) {\n      if (identifier === \"\") return null;\n      var part = {\n        request: \"\",\n        query: \"\",\n        module: false,\n        directory: false,\n        file: false\n      };\n      var idxQuery = identifier.indexOf(\"?\");\n\n      if (idxQuery === 0) {\n        part.query = identifier;\n      } else if (idxQuery > 0) {\n        part.request = identifier.slice(0, idxQuery);\n        part.query = identifier.slice(idxQuery);\n      } else {\n        part.request = identifier;\n      }\n\n      if (part.request) {\n        part.module = this.isModule(part.request);\n        part.directory = this.isDirectory(part.request);\n\n        if (part.directory) {\n          part.request = part.request.substr(0, part.request.length - 1);\n        }\n      }\n\n      return part;\n    }\n  }, {\n    key: \"isModule\",\n    value: function isModule(path) {\n      return !REGEXP_NOT_MODULE.test(path);\n    }\n  }, {\n    key: \"isDirectory\",\n    value: function isDirectory(path) {\n      return REGEXP_DIRECTORY.test(path);\n    }\n  }, {\n    key: \"join\",\n    value: function join(path, request) {\n      var cacheEntry;\n      var pathCache = memoizedJoin.get(path);\n\n      if (typeof pathCache === \"undefined\") {\n        memoizedJoin.set(path, pathCache = new Map());\n      } else {\n        cacheEntry = pathCache.get(request);\n        if (typeof cacheEntry !== \"undefined\") return cacheEntry;\n      }\n\n      cacheEntry = memoryFsJoin(path, request);\n      pathCache.set(request, cacheEntry);\n      return cacheEntry;\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize(path) {\n      return memoryFsNormalize(path);\n    }\n  }]);\n\n  return Resolver;\n}(Tapable);\n\nmodule.exports = Resolver;","map":null,"metadata":{},"sourceType":"module"}