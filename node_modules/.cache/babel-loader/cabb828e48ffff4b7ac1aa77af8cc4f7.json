{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\nvar normalize = require(\"./normalize\");\n\nvar errors = require(\"errno\");\n\nvar stream = require(\"readable-stream\");\n\nvar ReadableStream = stream.Readable;\nvar WritableStream = stream.Writable;\n\nfunction MemoryFileSystemError(err, path) {\n  Error.call(this);\n  if (Error.captureStackTrace) Error.captureStackTrace(this, arguments.callee);\n  this.code = err.code;\n  this.errno = err.errno;\n  this.message = err.description;\n  this.path = path;\n}\n\nMemoryFileSystemError.prototype = new Error();\n\nfunction MemoryFileSystem(data) {\n  this.data = data || {};\n}\n\nmodule.exports = MemoryFileSystem;\n\nfunction isDir(item) {\n  if (_typeof(item) !== \"object\") return false;\n  return item[\"\"] === true;\n}\n\nfunction isFile(item) {\n  if (_typeof(item) !== \"object\") return false;\n  return !item[\"\"];\n}\n\nfunction pathToArray(path) {\n  path = normalize(path);\n  var nix = /^\\//.test(path);\n\n  if (!nix) {\n    if (!/^[A-Za-z]:/.test(path)) {\n      throw new MemoryFileSystemError(errors.code.EINVAL, path);\n    }\n\n    path = path.replace(/[\\\\\\/]+/g, \"\\\\\"); // multi slashs\n\n    path = path.split(/[\\\\\\/]/);\n    path[0] = path[0].toUpperCase();\n  } else {\n    path = path.replace(/\\/+/g, \"/\"); // multi slashs\n\n    path = path.substr(1).split(\"/\");\n  }\n\n  if (!path[path.length - 1]) path.pop();\n  return path;\n}\n\nfunction trueFn() {\n  return true;\n}\n\nfunction falseFn() {\n  return false;\n}\n\nMemoryFileSystem.prototype.meta = function (_path) {\n  var path = pathToArray(_path);\n  var current = this.data;\n\n  for (var i = 0; i < path.length - 1; i++) {\n    if (!isDir(current[path[i]])) return;\n    current = current[path[i]];\n  }\n\n  return current[path[i]];\n};\n\nMemoryFileSystem.prototype.existsSync = function (_path) {\n  return !!this.meta(_path);\n};\n\nMemoryFileSystem.prototype.statSync = function (_path) {\n  var current = this.meta(_path);\n\n  if (_path === \"/\" || isDir(current)) {\n    return {\n      isFile: falseFn,\n      isDirectory: trueFn,\n      isBlockDevice: falseFn,\n      isCharacterDevice: falseFn,\n      isSymbolicLink: falseFn,\n      isFIFO: falseFn,\n      isSocket: falseFn\n    };\n  } else if (isFile(current)) {\n    return {\n      isFile: trueFn,\n      isDirectory: falseFn,\n      isBlockDevice: falseFn,\n      isCharacterDevice: falseFn,\n      isSymbolicLink: falseFn,\n      isFIFO: falseFn,\n      isSocket: falseFn\n    };\n  } else {\n    throw new MemoryFileSystemError(errors.code.ENOENT, _path);\n  }\n};\n\nMemoryFileSystem.prototype.readFileSync = function (_path, encoding) {\n  var path = pathToArray(_path);\n  var current = this.data;\n\n  for (var i = 0; i < path.length - 1; i++) {\n    if (!isDir(current[path[i]])) throw new MemoryFileSystemError(errors.code.ENOENT, _path);\n    current = current[path[i]];\n  }\n\n  if (!isFile(current[path[i]])) {\n    if (isDir(current[path[i]])) throw new MemoryFileSystemError(errors.code.EISDIR, _path);else throw new MemoryFileSystemError(errors.code.ENOENT, _path);\n  }\n\n  current = current[path[i]];\n  return encoding ? current.toString(encoding) : current;\n};\n\nMemoryFileSystem.prototype.readdirSync = function (_path) {\n  if (_path === \"/\") return Object.keys(this.data).filter(Boolean);\n  var path = pathToArray(_path);\n  var current = this.data;\n\n  for (var i = 0; i < path.length - 1; i++) {\n    if (!isDir(current[path[i]])) throw new MemoryFileSystemError(errors.code.ENOENT, _path);\n    current = current[path[i]];\n  }\n\n  if (!isDir(current[path[i]])) {\n    if (isFile(current[path[i]])) throw new MemoryFileSystemError(errors.code.ENOTDIR, _path);else throw new MemoryFileSystemError(errors.code.ENOENT, _path);\n  }\n\n  return Object.keys(current[path[i]]).filter(Boolean);\n};\n\nMemoryFileSystem.prototype.mkdirpSync = function (_path) {\n  var path = pathToArray(_path);\n  if (path.length === 0) return;\n  var current = this.data;\n\n  for (var i = 0; i < path.length; i++) {\n    if (isFile(current[path[i]])) throw new MemoryFileSystemError(errors.code.ENOTDIR, _path);else if (!isDir(current[path[i]])) current[path[i]] = {\n      \"\": true\n    };\n    current = current[path[i]];\n  }\n\n  return;\n};\n\nMemoryFileSystem.prototype.mkdirSync = function (_path) {\n  var path = pathToArray(_path);\n  if (path.length === 0) return;\n  var current = this.data;\n\n  for (var i = 0; i < path.length - 1; i++) {\n    if (!isDir(current[path[i]])) throw new MemoryFileSystemError(errors.code.ENOENT, _path);\n    current = current[path[i]];\n  }\n\n  if (isDir(current[path[i]])) throw new MemoryFileSystemError(errors.code.EEXIST, _path);else if (isFile(current[path[i]])) throw new MemoryFileSystemError(errors.code.ENOTDIR, _path);\n  current[path[i]] = {\n    \"\": true\n  };\n  return;\n};\n\nMemoryFileSystem.prototype._remove = function (_path, name, testFn) {\n  var path = pathToArray(_path);\n\n  if (path.length === 0) {\n    throw new MemoryFileSystemError(errors.code.EPERM, _path);\n  }\n\n  var current = this.data;\n\n  for (var i = 0; i < path.length - 1; i++) {\n    if (!isDir(current[path[i]])) throw new MemoryFileSystemError(errors.code.ENOENT, _path);\n    current = current[path[i]];\n  }\n\n  if (!testFn(current[path[i]])) throw new MemoryFileSystemError(errors.code.ENOENT, _path);\n  delete current[path[i]];\n  return;\n};\n\nMemoryFileSystem.prototype.rmdirSync = function (_path) {\n  return this._remove(_path, \"Directory\", isDir);\n};\n\nMemoryFileSystem.prototype.unlinkSync = function (_path) {\n  return this._remove(_path, \"File\", isFile);\n};\n\nMemoryFileSystem.prototype.readlinkSync = function (_path) {\n  throw new MemoryFileSystemError(errors.code.ENOSYS, _path);\n};\n\nMemoryFileSystem.prototype.writeFileSync = function (_path, content, encoding) {\n  if (!content && !encoding) throw new Error(\"No content\");\n  var path = pathToArray(_path);\n\n  if (path.length === 0) {\n    throw new MemoryFileSystemError(errors.code.EISDIR, _path);\n  }\n\n  var current = this.data;\n\n  for (var i = 0; i < path.length - 1; i++) {\n    if (!isDir(current[path[i]])) throw new MemoryFileSystemError(errors.code.ENOENT, _path);\n    current = current[path[i]];\n  }\n\n  if (isDir(current[path[i]])) throw new MemoryFileSystemError(errors.code.EISDIR, _path);\n  current[path[i]] = encoding || typeof content === \"string\" ? new Buffer(content, encoding) : content;\n  return;\n};\n\nMemoryFileSystem.prototype.join = require(\"./join\");\nMemoryFileSystem.prototype.pathToArray = pathToArray;\nMemoryFileSystem.prototype.normalize = normalize; // stream functions\n\nMemoryFileSystem.prototype.createReadStream = function (path, options) {\n  var stream = new ReadableStream();\n  var done = false;\n  var data;\n\n  try {\n    data = this.readFileSync(path);\n  } catch (e) {\n    stream._read = function () {\n      if (done) {\n        return;\n      }\n\n      done = true;\n      this.emit('error', e);\n      this.push(null);\n    };\n\n    return stream;\n  }\n\n  options = options || {};\n  options.start = options.start || 0;\n  options.end = options.end || data.length;\n\n  stream._read = function () {\n    if (done) {\n      return;\n    }\n\n    done = true;\n    this.push(data.slice(options.start, options.end));\n    this.push(null);\n  };\n\n  return stream;\n};\n\nMemoryFileSystem.prototype.createWriteStream = function (path, options) {\n  var stream = new WritableStream(),\n      self = this;\n\n  try {\n    // Zero the file and make sure it is writable\n    this.writeFileSync(path, new Buffer(0));\n  } catch (e) {\n    // This or setImmediate?\n    stream.once('prefinish', function () {\n      stream.emit('error', e);\n    });\n    return stream;\n  }\n\n  var bl = [],\n      len = 0;\n\n  stream._write = function (chunk, encoding, callback) {\n    bl.push(chunk);\n    len += chunk.length;\n    self.writeFile(path, Buffer.concat(bl, len), callback);\n  };\n\n  return stream;\n}; // async functions\n\n\n[\"stat\", \"readdir\", \"mkdirp\", \"rmdir\", \"unlink\", \"readlink\"].forEach(function (fn) {\n  MemoryFileSystem.prototype[fn] = function (path, callback) {\n    try {\n      var result = this[fn + \"Sync\"](path);\n    } catch (e) {\n      setImmediate(function () {\n        callback(e);\n      });\n      return;\n    }\n\n    setImmediate(function () {\n      callback(null, result);\n    });\n  };\n});\n[\"mkdir\", \"readFile\"].forEach(function (fn) {\n  MemoryFileSystem.prototype[fn] = function (path, optArg, callback) {\n    if (!callback) {\n      callback = optArg;\n      optArg = undefined;\n    }\n\n    try {\n      var result = this[fn + \"Sync\"](path, optArg);\n    } catch (e) {\n      setImmediate(function () {\n        callback(e);\n      });\n      return;\n    }\n\n    setImmediate(function () {\n      callback(null, result);\n    });\n  };\n});\n\nMemoryFileSystem.prototype.exists = function (path, callback) {\n  return callback(this.existsSync(path));\n};\n\nMemoryFileSystem.prototype.writeFile = function (path, content, encoding, callback) {\n  if (!callback) {\n    callback = encoding;\n    encoding = undefined;\n  }\n\n  try {\n    this.writeFileSync(path, content, encoding);\n  } catch (e) {\n    return callback(e);\n  }\n\n  return callback();\n};","map":null,"metadata":{},"sourceType":"module"}