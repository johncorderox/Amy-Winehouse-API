{"ast":null,"code":"'use strict';\n\nvar DEFAULT_OPTIONS = {\n  workerOptions: {},\n  maxCallsPerWorker: Infinity,\n  maxConcurrentWorkers: (require('os').cpus() || {\n    length: 1\n  }).length,\n  maxConcurrentCallsPerWorker: 10,\n  maxConcurrentCalls: Infinity,\n  maxCallTime: Infinity // exceed this and the whole worker is terminated\n  ,\n  maxRetries: Infinity,\n  forcedKillTime: 100,\n  autoStart: false,\n  onChild: function onChild() {}\n};\n\nvar fork = require('./fork'),\n    TimeoutError = require('errno').create('TimeoutError'),\n    ProcessTerminatedError = require('errno').create('ProcessTerminatedError'),\n    MaxConcurrentCallsError = require('errno').create('MaxConcurrentCallsError');\n\nfunction Farm(options, path) {\n  this.options = Object.assign({}, DEFAULT_OPTIONS, options);\n  this.path = path;\n  this.activeCalls = 0;\n} // make a handle to pass back in the form of an external API\n\n\nFarm.prototype.mkhandle = function (method) {\n  return function () {\n    var args = Array.prototype.slice.call(arguments);\n\n    if (this.activeCalls + this.callQueue.length >= this.options.maxConcurrentCalls) {\n      var err = new MaxConcurrentCallsError('Too many concurrent calls (active: ' + this.activeCalls + ', queued: ' + this.callQueue.length + ')');\n      if (typeof args[args.length - 1] == 'function') return process.nextTick(args[args.length - 1].bind(null, err));\n      throw err;\n    }\n\n    this.addCall({\n      method: method,\n      callback: args.pop(),\n      args: args,\n      retries: 0\n    });\n  }.bind(this);\n}; // a constructor of sorts\n\n\nFarm.prototype.setup = function (methods) {\n  var iface;\n\n  if (!methods) {\n    // single-function export\n    iface = this.mkhandle();\n  } else {\n    // multiple functions on the export\n    iface = {};\n    methods.forEach(function (m) {\n      iface[m] = this.mkhandle(m);\n    }.bind(this));\n  }\n\n  this.searchStart = -1;\n  this.childId = -1;\n  this.children = {};\n  this.activeChildren = 0;\n  this.callQueue = [];\n\n  if (this.options.autoStart) {\n    while (this.activeChildren < this.options.maxConcurrentWorkers) {\n      this.startChild();\n    }\n  }\n\n  return iface;\n}; // when a child exits, check if there are any outstanding jobs and requeue them\n\n\nFarm.prototype.onExit = function (childId) {\n  // delay this to give any sends a chance to finish\n  setTimeout(function () {\n    var doQueue = false;\n\n    if (this.children[childId] && this.children[childId].activeCalls) {\n      this.children[childId].calls.forEach(function (call, i) {\n        if (!call) return;else if (call.retries >= this.options.maxRetries) {\n          this.receive({\n            idx: i,\n            child: childId,\n            args: [new ProcessTerminatedError('cancel after ' + call.retries + ' retries!')]\n          });\n        } else {\n          call.retries++;\n          this.callQueue.unshift(call);\n          doQueue = true;\n        }\n      }.bind(this));\n    }\n\n    this.stopChild(childId);\n    doQueue && this.processQueue();\n  }.bind(this), 10);\n}; // start a new worker\n\n\nFarm.prototype.startChild = function () {\n  this.childId++;\n  var forked = fork(this.path, this.options.workerOptions),\n      id = this.childId,\n      c = {\n    send: forked.send,\n    child: forked.child,\n    calls: [],\n    activeCalls: 0,\n    exitCode: null\n  };\n  this.options.onChild(forked.child);\n  forked.child.on('message', function (data) {\n    if (data.owner !== 'farm') {\n      return;\n    }\n\n    this.receive(data);\n  }.bind(this));\n  forked.child.once('exit', function (code) {\n    c.exitCode = code;\n    this.onExit(id);\n  }.bind(this));\n  this.activeChildren++;\n  this.children[id] = c;\n}; // stop a worker, identified by id\n\n\nFarm.prototype.stopChild = function (childId) {\n  var child = this.children[childId];\n\n  if (child) {\n    child.send({\n      owner: 'farm',\n      event: 'die'\n    });\n    setTimeout(function () {\n      if (child.exitCode === null) child.child.kill('SIGKILL');\n    }, this.options.forcedKillTime).unref();\n    delete this.children[childId];\n    this.activeChildren--;\n  }\n}; // called from a child process, the data contains information needed to\n// look up the child and the original call so we can invoke the callback\n\n\nFarm.prototype.receive = function (data) {\n  var idx = data.idx,\n      childId = data.child,\n      args = data.args,\n      child = this.children[childId],\n      call;\n\n  if (!child) {\n    return console.error('Worker Farm: Received message for unknown child. ' + 'This is likely as a result of premature child death, ' + 'the operation will have been re-queued.');\n  }\n\n  call = child.calls[idx];\n\n  if (!call) {\n    return console.error('Worker Farm: Received message for unknown index for existing child. ' + 'This should not happen!');\n  }\n\n  if (this.options.maxCallTime !== Infinity) clearTimeout(call.timer);\n\n  if (args[0] && args[0].$error == '$error') {\n    var e = args[0];\n\n    switch (e.type) {\n      case 'TypeError':\n        args[0] = new TypeError(e.message);\n        break;\n\n      case 'RangeError':\n        args[0] = new RangeError(e.message);\n        break;\n\n      case 'EvalError':\n        args[0] = new EvalError(e.message);\n        break;\n\n      case 'ReferenceError':\n        args[0] = new ReferenceError(e.message);\n        break;\n\n      case 'SyntaxError':\n        args[0] = new SyntaxError(e.message);\n        break;\n\n      case 'URIError':\n        args[0] = new URIError(e.message);\n        break;\n\n      default:\n        args[0] = new Error(e.message);\n    }\n\n    args[0].type = e.type;\n    args[0].stack = e.stack; // Copy any custom properties to pass it on.\n\n    Object.keys(e).forEach(function (key) {\n      args[0][key] = e[key];\n    });\n  }\n\n  process.nextTick(function () {\n    call.callback.apply(null, args);\n  });\n  delete child.calls[idx];\n  child.activeCalls--;\n  this.activeCalls--;\n\n  if (child.calls.length >= this.options.maxCallsPerWorker && !Object.keys(child.calls).length) {\n    // this child has finished its run, kill it\n    this.stopChild(childId);\n  } // allow any outstanding calls to be processed\n\n\n  this.processQueue();\n};\n\nFarm.prototype.childTimeout = function (childId) {\n  var child = this.children[childId],\n      i;\n  if (!child) return;\n\n  for (i in child.calls) {\n    this.receive({\n      idx: i,\n      child: childId,\n      args: [new TimeoutError('worker call timed out!')]\n    });\n  }\n\n  this.stopChild(childId);\n}; // send a call to a worker, identified by id\n\n\nFarm.prototype.send = function (childId, call) {\n  var child = this.children[childId],\n      idx = child.calls.length;\n  child.calls.push(call);\n  child.activeCalls++;\n  this.activeCalls++;\n  child.send({\n    owner: 'farm',\n    idx: idx,\n    child: childId,\n    method: call.method,\n    args: call.args\n  });\n\n  if (this.options.maxCallTime !== Infinity) {\n    call.timer = setTimeout(this.childTimeout.bind(this, childId), this.options.maxCallTime);\n  }\n}; // a list of active worker ids, in order, but the starting offset is\n// shifted each time this method is called, so we work our way through\n// all workers when handing out jobs\n\n\nFarm.prototype.childKeys = function () {\n  var cka = Object.keys(this.children),\n      cks;\n  if (this.searchStart >= cka.length - 1) this.searchStart = 0;else this.searchStart++;\n  cks = cka.splice(0, this.searchStart);\n  return cka.concat(cks);\n}; // Calls are added to a queue, this processes the queue and is called\n// whenever there might be a chance to send more calls to the workers.\n// The various options all impact on when we're able to send calls,\n// they may need to be kept in a queue until a worker is ready.\n\n\nFarm.prototype.processQueue = function () {\n  var cka,\n      i = 0,\n      childId;\n  if (!this.callQueue.length) return this.ending && this.end();\n  if (this.activeChildren < this.options.maxConcurrentWorkers) this.startChild();\n\n  for (cka = this.childKeys(); i < cka.length; i++) {\n    childId = +cka[i];\n\n    if (this.children[childId].activeCalls < this.options.maxConcurrentCallsPerWorker && this.children[childId].calls.length < this.options.maxCallsPerWorker) {\n      this.send(childId, this.callQueue.shift());\n      if (!this.callQueue.length) return this.ending && this.end();\n    }\n    /*else {\n    console.log(\n      , this.children[childId].activeCalls < this.options.maxConcurrentCallsPerWorker\n      , this.children[childId].calls.length < this.options.maxCallsPerWorker\n      , this.children[childId].calls.length , this.options.maxCallsPerWorker)\n    }*/\n\n  }\n\n  if (this.ending) this.end();\n}; // add a new call to the call queue, then trigger a process of the queue\n\n\nFarm.prototype.addCall = function (call) {\n  if (this.ending) return this.end(); // don't add anything new to the queue\n\n  this.callQueue.push(call);\n  this.processQueue();\n}; // kills child workers when they're all done\n\n\nFarm.prototype.end = function (callback) {\n  var complete = true;\n  if (this.ending === false) return;\n  if (callback) this.ending = callback;else if (this.ending == null) this.ending = true;\n  Object.keys(this.children).forEach(function (child) {\n    if (!this.children[child]) return;\n    if (!this.children[child].activeCalls) this.stopChild(child);else complete = false;\n  }.bind(this));\n\n  if (complete && typeof this.ending == 'function') {\n    process.nextTick(function () {\n      this.ending();\n      this.ending = false;\n    }.bind(this));\n  }\n};\n\nmodule.exports = Farm;\nmodule.exports.TimeoutError = TimeoutError;","map":null,"metadata":{},"sourceType":"module"}