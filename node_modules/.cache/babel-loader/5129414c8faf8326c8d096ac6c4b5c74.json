{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction globToRegExp(glob) {\n  // * [^\\\\\\/]*\n  // /**/ /.+/\n  // ^* \\./.+ (concord special)\n  // ? [^\\\\\\/]\n  // [!...] [^...]\n  // [^...] [^...]\n  // / [\\\\\\/]\n  // {...,...} (...|...)\n  // ?(...|...) (...|...)?\n  // +(...|...) (...|...)+\n  // *(...|...) (...|...)*\n  // @(...|...) (...|...)\n  if (/^\\(.+\\)$/.test(glob)) {\n    // allow to pass an RegExp in brackets\n    return new RegExp(glob.substr(1, glob.length - 2));\n  }\n\n  var tokens = tokenize(glob);\n  var process = createRoot();\n  var regExpStr = tokens.map(process).join(\"\");\n  return new RegExp(\"^\" + regExpStr + \"$\");\n}\n\nvar SIMPLE_TOKENS = {\n  \"@(\": \"one\",\n  \"?(\": \"zero-one\",\n  \"+(\": \"one-many\",\n  \"*(\": \"zero-many\",\n  \"|\": \"segment-sep\",\n  \"/**/\": \"any-path-segments\",\n  \"**\": \"any-path\",\n  \"*\": \"any-path-segment\",\n  \"?\": \"any-char\",\n  \"{\": \"or\",\n  \"/\": \"path-sep\",\n  \",\": \"comma\",\n  \")\": \"closing-segment\",\n  \"}\": \"closing-or\"\n};\n\nfunction tokenize(glob) {\n  return glob.split(/([@?+*]\\(|\\/\\*\\*\\/|\\*\\*|[?*]|\\[[!^]?(?:[^\\]\\\\]|\\\\.)+\\]|\\{|,|\\/|[|)}])/g).map(function (item) {\n    if (!item) return null;\n    var t = SIMPLE_TOKENS[item];\n\n    if (t) {\n      return {\n        type: t\n      };\n    }\n\n    if (item[0] === \"[\") {\n      if (item[1] === \"^\" || item[1] === \"!\") {\n        return {\n          type: \"inverted-char-set\",\n          value: item.substr(2, item.length - 3)\n        };\n      } else {\n        return {\n          type: \"char-set\",\n          value: item.substr(1, item.length - 2)\n        };\n      }\n    }\n\n    return {\n      type: \"string\",\n      value: item\n    };\n  }).filter(Boolean).concat({\n    type: \"end\"\n  });\n}\n\nfunction createRoot() {\n  var inOr = [];\n  var process = createSeqment();\n  var initial = true;\n  return function (token) {\n    switch (token.type) {\n      case \"or\":\n        inOr.push(initial);\n        return \"(\";\n\n      case \"comma\":\n        if (inOr.length) {\n          initial = inOr[inOr.length - 1];\n          return \"|\";\n        } else {\n          return process({\n            type: \"string\",\n            value: \",\"\n          }, initial);\n        }\n\n      case \"closing-or\":\n        if (inOr.length === 0) throw new Error(\"Unmatched '}'\");\n        inOr.pop();\n        return \")\";\n\n      case \"end\":\n        if (inOr.length) throw new Error(\"Unmatched '{'\");\n        return process(token, initial);\n\n      default:\n        {\n          var result = process(token, initial);\n          initial = false;\n          return result;\n        }\n    }\n  };\n}\n\nfunction createSeqment() {\n  var inSeqment = [];\n  var process = createSimple();\n  return function (token, initial) {\n    switch (token.type) {\n      case \"one\":\n      case \"one-many\":\n      case \"zero-many\":\n      case \"zero-one\":\n        inSeqment.push(token.type);\n        return \"(\";\n\n      case \"segment-sep\":\n        if (inSeqment.length) {\n          return \"|\";\n        } else {\n          return process({\n            type: \"string\",\n            value: \"|\"\n          }, initial);\n        }\n\n      case \"closing-segment\":\n        {\n          var segment = inSeqment.pop();\n\n          switch (segment) {\n            case \"one\":\n              return \")\";\n\n            case \"one-many\":\n              return \")+\";\n\n            case \"zero-many\":\n              return \")*\";\n\n            case \"zero-one\":\n              return \")?\";\n          }\n\n          throw new Error(\"Unexcepted segment \" + segment);\n        }\n\n      case \"end\":\n        if (inSeqment.length > 0) {\n          throw new Error(\"Unmatched segment, missing ')'\");\n        }\n\n        return process(token, initial);\n\n      default:\n        return process(token, initial);\n    }\n  };\n}\n\nfunction createSimple() {\n  return function (token, initial) {\n    switch (token.type) {\n      case \"path-sep\":\n        return \"[\\\\\\\\/]+\";\n\n      case \"any-path-segments\":\n        return \"[\\\\\\\\/]+(?:(.+)[\\\\\\\\/]+)?\";\n\n      case \"any-path\":\n        return \"(.*)\";\n\n      case \"any-path-segment\":\n        if (initial) {\n          return \"\\\\.[\\\\\\\\/]+(?:.*[\\\\\\\\/]+)?([^\\\\\\\\/]+)\";\n        } else {\n          return \"([^\\\\\\\\/]*)\";\n        }\n\n      case \"any-char\":\n        return \"[^\\\\\\\\/]\";\n\n      case \"inverted-char-set\":\n        return \"[^\" + token.value + \"]\";\n\n      case \"char-set\":\n        return \"[\" + token.value + \"]\";\n\n      case \"string\":\n        return token.value.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n\n      case \"end\":\n        return \"\";\n\n      default:\n        throw new Error(\"Unsupported token '\" + token.type + \"'\");\n    }\n  };\n}\n\nexports.globToRegExp = globToRegExp;","map":null,"metadata":{},"sourceType":"module"}