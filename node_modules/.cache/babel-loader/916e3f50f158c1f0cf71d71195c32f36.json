{"ast":null,"code":"'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar crypto = require('crypto');\n\nvar figgyPudding = require('figgy-pudding');\n\nvar Transform = require('stream').Transform;\n\nvar SPEC_ALGORITHMS = ['sha256', 'sha384', 'sha512'];\nvar BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i;\nvar SRI_REGEX = /^([^-]+)-([^?]+)([?\\S*]*)$/;\nvar STRICT_SRI_REGEX = /^([^-]+)-([A-Za-z0-9+/=]{44,88})(\\?[\\x21-\\x7E]*)?$/;\nvar VCHAR_REGEX = /^[\\x21-\\x7E]+$/;\nvar SsriOpts = figgyPudding({\n  algorithms: {\n    \"default\": ['sha512']\n  },\n  error: {\n    \"default\": false\n  },\n  integrity: {},\n  options: {\n    \"default\": []\n  },\n  pickAlgorithm: {\n    \"default\": function _default() {\n      return getPrioritizedHash;\n    }\n  },\n  Promise: {\n    \"default\": function _default() {\n      return Promise;\n    }\n  },\n  sep: {\n    \"default\": ' '\n  },\n  single: {\n    \"default\": false\n  },\n  size: {},\n  strict: {\n    \"default\": false\n  }\n});\n\nvar Hash = /*#__PURE__*/function () {\n  function Hash(hash, opts) {\n    _classCallCheck(this, Hash);\n\n    opts = SsriOpts(opts);\n    var strict = !!opts.strict;\n    this.source = hash.trim(); // 3.1. Integrity metadata (called \"Hash\" by ssri)\n    // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description\n\n    var match = this.source.match(strict ? STRICT_SRI_REGEX : SRI_REGEX);\n\n    if (!match) {\n      return;\n    }\n\n    if (strict && !SPEC_ALGORITHMS.some(function (a) {\n      return a === match[1];\n    })) {\n      return;\n    }\n\n    this.algorithm = match[1];\n    this.digest = match[2];\n    var rawOpts = match[3];\n    this.options = rawOpts ? rawOpts.slice(1).split('?') : [];\n  }\n\n  _createClass(Hash, [{\n    key: \"isHash\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"hexDigest\",\n    value: function hexDigest() {\n      return this.digest && Buffer.from(this.digest, 'base64').toString('hex');\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.toString();\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(opts) {\n      var _this = this;\n\n      opts = SsriOpts(opts);\n\n      if (opts.strict) {\n        // Strict mode enforces the standard as close to the foot of the\n        // letter as it can.\n        if (!( // The spec has very restricted productions for algorithms.\n        // https://www.w3.org/TR/CSP2/#source-list-syntax\n        SPEC_ALGORITHMS.some(function (x) {\n          return x === _this.algorithm;\n        }) && // Usually, if someone insists on using a \"different\" base64, we\n        // leave it as-is, since there's multiple standards, and the\n        // specified is not a URL-safe variant.\n        // https://www.w3.org/TR/CSP2/#base64_value\n        this.digest.match(BASE64_REGEX) && // Option syntax is strictly visual chars.\n        // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression\n        // https://tools.ietf.org/html/rfc5234#appendix-B.1\n        (this.options || []).every(function (opt) {\n          return opt.match(VCHAR_REGEX);\n        }))) {\n          return '';\n        }\n      }\n\n      var options = this.options && this.options.length ? \"?\".concat(this.options.join('?')) : '';\n      return \"\".concat(this.algorithm, \"-\").concat(this.digest).concat(options);\n    }\n  }]);\n\n  return Hash;\n}();\n\nvar Integrity = /*#__PURE__*/function () {\n  function Integrity() {\n    _classCallCheck(this, Integrity);\n  }\n\n  _createClass(Integrity, [{\n    key: \"isIntegrity\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.toString();\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(opts) {\n      var _this2 = this;\n\n      opts = SsriOpts(opts);\n      var sep = opts.sep || ' ';\n\n      if (opts.strict) {\n        // Entries must be separated by whitespace, according to spec.\n        sep = sep.replace(/\\S+/g, ' ');\n      }\n\n      return Object.keys(this).map(function (k) {\n        return _this2[k].map(function (hash) {\n          return Hash.prototype.toString.call(hash, opts);\n        }).filter(function (x) {\n          return x.length;\n        }).join(sep);\n      }).filter(function (x) {\n        return x.length;\n      }).join(sep);\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(integrity, opts) {\n      opts = SsriOpts(opts);\n      var other = typeof integrity === 'string' ? integrity : stringify(integrity, opts);\n      return parse(\"\".concat(this.toString(opts), \" \").concat(other), opts);\n    }\n  }, {\n    key: \"hexDigest\",\n    value: function hexDigest() {\n      return parse(this, {\n        single: true\n      }).hexDigest();\n    }\n  }, {\n    key: \"match\",\n    value: function match(integrity, opts) {\n      opts = SsriOpts(opts);\n      var other = parse(integrity, opts);\n      var algo = other.pickAlgorithm(opts);\n      return this[algo] && other[algo] && this[algo].find(function (hash) {\n        return other[algo].find(function (otherhash) {\n          return hash.digest === otherhash.digest;\n        });\n      }) || false;\n    }\n  }, {\n    key: \"pickAlgorithm\",\n    value: function pickAlgorithm(opts) {\n      opts = SsriOpts(opts);\n      var pickAlgorithm = opts.pickAlgorithm;\n      var keys = Object.keys(this);\n\n      if (!keys.length) {\n        throw new Error(\"No algorithms available for \".concat(JSON.stringify(this.toString())));\n      }\n\n      return keys.reduce(function (acc, algo) {\n        return pickAlgorithm(acc, algo) || acc;\n      });\n    }\n  }]);\n\n  return Integrity;\n}();\n\nmodule.exports.parse = parse;\n\nfunction parse(sri, opts) {\n  opts = SsriOpts(opts);\n\n  if (typeof sri === 'string') {\n    return _parse(sri, opts);\n  } else if (sri.algorithm && sri.digest) {\n    var fullSri = new Integrity();\n    fullSri[sri.algorithm] = [sri];\n    return _parse(stringify(fullSri, opts), opts);\n  } else {\n    return _parse(stringify(sri, opts), opts);\n  }\n}\n\nfunction _parse(integrity, opts) {\n  // 3.4.3. Parse metadata\n  // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n  if (opts.single) {\n    return new Hash(integrity, opts);\n  }\n\n  return integrity.trim().split(/\\s+/).reduce(function (acc, string) {\n    var hash = new Hash(string, opts);\n\n    if (hash.algorithm && hash.digest) {\n      var algo = hash.algorithm;\n\n      if (!acc[algo]) {\n        acc[algo] = [];\n      }\n\n      acc[algo].push(hash);\n    }\n\n    return acc;\n  }, new Integrity());\n}\n\nmodule.exports.stringify = stringify;\n\nfunction stringify(obj, opts) {\n  opts = SsriOpts(opts);\n\n  if (obj.algorithm && obj.digest) {\n    return Hash.prototype.toString.call(obj, opts);\n  } else if (typeof obj === 'string') {\n    return stringify(parse(obj, opts), opts);\n  } else {\n    return Integrity.prototype.toString.call(obj, opts);\n  }\n}\n\nmodule.exports.fromHex = fromHex;\n\nfunction fromHex(hexDigest, algorithm, opts) {\n  opts = SsriOpts(opts);\n  var optString = opts.options && opts.options.length ? \"?\".concat(opts.options.join('?')) : '';\n  return parse(\"\".concat(algorithm, \"-\").concat(Buffer.from(hexDigest, 'hex').toString('base64')).concat(optString), opts);\n}\n\nmodule.exports.fromData = fromData;\n\nfunction fromData(data, opts) {\n  opts = SsriOpts(opts);\n  var algorithms = opts.algorithms;\n  var optString = opts.options && opts.options.length ? \"?\".concat(opts.options.join('?')) : '';\n  return algorithms.reduce(function (acc, algo) {\n    var digest = crypto.createHash(algo).update(data).digest('base64');\n    var hash = new Hash(\"\".concat(algo, \"-\").concat(digest).concat(optString), opts);\n\n    if (hash.algorithm && hash.digest) {\n      var _algo = hash.algorithm;\n\n      if (!acc[_algo]) {\n        acc[_algo] = [];\n      }\n\n      acc[_algo].push(hash);\n    }\n\n    return acc;\n  }, new Integrity());\n}\n\nmodule.exports.fromStream = fromStream;\n\nfunction fromStream(stream, opts) {\n  opts = SsriOpts(opts);\n  var P = opts.Promise || Promise;\n  var istream = integrityStream(opts);\n  return new P(function (resolve, reject) {\n    stream.pipe(istream);\n    stream.on('error', reject);\n    istream.on('error', reject);\n    var sri;\n    istream.on('integrity', function (s) {\n      sri = s;\n    });\n    istream.on('end', function () {\n      return resolve(sri);\n    });\n    istream.on('data', function () {});\n  });\n}\n\nmodule.exports.checkData = checkData;\n\nfunction checkData(data, sri, opts) {\n  opts = SsriOpts(opts);\n  sri = parse(sri, opts);\n\n  if (!Object.keys(sri).length) {\n    if (opts.error) {\n      throw Object.assign(new Error('No valid integrity hashes to check against'), {\n        code: 'EINTEGRITY'\n      });\n    } else {\n      return false;\n    }\n  }\n\n  var algorithm = sri.pickAlgorithm(opts);\n  var digest = crypto.createHash(algorithm).update(data).digest('base64');\n  var newSri = parse({\n    algorithm: algorithm,\n    digest: digest\n  });\n  var match = newSri.match(sri, opts);\n\n  if (match || !opts.error) {\n    return match;\n  } else if (typeof opts.size === 'number' && data.length !== opts.size) {\n    var err = new Error(\"data size mismatch when checking \".concat(sri, \".\\n  Wanted: \").concat(opts.size, \"\\n  Found: \").concat(data.length));\n    err.code = 'EBADSIZE';\n    err.found = data.length;\n    err.expected = opts.size;\n    err.sri = sri;\n    throw err;\n  } else {\n    var _err = new Error(\"Integrity checksum failed when using \".concat(algorithm, \": Wanted \").concat(sri, \", but got \").concat(newSri, \". (\").concat(data.length, \" bytes)\"));\n\n    _err.code = 'EINTEGRITY';\n    _err.found = newSri;\n    _err.expected = sri;\n    _err.algorithm = algorithm;\n    _err.sri = sri;\n    throw _err;\n  }\n}\n\nmodule.exports.checkStream = checkStream;\n\nfunction checkStream(stream, sri, opts) {\n  opts = SsriOpts(opts);\n  var P = opts.Promise || Promise;\n  var checker = integrityStream(opts.concat({\n    integrity: sri\n  }));\n  return new P(function (resolve, reject) {\n    stream.pipe(checker);\n    stream.on('error', reject);\n    checker.on('error', reject);\n    var sri;\n    checker.on('verified', function (s) {\n      sri = s;\n    });\n    checker.on('end', function () {\n      return resolve(sri);\n    });\n    checker.on('data', function () {});\n  });\n}\n\nmodule.exports.integrityStream = integrityStream;\n\nfunction integrityStream(opts) {\n  opts = SsriOpts(opts); // For verification\n\n  var sri = opts.integrity && parse(opts.integrity, opts);\n  var goodSri = sri && Object.keys(sri).length;\n  var algorithm = goodSri && sri.pickAlgorithm(opts);\n  var digests = goodSri && sri[algorithm]; // Calculating stream\n\n  var algorithms = Array.from(new Set(opts.algorithms.concat(algorithm ? [algorithm] : [])));\n  var hashes = algorithms.map(crypto.createHash);\n  var streamSize = 0;\n  var stream = new Transform({\n    transform: function transform(chunk, enc, cb) {\n      streamSize += chunk.length;\n      hashes.forEach(function (h) {\n        return h.update(chunk, enc);\n      });\n      cb(null, chunk, enc);\n    }\n  }).on('end', function () {\n    var optString = opts.options && opts.options.length ? \"?\".concat(opts.options.join('?')) : '';\n    var newSri = parse(hashes.map(function (h, i) {\n      return \"\".concat(algorithms[i], \"-\").concat(h.digest('base64')).concat(optString);\n    }).join(' '), opts); // Integrity verification mode\n\n    var match = goodSri && newSri.match(sri, opts);\n\n    if (typeof opts.size === 'number' && streamSize !== opts.size) {\n      var err = new Error(\"stream size mismatch when checking \".concat(sri, \".\\n  Wanted: \").concat(opts.size, \"\\n  Found: \").concat(streamSize));\n      err.code = 'EBADSIZE';\n      err.found = streamSize;\n      err.expected = opts.size;\n      err.sri = sri;\n      stream.emit('error', err);\n    } else if (opts.integrity && !match) {\n      var _err2 = new Error(\"\".concat(sri, \" integrity checksum failed when using \").concat(algorithm, \": wanted \").concat(digests, \" but got \").concat(newSri, \". (\").concat(streamSize, \" bytes)\"));\n\n      _err2.code = 'EINTEGRITY';\n      _err2.found = newSri;\n      _err2.expected = digests;\n      _err2.algorithm = algorithm;\n      _err2.sri = sri;\n      stream.emit('error', _err2);\n    } else {\n      stream.emit('size', streamSize);\n      stream.emit('integrity', newSri);\n      match && stream.emit('verified', match);\n    }\n  });\n  return stream;\n}\n\nmodule.exports.create = createIntegrity;\n\nfunction createIntegrity(opts) {\n  opts = SsriOpts(opts);\n  var algorithms = opts.algorithms;\n  var optString = opts.options.length ? \"?\".concat(opts.options.join('?')) : '';\n  var hashes = algorithms.map(crypto.createHash);\n  return {\n    update: function update(chunk, enc) {\n      hashes.forEach(function (h) {\n        return h.update(chunk, enc);\n      });\n      return this;\n    },\n    digest: function digest(enc) {\n      var integrity = algorithms.reduce(function (acc, algo) {\n        var digest = hashes.shift().digest('base64');\n        var hash = new Hash(\"\".concat(algo, \"-\").concat(digest).concat(optString), opts);\n\n        if (hash.algorithm && hash.digest) {\n          var _algo2 = hash.algorithm;\n\n          if (!acc[_algo2]) {\n            acc[_algo2] = [];\n          }\n\n          acc[_algo2].push(hash);\n        }\n\n        return acc;\n      }, new Integrity());\n      return integrity;\n    }\n  };\n}\n\nvar NODE_HASHES = new Set(crypto.getHashes()); // This is a Best Effort™ at a reasonable priority for hash algos\n\nvar DEFAULT_PRIORITY = ['md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512', // TODO - it's unclear _which_ of these Node will actually use as its name\n//        for the algorithm, so we guesswork it based on the OpenSSL names.\n'sha3', 'sha3-256', 'sha3-384', 'sha3-512', 'sha3_256', 'sha3_384', 'sha3_512'].filter(function (algo) {\n  return NODE_HASHES.has(algo);\n});\n\nfunction getPrioritizedHash(algo1, algo2) {\n  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase()) ? algo1 : algo2;\n}","map":null,"metadata":{},"sourceType":"module"}