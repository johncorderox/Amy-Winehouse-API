{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar ContextDependencyHelpers = exports;\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\n\nvar quotemeta = function quotemeta(str) {\n  return str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n\nvar splitContextFromPrefix = function splitContextFromPrefix(prefix) {\n  var idx = prefix.lastIndexOf(\"/\");\n  var context = \".\";\n\n  if (idx >= 0) {\n    context = prefix.substr(0, idx);\n    prefix = \".\".concat(prefix.substr(idx));\n  }\n\n  return {\n    context: context,\n    prefix: prefix\n  };\n};\n\nvar splitQueryFromPostfix = function splitQueryFromPostfix(postfix) {\n  var idx = postfix.indexOf(\"?\");\n  var query = \"\";\n\n  if (idx >= 0) {\n    query = postfix.substr(idx);\n    postfix = postfix.substr(0, idx);\n  }\n\n  return {\n    postfix: postfix,\n    query: query\n  };\n};\n\nContextDependencyHelpers.create = function (Dep, range, param, expr, options, contextOptions) {\n  var parser = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n\n  if (param.isTemplateString()) {\n    var prefixRaw = param.quasis[0].string;\n    var postfixRaw = param.quasis.length > 1 ? param.quasis[param.quasis.length - 1].string : \"\";\n    var valueRange = param.range;\n\n    var _splitContextFromPref = splitContextFromPrefix(prefixRaw),\n        context = _splitContextFromPref.context,\n        prefix = _splitContextFromPref.prefix;\n\n    var _splitQueryFromPostfi = splitQueryFromPostfix(postfixRaw),\n        postfix = _splitQueryFromPostfi.postfix,\n        query = _splitQueryFromPostfi.query; // When there are more than two quasis, the generated RegExp can be more precise\n    // We join the quasis with the expression regexp\n\n\n    var innerQuasis = param.quasis.slice(1, param.quasis.length - 1);\n    var innerRegExp = options.wrappedContextRegExp.source + innerQuasis.map(function (q) {\n      return quotemeta(q.string) + options.wrappedContextRegExp.source;\n    }).join(\"\"); // Example: `./context/pre${e}inner${e}inner2${e}post?query`\n    // context: \"./context\"\n    // prefix: \"./pre\"\n    // innerQuasis: [BEE(\"inner\"), BEE(\"inner2\")]\n    // (BEE = BasicEvaluatedExpression)\n    // postfix: \"post\"\n    // query: \"?query\"\n    // regExp: /^\\.\\/pre.*inner.*inner2.*post$/\n\n    var regExp = new RegExp(\"^\".concat(quotemeta(prefix)).concat(innerRegExp).concat(quotemeta(postfix), \"$\"));\n    var dep = new Dep(Object.assign({\n      request: context + query,\n      recursive: options.wrappedContextRecursive,\n      regExp: regExp,\n      mode: \"sync\"\n    }, contextOptions), range, valueRange);\n    dep.loc = expr.loc;\n    var replaces = [];\n    param.parts.forEach(function (part, i) {\n      if (i % 2 === 0) {\n        // Quasis or merged quasi\n        var _range = part.range;\n        var value = part.string;\n\n        if (param.templateStringKind === \"cooked\") {\n          value = JSON.stringify(value);\n          value = value.slice(1, value.length - 1);\n        }\n\n        if (i === 0) {\n          // prefix\n          value = prefix;\n          _range = [param.range[0], part.range[1]];\n          value = (param.templateStringKind === \"cooked\" ? \"`\" : \"String.raw`\") + value;\n        } else if (i === param.parts.length - 1) {\n          // postfix\n          value = postfix;\n          _range = [part.range[0], param.range[1]];\n          value = value + \"`\";\n        } else if (part.expression && part.expression.type === \"TemplateElement\" && part.expression.value.raw === value) {\n          // Shortcut when it's a single quasi and doesn't need to be replaced\n          return;\n        }\n\n        replaces.push({\n          range: _range,\n          value: value\n        });\n      } else {\n        // Expression\n        if (parser) {\n          parser.walkExpression(part.expression);\n        }\n      }\n    });\n    dep.replaces = replaces;\n    dep.critical = options.wrappedContextCritical && \"a part of the request of a dependency is an expression\";\n    return dep;\n  } else if (param.isWrapped() && (param.prefix && param.prefix.isString() || param.postfix && param.postfix.isString())) {\n    var _prefixRaw = param.prefix && param.prefix.isString() ? param.prefix.string : \"\";\n\n    var _postfixRaw = param.postfix && param.postfix.isString() ? param.postfix.string : \"\";\n\n    var prefixRange = param.prefix && param.prefix.isString() ? param.prefix.range : null;\n    var postfixRange = param.postfix && param.postfix.isString() ? param.postfix.range : null;\n    var _valueRange = param.range;\n\n    var _splitContextFromPref2 = splitContextFromPrefix(_prefixRaw),\n        _context = _splitContextFromPref2.context,\n        _prefix = _splitContextFromPref2.prefix;\n\n    var _splitQueryFromPostfi2 = splitQueryFromPostfix(_postfixRaw),\n        _postfix = _splitQueryFromPostfi2.postfix,\n        _query = _splitQueryFromPostfi2.query;\n\n    var _regExp = new RegExp(\"^\".concat(quotemeta(_prefix)).concat(options.wrappedContextRegExp.source).concat(quotemeta(_postfix), \"$\"));\n\n    var _dep = new Dep(Object.assign({\n      request: _context + _query,\n      recursive: options.wrappedContextRecursive,\n      regExp: _regExp,\n      mode: \"sync\"\n    }, contextOptions), range, _valueRange);\n\n    _dep.loc = expr.loc;\n    var _replaces = [];\n\n    if (prefixRange) {\n      _replaces.push({\n        range: prefixRange,\n        value: JSON.stringify(_prefix)\n      });\n    }\n\n    if (postfixRange) {\n      _replaces.push({\n        range: postfixRange,\n        value: JSON.stringify(_postfix)\n      });\n    }\n\n    _dep.replaces = _replaces;\n    _dep.critical = options.wrappedContextCritical && \"a part of the request of a dependency is an expression\";\n\n    if (parser && param.wrappedInnerExpressions) {\n      var _iterator = _createForOfIteratorHelper(param.wrappedInnerExpressions),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var part = _step.value;\n          if (part.expression) parser.walkExpression(part.expression);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    return _dep;\n  } else {\n    var _dep2 = new Dep(Object.assign({\n      request: options.exprContextRequest,\n      recursive: options.exprContextRecursive,\n      regExp: options.exprContextRegExp,\n      mode: \"sync\"\n    }, contextOptions), range, param.range);\n\n    _dep2.loc = expr.loc;\n    _dep2.critical = options.exprContextCritical && \"the request of a dependency is an expression\";\n\n    if (parser) {\n      parser.walkExpression(param.expression);\n    }\n\n    return _dep2;\n  }\n};","map":null,"metadata":{},"sourceType":"module"}