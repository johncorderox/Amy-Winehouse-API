{"ast":null,"code":"'use strict';\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar LRU = require('lru-cache');\n\nvar MAX_SIZE = 50 * 1024 * 1024; // 50MB\n\nvar MAX_AGE = 3 * 60 * 1000;\nvar MEMOIZED = new LRU({\n  max: MAX_SIZE,\n  maxAge: MAX_AGE,\n  length: function length(entry, key) {\n    if (key.startsWith('key:')) {\n      return entry.data.length;\n    } else if (key.startsWith('digest:')) {\n      return entry.length;\n    }\n  }\n});\nmodule.exports.clearMemoized = clearMemoized;\n\nfunction clearMemoized() {\n  var old = {};\n  MEMOIZED.forEach(function (v, k) {\n    old[k] = v;\n  });\n  MEMOIZED.reset();\n  return old;\n}\n\nmodule.exports.put = put;\n\nfunction put(cache, entry, data, opts) {\n  pickMem(opts).set(\"key:\".concat(cache, \":\").concat(entry.key), {\n    entry: entry,\n    data: data\n  });\n  putDigest(cache, entry.integrity, data, opts);\n}\n\nmodule.exports.put.byDigest = putDigest;\n\nfunction putDigest(cache, integrity, data, opts) {\n  pickMem(opts).set(\"digest:\".concat(cache, \":\").concat(integrity), data);\n}\n\nmodule.exports.get = get;\n\nfunction get(cache, key, opts) {\n  return pickMem(opts).get(\"key:\".concat(cache, \":\").concat(key));\n}\n\nmodule.exports.get.byDigest = getDigest;\n\nfunction getDigest(cache, integrity, opts) {\n  return pickMem(opts).get(\"digest:\".concat(cache, \":\").concat(integrity));\n}\n\nvar ObjProxy = /*#__PURE__*/function () {\n  function ObjProxy(obj) {\n    _classCallCheck(this, ObjProxy);\n\n    this.obj = obj;\n  }\n\n  _createClass(ObjProxy, [{\n    key: \"get\",\n    value: function get(key) {\n      return this.obj[key];\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, val) {\n      this.obj[key] = val;\n    }\n  }]);\n\n  return ObjProxy;\n}();\n\nfunction pickMem(opts) {\n  if (!opts || !opts.memoize) {\n    return MEMOIZED;\n  } else if (opts.memoize.get && opts.memoize.set) {\n    return opts.memoize;\n  } else if (_typeof(opts.memoize) === 'object') {\n    return new ObjProxy(opts.memoize);\n  } else {\n    return MEMOIZED;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}