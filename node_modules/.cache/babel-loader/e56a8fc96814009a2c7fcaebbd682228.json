{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar util = require(\"util\");\n\nvar DependenciesBlock = require(\"./DependenciesBlock\");\n\nvar ModuleReason = require(\"./ModuleReason\");\n\nvar SortableSet = require(\"./util/SortableSet\");\n\nvar Template = require(\"./Template\");\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./RequestShortener\")} RequestShortener */\n\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n\n/** @typedef {import(\"./util/createHash\").Hash} Hash */\n\n\nvar EMPTY_RESOLVE_OPTIONS = {};\nvar debugId = 1000;\n\nvar sortById = function sortById(a, b) {\n  return a.id - b.id;\n};\n\nvar sortByDebugId = function sortByDebugId(a, b) {\n  return a.debugId - b.debugId;\n};\n/** @typedef {(requestShortener: RequestShortener) => string} OptimizationBailoutFunction */\n\n\nvar Module = /*#__PURE__*/function (_DependenciesBlock) {\n  _inherits(Module, _DependenciesBlock);\n\n  var _super = _createSuper(Module);\n\n  function Module(type) {\n    var _this;\n\n    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _classCallCheck(this, Module);\n\n    _this = _super.call(this);\n    /** @type {string} */\n\n    _this.type = type;\n    /** @type {string} */\n\n    _this.context = context; // Unique Id\n\n    /** @type {number} */\n\n    _this.debugId = debugId++; // Hash\n\n    /** @type {string} */\n\n    _this.hash = undefined;\n    /** @type {string} */\n\n    _this.renderedHash = undefined; // Info from Factory\n\n    /** @type {TODO} */\n\n    _this.resolveOptions = EMPTY_RESOLVE_OPTIONS;\n    /** @type {object} */\n\n    _this.factoryMeta = {}; // Info from Build\n\n    /** @type {WebpackError[]} */\n\n    _this.warnings = [];\n    /** @type {WebpackError[]} */\n\n    _this.errors = [];\n    /** @type {object} */\n\n    _this.buildMeta = undefined;\n    /** @type {object} */\n\n    _this.buildInfo = undefined; // Graph (per Compilation)\n\n    /** @type {ModuleReason[]} */\n\n    _this.reasons = [];\n    /** @type {SortableSet<Chunk>} */\n\n    _this._chunks = new SortableSet(undefined, sortById); // Info from Compilation (per Compilation)\n\n    /** @type {number|string} */\n\n    _this.id = null;\n    /** @type {number} */\n\n    _this.index = null;\n    /** @type {number} */\n\n    _this.index2 = null;\n    /** @type {number} */\n\n    _this.depth = null;\n    /** @type {Module} */\n\n    _this.issuer = null;\n    /** @type {undefined | object} */\n\n    _this.profile = undefined;\n    /** @type {boolean} */\n\n    _this.prefetched = false;\n    /** @type {boolean} */\n\n    _this.built = false; // Info from Optimization (per Compilation)\n\n    /** @type {null | boolean} */\n\n    _this.used = null;\n    /** @type {false | true | string[]} */\n\n    _this.usedExports = null;\n    /** @type {(string | OptimizationBailoutFunction)[]} */\n\n    _this.optimizationBailout = []; // delayed operations\n\n    /** @type {undefined | {oldChunk: Chunk, newChunks: Chunk[]}[] } */\n\n    _this._rewriteChunkInReasons = undefined;\n    /** @type {boolean} */\n\n    _this.useSourceMap = false; // info from build\n\n    _this._source = null;\n    return _this;\n  }\n\n  _createClass(Module, [{\n    key: \"exportsArgument\",\n    get: function get() {\n      return this.buildInfo && this.buildInfo.exportsArgument || \"exports\";\n    }\n  }, {\n    key: \"moduleArgument\",\n    get: function get() {\n      return this.buildInfo && this.buildInfo.moduleArgument || \"module\";\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      this.hash = undefined;\n      this.renderedHash = undefined;\n      this.reasons.length = 0;\n      this._rewriteChunkInReasons = undefined;\n\n      this._chunks.clear();\n\n      this.id = null;\n      this.index = null;\n      this.index2 = null;\n      this.depth = null;\n      this.issuer = null;\n      this.profile = undefined;\n      this.prefetched = false;\n      this.built = false;\n      this.used = null;\n      this.usedExports = null;\n      this.optimizationBailout.length = 0;\n\n      _get(_getPrototypeOf(Module.prototype), \"disconnect\", this).call(this);\n    }\n  }, {\n    key: \"unseal\",\n    value: function unseal() {\n      this.id = null;\n      this.index = null;\n      this.index2 = null;\n      this.depth = null;\n\n      this._chunks.clear();\n\n      _get(_getPrototypeOf(Module.prototype), \"unseal\", this).call(this);\n    }\n  }, {\n    key: \"setChunks\",\n    value: function setChunks(chunks) {\n      this._chunks = new SortableSet(chunks, sortById);\n    }\n  }, {\n    key: \"addChunk\",\n    value: function addChunk(chunk) {\n      if (this._chunks.has(chunk)) return false;\n\n      this._chunks.add(chunk);\n\n      return true;\n    }\n  }, {\n    key: \"removeChunk\",\n    value: function removeChunk(chunk) {\n      if (this._chunks[\"delete\"](chunk)) {\n        chunk.removeModule(this);\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"isInChunk\",\n    value: function isInChunk(chunk) {\n      return this._chunks.has(chunk);\n    }\n  }, {\n    key: \"isEntryModule\",\n    value: function isEntryModule() {\n      var _iterator = _createForOfIteratorHelper(this._chunks),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var chunk = _step.value;\n          if (chunk.entryModule === this) return true;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return false;\n    }\n  }, {\n    key: \"optional\",\n    get: function get() {\n      return this.reasons.length > 0 && this.reasons.every(function (r) {\n        return r.dependency && r.dependency.optional;\n      });\n    }\n    /**\n     * @returns {Chunk[]} all chunks which contain the module\n     */\n\n  }, {\n    key: \"getChunks\",\n    value: function getChunks() {\n      return Array.from(this._chunks);\n    }\n  }, {\n    key: \"getNumberOfChunks\",\n    value: function getNumberOfChunks() {\n      return this._chunks.size;\n    }\n  }, {\n    key: \"chunksIterable\",\n    get: function get() {\n      return this._chunks;\n    }\n  }, {\n    key: \"hasEqualsChunks\",\n    value: function hasEqualsChunks(otherModule) {\n      if (this._chunks.size !== otherModule._chunks.size) return false;\n\n      this._chunks.sortWith(sortByDebugId);\n\n      otherModule._chunks.sortWith(sortByDebugId);\n\n      var a = this._chunks[Symbol.iterator]();\n\n      var b = otherModule._chunks[Symbol.iterator](); // eslint-disable-next-line no-constant-condition\n\n\n      while (true) {\n        var aItem = a.next();\n        var bItem = b.next();\n        if (aItem.done) return true;\n        if (aItem.value !== bItem.value) return false;\n      }\n    }\n  }, {\n    key: \"addReason\",\n    value: function addReason(module, dependency, explanation) {\n      this.reasons.push(new ModuleReason(module, dependency, explanation));\n    }\n  }, {\n    key: \"removeReason\",\n    value: function removeReason(module, dependency) {\n      for (var i = 0; i < this.reasons.length; i++) {\n        var r = this.reasons[i];\n\n        if (r.module === module && r.dependency === dependency) {\n          this.reasons.splice(i, 1);\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"hasReasonForChunk\",\n    value: function hasReasonForChunk(chunk) {\n      if (this._rewriteChunkInReasons) {\n        var _iterator2 = _createForOfIteratorHelper(this._rewriteChunkInReasons),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var operation = _step2.value;\n\n            this._doRewriteChunkInReasons(operation.oldChunk, operation.newChunks);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        this._rewriteChunkInReasons = undefined;\n      }\n\n      for (var i = 0; i < this.reasons.length; i++) {\n        if (this.reasons[i].hasChunk(chunk)) return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"hasReasons\",\n    value: function hasReasons() {\n      return this.reasons.length > 0;\n    }\n  }, {\n    key: \"rewriteChunkInReasons\",\n    value: function rewriteChunkInReasons(oldChunk, newChunks) {\n      // This is expensive. Delay operation until we really need the data\n      if (this._rewriteChunkInReasons === undefined) {\n        this._rewriteChunkInReasons = [];\n      }\n\n      this._rewriteChunkInReasons.push({\n        oldChunk: oldChunk,\n        newChunks: newChunks\n      });\n    }\n  }, {\n    key: \"_doRewriteChunkInReasons\",\n    value: function _doRewriteChunkInReasons(oldChunk, newChunks) {\n      for (var i = 0; i < this.reasons.length; i++) {\n        this.reasons[i].rewriteChunks(oldChunk, newChunks);\n      }\n    }\n    /**\n     * @param {string=} exportName the name of the export\n     * @returns {boolean|string} false if the export isn't used, true if no exportName is provided and the module is used, or the name to access it if the export is used\n     */\n\n  }, {\n    key: \"isUsed\",\n    value: function isUsed(exportName) {\n      if (!exportName) return this.used !== false;\n      if (this.used === null || this.usedExports === null) return exportName;\n      if (!this.used) return false;\n      if (!this.usedExports) return false;\n      if (this.usedExports === true) return exportName;\n      var idx = this.usedExports.indexOf(exportName);\n      if (idx < 0) return false; // Mangle export name if possible\n\n      if (this.isProvided(exportName)) {\n        if (this.buildMeta.exportsType === \"namespace\") {\n          return Template.numberToIdentifer(idx);\n        }\n\n        if (this.buildMeta.exportsType === \"named\" && !this.usedExports.includes(\"default\")) {\n          return Template.numberToIdentifer(idx);\n        }\n      }\n\n      return exportName;\n    }\n  }, {\n    key: \"isProvided\",\n    value: function isProvided(exportName) {\n      if (!Array.isArray(this.buildMeta.providedExports)) return null;\n      return this.buildMeta.providedExports.includes(exportName);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"Module[\".concat(this.id || this.debugId, \"]\");\n    }\n  }, {\n    key: \"needRebuild\",\n    value: function needRebuild(fileTimestamps, contextTimestamps) {\n      return true;\n    }\n    /**\n     * @param {Hash} hash the hash used to track dependencies\n     * @returns {void}\n     */\n\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash) {\n      hash.update(\"\".concat(this.id));\n      hash.update(JSON.stringify(this.usedExports));\n\n      _get(_getPrototypeOf(Module.prototype), \"updateHash\", this).call(this, hash);\n    }\n  }, {\n    key: \"sortItems\",\n    value: function sortItems(sortChunks) {\n      _get(_getPrototypeOf(Module.prototype), \"sortItems\", this).call(this);\n\n      if (sortChunks) this._chunks.sort();\n      this.reasons.sort(function (a, b) {\n        if (a.module === b.module) return 0;\n        if (!a.module) return -1;\n        if (!b.module) return 1;\n        return sortById(a.module, b.module);\n      });\n\n      if (Array.isArray(this.usedExports)) {\n        this.usedExports.sort();\n      }\n    }\n  }, {\n    key: \"unbuild\",\n    value: function unbuild() {\n      this.dependencies.length = 0;\n      this.blocks.length = 0;\n      this.variables.length = 0;\n      this.buildMeta = undefined;\n      this.buildInfo = undefined;\n      this.disconnect();\n    }\n  }, {\n    key: \"arguments\",\n    get: function get() {\n      throw new Error(\"Module.arguments was removed, there is no replacement.\");\n    },\n    set: function set(value) {\n      throw new Error(\"Module.arguments was removed, there is no replacement.\");\n    }\n  }]);\n\n  return Module;\n}(DependenciesBlock); // TODO remove in webpack 5\n\n\nObject.defineProperty(Module.prototype, \"forEachChunk\", {\n  configurable: false,\n  value: util.deprecate(\n  /**\n   * @deprecated\n   * @param {function(any, any, Set<any>): void} fn callback function\n   * @returns {void}\n   * @this {Module}\n   */\n  function (fn) {\n    this._chunks.forEach(fn);\n  }, \"Module.forEachChunk: Use for(const chunk of module.chunksIterable) instead\")\n}); // TODO remove in webpack 5\n\nObject.defineProperty(Module.prototype, \"mapChunks\", {\n  configurable: false,\n  value: util.deprecate(\n  /**\n   * @deprecated\n   * @param {function(any, any): void} fn Mapper function\n   * @returns {Array<TODO>} Array of chunks mapped\n   * @this {Module}\n   */\n  function (fn) {\n    return Array.from(this._chunks, fn);\n  }, \"Module.mapChunks: Use Array.from(module.chunksIterable, fn) instead\")\n}); // TODO remove in webpack 5\n\nObject.defineProperty(Module.prototype, \"entry\", {\n  configurable: false,\n  get: function get() {\n    throw new Error(\"Module.entry was removed. Use Chunk.entryModule\");\n  },\n  set: function set() {\n    throw new Error(\"Module.entry was removed. Use Chunk.entryModule\");\n  }\n}); // TODO remove in webpack 5\n\nObject.defineProperty(Module.prototype, \"meta\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @returns {void}\n   * @this {Module}\n   */\n  function () {\n    return this.buildMeta;\n  }, \"Module.meta was renamed to Module.buildMeta\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @param {TODO} value Value\n   * @returns {void}\n   * @this {Module}\n   */\n  function (value) {\n    this.buildMeta = value;\n  }, \"Module.meta was renamed to Module.buildMeta\")\n});\n/** @type {function(): string} */\n\nModule.prototype.identifier = null;\n/** @type {function(RequestShortener): string} */\n\nModule.prototype.readableIdentifier = null;\nModule.prototype.build = null;\nModule.prototype.source = null;\nModule.prototype.size = null;\nModule.prototype.nameForCondition = null;\n/** @type {null | function(Chunk): boolean} */\n\nModule.prototype.chunkCondition = null;\nModule.prototype.updateCacheModule = null;\nmodule.exports = Module;","map":null,"metadata":{},"sourceType":"module"}