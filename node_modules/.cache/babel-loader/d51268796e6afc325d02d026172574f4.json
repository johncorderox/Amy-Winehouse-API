{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar asyncLib = require(\"neo-async\");\n\nvar path = require(\"path\");\n\nvar _require = require(\"tapable\"),\n    Tapable = _require.Tapable,\n    AsyncSeriesWaterfallHook = _require.AsyncSeriesWaterfallHook,\n    SyncWaterfallHook = _require.SyncWaterfallHook;\n\nvar ContextModule = require(\"./ContextModule\");\n\nvar ContextElementDependency = require(\"./dependencies/ContextElementDependency\");\n/** @typedef {import(\"./Module\")} Module */\n\n\nvar EMPTY_RESOLVE_OPTIONS = {};\n\nmodule.exports = /*#__PURE__*/function (_Tapable) {\n  _inherits(ContextModuleFactory, _Tapable);\n\n  var _super = _createSuper(ContextModuleFactory);\n\n  function ContextModuleFactory(resolverFactory) {\n    var _this;\n\n    _classCallCheck(this, ContextModuleFactory);\n\n    _this = _super.call(this);\n    _this.hooks = {\n      /** @type {AsyncSeriesWaterfallHook<TODO>} */\n      beforeResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\n      /** @type {AsyncSeriesWaterfallHook<TODO>} */\n      afterResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\n      /** @type {SyncWaterfallHook<string[]>} */\n      contextModuleFiles: new SyncWaterfallHook([\"files\"]),\n\n      /** @type {SyncWaterfallHook<TODO[]>} */\n      alternatives: new AsyncSeriesWaterfallHook([\"modules\"])\n    };\n\n    _this._pluginCompat.tap(\"ContextModuleFactory\", function (options) {\n      switch (options.name) {\n        case \"before-resolve\":\n        case \"after-resolve\":\n        case \"alternatives\":\n          options.async = true;\n          break;\n      }\n    });\n\n    _this.resolverFactory = resolverFactory;\n    return _this;\n  }\n\n  _createClass(ContextModuleFactory, [{\n    key: \"create\",\n    value: function create(data, callback) {\n      var _this2 = this;\n\n      var context = data.context;\n      var dependencies = data.dependencies;\n      var resolveOptions = data.resolveOptions;\n      var dependency = dependencies[0];\n      this.hooks.beforeResolve.callAsync(Object.assign({\n        context: context,\n        dependencies: dependencies,\n        resolveOptions: resolveOptions\n      }, dependency.options), function (err, beforeResolveResult) {\n        if (err) return callback(err); // Ignored\n\n        if (!beforeResolveResult) return callback();\n        var context = beforeResolveResult.context;\n        var request = beforeResolveResult.request;\n        var resolveOptions = beforeResolveResult.resolveOptions;\n        var loaders,\n            resource,\n            loadersPrefix = \"\";\n        var idx = request.lastIndexOf(\"!\");\n\n        if (idx >= 0) {\n          var loadersRequest = request.substr(0, idx + 1);\n          var i;\n\n          for (i = 0; i < loadersRequest.length && loadersRequest[i] === \"!\"; i++) {\n            loadersPrefix += \"!\";\n          }\n\n          loadersRequest = loadersRequest.substr(i).replace(/!+$/, \"\").replace(/!!+/g, \"!\");\n\n          if (loadersRequest === \"\") {\n            loaders = [];\n          } else {\n            loaders = loadersRequest.split(\"!\");\n          }\n\n          resource = request.substr(idx + 1);\n        } else {\n          loaders = [];\n          resource = request;\n        }\n\n        var contextResolver = _this2.resolverFactory.get(\"context\", resolveOptions || EMPTY_RESOLVE_OPTIONS);\n\n        var loaderResolver = _this2.resolverFactory.get(\"loader\", EMPTY_RESOLVE_OPTIONS);\n\n        asyncLib.parallel([function (callback) {\n          contextResolver.resolve({}, context, resource, {}, function (err, result) {\n            if (err) return callback(err);\n            callback(null, result);\n          });\n        }, function (callback) {\n          asyncLib.map(loaders, function (loader, callback) {\n            loaderResolver.resolve({}, context, loader, {}, function (err, result) {\n              if (err) return callback(err);\n              callback(null, result);\n            });\n          }, callback);\n        }], function (err, result) {\n          if (err) return callback(err);\n\n          _this2.hooks.afterResolve.callAsync(Object.assign({\n            addon: loadersPrefix + result[1].join(\"!\") + (result[1].length > 0 ? \"!\" : \"\"),\n            resource: result[0],\n            resolveDependencies: _this2.resolveDependencies.bind(_this2)\n          }, beforeResolveResult), function (err, result) {\n            if (err) return callback(err); // Ignored\n\n            if (!result) return callback();\n            return callback(null, new ContextModule(result.resolveDependencies, result));\n          });\n        });\n      });\n    }\n  }, {\n    key: \"resolveDependencies\",\n    value: function resolveDependencies(fs, options, callback) {\n      var _this3 = this;\n\n      var cmf = this;\n      var resource = options.resource;\n      var resourceQuery = options.resourceQuery;\n      var recursive = options.recursive;\n      var regExp = options.regExp;\n      var include = options.include;\n      var exclude = options.exclude;\n      if (!regExp || !resource) return callback(null, []);\n\n      var addDirectory = function addDirectory(directory, callback) {\n        fs.readdir(directory, function (err, files) {\n          if (err) return callback(err);\n          files = cmf.hooks.contextModuleFiles.call(files);\n          if (!files || files.length === 0) return callback(null, []);\n          asyncLib.map(files.filter(function (p) {\n            return p.indexOf(\".\") !== 0;\n          }), function (segment, callback) {\n            var subResource = path.join(directory, segment);\n\n            if (!exclude || !subResource.match(exclude)) {\n              fs.stat(subResource, function (err, stat) {\n                if (err) {\n                  if (err.code === \"ENOENT\") {\n                    // ENOENT is ok here because the file may have been deleted between\n                    // the readdir and stat calls.\n                    return callback();\n                  } else {\n                    return callback(err);\n                  }\n                }\n\n                if (stat.isDirectory()) {\n                  if (!recursive) return callback();\n                  addDirectory.call(_this3, subResource, callback);\n                } else if (stat.isFile() && (!include || subResource.match(include))) {\n                  var obj = {\n                    context: resource,\n                    request: \".\" + subResource.substr(resource.length).replace(/\\\\/g, \"/\")\n                  };\n\n                  _this3.hooks.alternatives.callAsync([obj], function (err, alternatives) {\n                    if (err) return callback(err);\n                    alternatives = alternatives.filter(function (obj) {\n                      return regExp.test(obj.request);\n                    }).map(function (obj) {\n                      var dep = new ContextElementDependency(obj.request + resourceQuery, obj.request);\n                      dep.optional = true;\n                      return dep;\n                    });\n                    callback(null, alternatives);\n                  });\n                } else {\n                  callback();\n                }\n              });\n            } else {\n              callback();\n            }\n          }, function (err, result) {\n            if (err) return callback(err);\n            if (!result) return callback(null, []);\n            callback(null, result.filter(Boolean).reduce(function (a, i) {\n              return a.concat(i);\n            }, []));\n          });\n        });\n      };\n\n      addDirectory(resource, callback);\n    }\n  }]);\n\n  return ContextModuleFactory;\n}(Tapable);","map":null,"metadata":{},"sourceType":"module"}