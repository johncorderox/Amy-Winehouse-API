{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\"; // Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar acorn = require(\"acorn\");\n\nvar _require = require(\"tapable\"),\n    Tapable = _require.Tapable,\n    SyncBailHook = _require.SyncBailHook,\n    HookMap = _require.HookMap;\n\nvar util = require(\"util\");\n\nvar vm = require(\"vm\");\n\nvar BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\n\nvar StackedSetMap = require(\"./util/StackedSetMap\");\n\nvar acornParser = acorn.Parser;\n\nvar joinRanges = function joinRanges(startRange, endRange) {\n  if (!endRange) return startRange;\n  if (!startRange) return endRange;\n  return [startRange[0], endRange[1]];\n};\n\nvar defaultParserOptions = {\n  ranges: true,\n  locations: true,\n  ecmaVersion: 11,\n  sourceType: \"module\",\n  onComment: null\n}; // regexp to match at least one \"magic comment\"\n\nvar webpackCommentRegExp = new RegExp(/(^|\\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/);\nvar EMPTY_COMMENT_OPTIONS = {\n  options: null,\n  errors: null\n};\n\nvar Parser = /*#__PURE__*/function (_Tapable) {\n  _inherits(Parser, _Tapable);\n\n  var _super = _createSuper(Parser);\n\n  function Parser(options) {\n    var _this;\n\n    var sourceType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"auto\";\n\n    _classCallCheck(this, Parser);\n\n    _this = _super.call(this);\n    _this.hooks = {\n      evaluateTypeof: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      evaluate: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      evaluateIdentifier: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      evaluateDefinedIdentifier: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      evaluateCallExpressionMember: new HookMap(function () {\n        return new SyncBailHook([\"expression\", \"param\"]);\n      }),\n      statement: new SyncBailHook([\"statement\"]),\n      statementIf: new SyncBailHook([\"statement\"]),\n      label: new HookMap(function () {\n        return new SyncBailHook([\"statement\"]);\n      }),\n      \"import\": new SyncBailHook([\"statement\", \"source\"]),\n      importSpecifier: new SyncBailHook([\"statement\", \"source\", \"exportName\", \"identifierName\"]),\n      \"export\": new SyncBailHook([\"statement\"]),\n      exportImport: new SyncBailHook([\"statement\", \"source\"]),\n      exportDeclaration: new SyncBailHook([\"statement\", \"declaration\"]),\n      exportExpression: new SyncBailHook([\"statement\", \"declaration\"]),\n      exportSpecifier: new SyncBailHook([\"statement\", \"identifierName\", \"exportName\", \"index\"]),\n      exportImportSpecifier: new SyncBailHook([\"statement\", \"source\", \"identifierName\", \"exportName\", \"index\"]),\n      varDeclaration: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n      varDeclarationLet: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n      varDeclarationConst: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n      varDeclarationVar: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n      canRename: new HookMap(function () {\n        return new SyncBailHook([\"initExpression\"]);\n      }),\n      rename: new HookMap(function () {\n        return new SyncBailHook([\"initExpression\"]);\n      }),\n      assigned: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      assign: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      \"typeof\": new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      importCall: new SyncBailHook([\"expression\"]),\n      call: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      callAnyMember: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      \"new\": new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      expression: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      expressionAnyMember: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      expressionConditionalOperator: new SyncBailHook([\"expression\"]),\n      expressionLogicalOperator: new SyncBailHook([\"expression\"]),\n      program: new SyncBailHook([\"ast\", \"comments\"])\n    };\n    var HOOK_MAP_COMPAT_CONFIG = {\n      evaluateTypeof: /^evaluate typeof (.+)$/,\n      evaluateIdentifier: /^evaluate Identifier (.+)$/,\n      evaluateDefinedIdentifier: /^evaluate defined Identifier (.+)$/,\n      evaluateCallExpressionMember: /^evaluate CallExpression .(.+)$/,\n      evaluate: /^evaluate (.+)$/,\n      label: /^label (.+)$/,\n      varDeclarationLet: /^var-let (.+)$/,\n      varDeclarationConst: /^var-const (.+)$/,\n      varDeclarationVar: /^var-var (.+)$/,\n      varDeclaration: /^var (.+)$/,\n      canRename: /^can-rename (.+)$/,\n      rename: /^rename (.+)$/,\n      \"typeof\": /^typeof (.+)$/,\n      assigned: /^assigned (.+)$/,\n      assign: /^assign (.+)$/,\n      callAnyMember: /^call (.+)\\.\\*$/,\n      call: /^call (.+)$/,\n      \"new\": /^new (.+)$/,\n      expressionConditionalOperator: /^expression \\?:$/,\n      expressionAnyMember: /^expression (.+)\\.\\*$/,\n      expression: /^expression (.+)$/\n    };\n\n    _this._pluginCompat.tap(\"Parser\", function (options) {\n      for (var _i = 0, _Object$keys = Object.keys(HOOK_MAP_COMPAT_CONFIG); _i < _Object$keys.length; _i++) {\n        var name = _Object$keys[_i];\n        var regexp = HOOK_MAP_COMPAT_CONFIG[name];\n        var match = regexp.exec(options.name);\n\n        if (match) {\n          if (match[1]) {\n            _this.hooks[name].tap(match[1], options.fn.name || \"unnamed compat plugin\", options.fn.bind(_assertThisInitialized(_this)));\n          } else {\n            _this.hooks[name].tap(options.fn.name || \"unnamed compat plugin\", options.fn.bind(_assertThisInitialized(_this)));\n          }\n\n          return true;\n        }\n      }\n    });\n\n    _this.options = options;\n    _this.sourceType = sourceType;\n    _this.scope = undefined;\n    _this.state = undefined;\n    _this.comments = undefined;\n\n    _this.initializeEvaluating();\n\n    return _this;\n  }\n\n  _createClass(Parser, [{\n    key: \"initializeEvaluating\",\n    value: function initializeEvaluating() {\n      var _this2 = this;\n\n      this.hooks.evaluate[\"for\"](\"Literal\").tap(\"Parser\", function (expr) {\n        switch (_typeof(expr.value)) {\n          case \"number\":\n            return new BasicEvaluatedExpression().setNumber(expr.value).setRange(expr.range);\n\n          case \"string\":\n            return new BasicEvaluatedExpression().setString(expr.value).setRange(expr.range);\n\n          case \"boolean\":\n            return new BasicEvaluatedExpression().setBoolean(expr.value).setRange(expr.range);\n        }\n\n        if (expr.value === null) {\n          return new BasicEvaluatedExpression().setNull().setRange(expr.range);\n        }\n\n        if (expr.value instanceof RegExp) {\n          return new BasicEvaluatedExpression().setRegExp(expr.value).setRange(expr.range);\n        }\n      });\n      this.hooks.evaluate[\"for\"](\"LogicalExpression\").tap(\"Parser\", function (expr) {\n        var left;\n        var leftAsBool;\n        var right;\n\n        if (expr.operator === \"&&\") {\n          left = _this2.evaluateExpression(expr.left);\n          leftAsBool = left && left.asBool();\n          if (leftAsBool === false) return left.setRange(expr.range);\n          if (leftAsBool !== true) return;\n          right = _this2.evaluateExpression(expr.right);\n          return right.setRange(expr.range);\n        } else if (expr.operator === \"||\") {\n          left = _this2.evaluateExpression(expr.left);\n          leftAsBool = left && left.asBool();\n          if (leftAsBool === true) return left.setRange(expr.range);\n          if (leftAsBool !== false) return;\n          right = _this2.evaluateExpression(expr.right);\n          return right.setRange(expr.range);\n        }\n      });\n      this.hooks.evaluate[\"for\"](\"BinaryExpression\").tap(\"Parser\", function (expr) {\n        var left;\n        var right;\n        var res;\n\n        if (expr.operator === \"+\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          res = new BasicEvaluatedExpression();\n\n          if (left.isString()) {\n            if (right.isString()) {\n              res.setString(left.string + right.string);\n            } else if (right.isNumber()) {\n              res.setString(left.string + right.number);\n            } else if (right.isWrapped() && right.prefix && right.prefix.isString()) {\n              // \"left\" + (\"prefix\" + inner + \"postfix\")\n              // => (\"leftprefix\" + inner + \"postfix\")\n              res.setWrapped(new BasicEvaluatedExpression().setString(left.string + right.prefix.string).setRange(joinRanges(left.range, right.prefix.range)), right.postfix, right.wrappedInnerExpressions);\n            } else if (right.isWrapped()) {\n              // \"left\" + ([null] + inner + \"postfix\")\n              // => (\"left\" + inner + \"postfix\")\n              res.setWrapped(left, right.postfix, right.wrappedInnerExpressions);\n            } else {\n              // \"left\" + expr\n              // => (\"left\" + expr + \"\")\n              res.setWrapped(left, null, [right]);\n            }\n          } else if (left.isNumber()) {\n            if (right.isString()) {\n              res.setString(left.number + right.string);\n            } else if (right.isNumber()) {\n              res.setNumber(left.number + right.number);\n            } else {\n              return;\n            }\n          } else if (left.isWrapped()) {\n            if (left.postfix && left.postfix.isString() && right.isString()) {\n              // (\"prefix\" + inner + \"postfix\") + \"right\"\n              // => (\"prefix\" + inner + \"postfixright\")\n              res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.string).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions);\n            } else if (left.postfix && left.postfix.isString() && right.isNumber()) {\n              // (\"prefix\" + inner + \"postfix\") + 123\n              // => (\"prefix\" + inner + \"postfix123\")\n              res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.number).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions);\n            } else if (right.isString()) {\n              // (\"prefix\" + inner + [null]) + \"right\"\n              // => (\"prefix\" + inner + \"right\")\n              res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);\n            } else if (right.isNumber()) {\n              // (\"prefix\" + inner + [null]) + 123\n              // => (\"prefix\" + inner + \"123\")\n              res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(right.number + \"\").setRange(right.range), left.wrappedInnerExpressions);\n            } else if (right.isWrapped()) {\n              // (\"prefix1\" + inner1 + \"postfix1\") + (\"prefix2\" + inner2 + \"postfix2\")\n              // (\"prefix1\" + inner1 + \"postfix1\" + \"prefix2\" + inner2 + \"postfix2\")\n              res.setWrapped(left.prefix, right.postfix, left.wrappedInnerExpressions && right.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix] : []).concat(right.prefix ? [right.prefix] : []).concat(right.wrappedInnerExpressions));\n            } else {\n              // (\"prefix\" + inner + postfix) + expr\n              // => (\"prefix\" + inner + postfix + expr + [null])\n              res.setWrapped(left.prefix, null, left.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix, right] : [right]));\n            }\n          } else {\n            if (right.isString()) {\n              // left + \"right\"\n              // => ([null] + left + \"right\")\n              res.setWrapped(null, right, [left]);\n            } else if (right.isWrapped()) {\n              // left + (prefix + inner + \"postfix\")\n              // => ([null] + left + prefix + inner + \"postfix\")\n              res.setWrapped(null, right.postfix, right.wrappedInnerExpressions && (right.prefix ? [left, right.prefix] : [left]).concat(right.wrappedInnerExpressions));\n            } else {\n              return;\n            }\n          }\n\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"-\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number - right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"*\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number * right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"/\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number / right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"**\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(Math.pow(left.number, right.number));\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"==\" || expr.operator === \"===\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          res = new BasicEvaluatedExpression();\n          res.setRange(expr.range);\n\n          if (left.isString() && right.isString()) {\n            return res.setBoolean(left.string === right.string);\n          } else if (left.isNumber() && right.isNumber()) {\n            return res.setBoolean(left.number === right.number);\n          } else if (left.isBoolean() && right.isBoolean()) {\n            return res.setBoolean(left.bool === right.bool);\n          }\n        } else if (expr.operator === \"!=\" || expr.operator === \"!==\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          res = new BasicEvaluatedExpression();\n          res.setRange(expr.range);\n\n          if (left.isString() && right.isString()) {\n            return res.setBoolean(left.string !== right.string);\n          } else if (left.isNumber() && right.isNumber()) {\n            return res.setBoolean(left.number !== right.number);\n          } else if (left.isBoolean() && right.isBoolean()) {\n            return res.setBoolean(left.bool !== right.bool);\n          }\n        } else if (expr.operator === \"&\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number & right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"|\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number | right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"^\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number ^ right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \">>>\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number >>> right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \">>\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number >> right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"<<\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number << right.number);\n          res.setRange(expr.range);\n          return res;\n        }\n      });\n      this.hooks.evaluate[\"for\"](\"UnaryExpression\").tap(\"Parser\", function (expr) {\n        if (expr.operator === \"typeof\") {\n          var res;\n          var name;\n\n          if (expr.argument.type === \"Identifier\") {\n            name = _this2.scope.renames.get(expr.argument.name) || expr.argument.name;\n\n            if (!_this2.scope.definitions.has(name)) {\n              var hook = _this2.hooks.evaluateTypeof.get(name);\n\n              if (hook !== undefined) {\n                res = hook.call(expr);\n                if (res !== undefined) return res;\n              }\n            }\n          }\n\n          if (expr.argument.type === \"MemberExpression\") {\n            var exprName = _this2.getNameForExpression(expr.argument);\n\n            if (exprName && exprName.free) {\n              var _hook = _this2.hooks.evaluateTypeof.get(exprName.name);\n\n              if (_hook !== undefined) {\n                res = _hook.call(expr);\n                if (res !== undefined) return res;\n              }\n            }\n          }\n\n          if (expr.argument.type === \"FunctionExpression\") {\n            return new BasicEvaluatedExpression().setString(\"function\").setRange(expr.range);\n          }\n\n          var arg = _this2.evaluateExpression(expr.argument);\n\n          if (arg.isString() || arg.isWrapped()) {\n            return new BasicEvaluatedExpression().setString(\"string\").setRange(expr.range);\n          }\n\n          if (arg.isNumber()) {\n            return new BasicEvaluatedExpression().setString(\"number\").setRange(expr.range);\n          }\n\n          if (arg.isBoolean()) {\n            return new BasicEvaluatedExpression().setString(\"boolean\").setRange(expr.range);\n          }\n\n          if (arg.isArray() || arg.isConstArray() || arg.isRegExp()) {\n            return new BasicEvaluatedExpression().setString(\"object\").setRange(expr.range);\n          }\n        } else if (expr.operator === \"!\") {\n          var argument = _this2.evaluateExpression(expr.argument);\n\n          if (!argument) return;\n\n          if (argument.isBoolean()) {\n            return new BasicEvaluatedExpression().setBoolean(!argument.bool).setRange(expr.range);\n          }\n\n          if (argument.isTruthy()) {\n            return new BasicEvaluatedExpression().setBoolean(false).setRange(expr.range);\n          }\n\n          if (argument.isFalsy()) {\n            return new BasicEvaluatedExpression().setBoolean(true).setRange(expr.range);\n          }\n\n          if (argument.isString()) {\n            return new BasicEvaluatedExpression().setBoolean(!argument.string).setRange(expr.range);\n          }\n\n          if (argument.isNumber()) {\n            return new BasicEvaluatedExpression().setBoolean(!argument.number).setRange(expr.range);\n          }\n        } else if (expr.operator === \"~\") {\n          var _argument = _this2.evaluateExpression(expr.argument);\n\n          if (!_argument) return;\n          if (!_argument.isNumber()) return;\n\n          var _res = new BasicEvaluatedExpression();\n\n          _res.setNumber(~_argument.number);\n\n          _res.setRange(expr.range);\n\n          return _res;\n        }\n      });\n      this.hooks.evaluateTypeof[\"for\"](\"undefined\").tap(\"Parser\", function (expr) {\n        return new BasicEvaluatedExpression().setString(\"undefined\").setRange(expr.range);\n      });\n      this.hooks.evaluate[\"for\"](\"Identifier\").tap(\"Parser\", function (expr) {\n        var name = _this2.scope.renames.get(expr.name) || expr.name;\n\n        if (!_this2.scope.definitions.has(expr.name)) {\n          var hook = _this2.hooks.evaluateIdentifier.get(name);\n\n          if (hook !== undefined) {\n            var result = hook.call(expr);\n            if (result) return result;\n          }\n\n          return new BasicEvaluatedExpression().setIdentifier(name).setRange(expr.range);\n        } else {\n          var _hook2 = _this2.hooks.evaluateDefinedIdentifier.get(name);\n\n          if (_hook2 !== undefined) {\n            return _hook2.call(expr);\n          }\n        }\n      });\n      this.hooks.evaluate[\"for\"](\"ThisExpression\").tap(\"Parser\", function (expr) {\n        var name = _this2.scope.renames.get(\"this\");\n\n        if (name) {\n          var hook = _this2.hooks.evaluateIdentifier.get(name);\n\n          if (hook !== undefined) {\n            var result = hook.call(expr);\n            if (result) return result;\n          }\n\n          return new BasicEvaluatedExpression().setIdentifier(name).setRange(expr.range);\n        }\n      });\n      this.hooks.evaluate[\"for\"](\"MemberExpression\").tap(\"Parser\", function (expression) {\n        var exprName = _this2.getNameForExpression(expression);\n\n        if (exprName) {\n          if (exprName.free) {\n            var hook = _this2.hooks.evaluateIdentifier.get(exprName.name);\n\n            if (hook !== undefined) {\n              var result = hook.call(expression);\n              if (result) return result;\n            }\n\n            return new BasicEvaluatedExpression().setIdentifier(exprName.name).setRange(expression.range);\n          } else {\n            var _hook3 = _this2.hooks.evaluateDefinedIdentifier.get(exprName.name);\n\n            if (_hook3 !== undefined) {\n              return _hook3.call(expression);\n            }\n          }\n        }\n      });\n      this.hooks.evaluate[\"for\"](\"CallExpression\").tap(\"Parser\", function (expr) {\n        if (expr.callee.type !== \"MemberExpression\") return;\n        if (expr.callee.property.type !== (expr.callee.computed ? \"Literal\" : \"Identifier\")) return;\n\n        var param = _this2.evaluateExpression(expr.callee.object);\n\n        if (!param) return;\n        var property = expr.callee.property.name || expr.callee.property.value;\n\n        var hook = _this2.hooks.evaluateCallExpressionMember.get(property);\n\n        if (hook !== undefined) {\n          return hook.call(expr, param);\n        }\n      });\n      this.hooks.evaluateCallExpressionMember[\"for\"](\"replace\").tap(\"Parser\", function (expr, param) {\n        if (!param.isString()) return;\n        if (expr.arguments.length !== 2) return;\n\n        var arg1 = _this2.evaluateExpression(expr.arguments[0]);\n\n        var arg2 = _this2.evaluateExpression(expr.arguments[1]);\n\n        if (!arg1.isString() && !arg1.isRegExp()) return;\n        arg1 = arg1.regExp || arg1.string;\n        if (!arg2.isString()) return;\n        arg2 = arg2.string;\n        return new BasicEvaluatedExpression().setString(param.string.replace(arg1, arg2)).setRange(expr.range);\n      });\n      [\"substr\", \"substring\"].forEach(function (fn) {\n        _this2.hooks.evaluateCallExpressionMember[\"for\"](fn).tap(\"Parser\", function (expr, param) {\n          if (!param.isString()) return;\n          var arg1;\n          var result,\n              str = param.string;\n\n          switch (expr.arguments.length) {\n            case 1:\n              arg1 = _this2.evaluateExpression(expr.arguments[0]);\n              if (!arg1.isNumber()) return;\n              result = str[fn](arg1.number);\n              break;\n\n            case 2:\n              {\n                arg1 = _this2.evaluateExpression(expr.arguments[0]);\n\n                var arg2 = _this2.evaluateExpression(expr.arguments[1]);\n\n                if (!arg1.isNumber()) return;\n                if (!arg2.isNumber()) return;\n                result = str[fn](arg1.number, arg2.number);\n                break;\n              }\n\n            default:\n              return;\n          }\n\n          return new BasicEvaluatedExpression().setString(result).setRange(expr.range);\n        });\n      });\n      /**\n       * @param {string} kind \"cooked\" | \"raw\"\n       * @param {TODO} templateLiteralExpr TemplateLiteral expr\n       * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template\n       */\n\n      var getSimplifiedTemplateResult = function getSimplifiedTemplateResult(kind, templateLiteralExpr) {\n        var quasis = [];\n        var parts = [];\n\n        for (var i = 0; i < templateLiteralExpr.quasis.length; i++) {\n          var quasiExpr = templateLiteralExpr.quasis[i];\n          var quasi = quasiExpr.value[kind];\n\n          if (i > 0) {\n            var prevExpr = parts[parts.length - 1];\n\n            var expr = _this2.evaluateExpression(templateLiteralExpr.expressions[i - 1]);\n\n            var exprAsString = expr.asString();\n\n            if (typeof exprAsString === \"string\") {\n              // We can merge quasi + expr + quasi when expr\n              // is a const string\n              prevExpr.setString(prevExpr.string + exprAsString + quasi);\n              prevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]); // We unset the expression as it doesn't match to a single expression\n\n              prevExpr.setExpression(undefined);\n              continue;\n            }\n\n            parts.push(expr);\n          }\n\n          var part = new BasicEvaluatedExpression().setString(quasi).setRange(quasiExpr.range).setExpression(quasiExpr);\n          quasis.push(part);\n          parts.push(part);\n        }\n\n        return {\n          quasis: quasis,\n          parts: parts\n        };\n      };\n\n      this.hooks.evaluate[\"for\"](\"TemplateLiteral\").tap(\"Parser\", function (node) {\n        var _getSimplifiedTemplat = getSimplifiedTemplateResult(\"cooked\", node),\n            quasis = _getSimplifiedTemplat.quasis,\n            parts = _getSimplifiedTemplat.parts;\n\n        if (parts.length === 1) {\n          return parts[0].setRange(node.range);\n        }\n\n        return new BasicEvaluatedExpression().setTemplateString(quasis, parts, \"cooked\").setRange(node.range);\n      });\n      this.hooks.evaluate[\"for\"](\"TaggedTemplateExpression\").tap(\"Parser\", function (node) {\n        if (_this2.evaluateExpression(node.tag).identifier !== \"String.raw\") return;\n\n        var _getSimplifiedTemplat2 = getSimplifiedTemplateResult(\"raw\", node.quasi),\n            quasis = _getSimplifiedTemplat2.quasis,\n            parts = _getSimplifiedTemplat2.parts;\n\n        if (parts.length === 1) {\n          return parts[0].setRange(node.range);\n        }\n\n        return new BasicEvaluatedExpression().setTemplateString(quasis, parts, \"raw\").setRange(node.range);\n      });\n      this.hooks.evaluateCallExpressionMember[\"for\"](\"concat\").tap(\"Parser\", function (expr, param) {\n        if (!param.isString() && !param.isWrapped()) return;\n        var stringSuffix = null;\n        var hasUnknownParams = false;\n\n        for (var i = expr.arguments.length - 1; i >= 0; i--) {\n          var argExpr = _this2.evaluateExpression(expr.arguments[i]);\n\n          if (!argExpr.isString() && !argExpr.isNumber()) {\n            hasUnknownParams = true;\n            break;\n          }\n\n          var value = argExpr.isString() ? argExpr.string : \"\" + argExpr.number;\n          var newString = value + (stringSuffix ? stringSuffix.string : \"\");\n          var newRange = [argExpr.range[0], (stringSuffix || argExpr).range[1]];\n          stringSuffix = new BasicEvaluatedExpression().setString(newString).setRange(newRange);\n        }\n\n        if (hasUnknownParams) {\n          var prefix = param.isString() ? param : param.prefix;\n          return new BasicEvaluatedExpression().setWrapped(prefix, stringSuffix).setRange(expr.range);\n        } else if (param.isWrapped()) {\n          var postfix = stringSuffix || param.postfix;\n          return new BasicEvaluatedExpression().setWrapped(param.prefix, postfix).setRange(expr.range);\n        } else {\n          var _newString = param.string + (stringSuffix ? stringSuffix.string : \"\");\n\n          return new BasicEvaluatedExpression().setString(_newString).setRange(expr.range);\n        }\n      });\n      this.hooks.evaluateCallExpressionMember[\"for\"](\"split\").tap(\"Parser\", function (expr, param) {\n        if (!param.isString()) return;\n        if (expr.arguments.length !== 1) return;\n        var result;\n\n        var arg = _this2.evaluateExpression(expr.arguments[0]);\n\n        if (arg.isString()) {\n          result = param.string.split(arg.string);\n        } else if (arg.isRegExp()) {\n          result = param.string.split(arg.regExp);\n        } else {\n          return;\n        }\n\n        return new BasicEvaluatedExpression().setArray(result).setRange(expr.range);\n      });\n      this.hooks.evaluate[\"for\"](\"ConditionalExpression\").tap(\"Parser\", function (expr) {\n        var condition = _this2.evaluateExpression(expr.test);\n\n        var conditionValue = condition.asBool();\n        var res;\n\n        if (conditionValue === undefined) {\n          var consequent = _this2.evaluateExpression(expr.consequent);\n\n          var alternate = _this2.evaluateExpression(expr.alternate);\n\n          if (!consequent || !alternate) return;\n          res = new BasicEvaluatedExpression();\n\n          if (consequent.isConditional()) {\n            res.setOptions(consequent.options);\n          } else {\n            res.setOptions([consequent]);\n          }\n\n          if (alternate.isConditional()) {\n            res.addOptions(alternate.options);\n          } else {\n            res.addOptions([alternate]);\n          }\n        } else {\n          res = _this2.evaluateExpression(conditionValue ? expr.consequent : expr.alternate);\n        }\n\n        res.setRange(expr.range);\n        return res;\n      });\n      this.hooks.evaluate[\"for\"](\"ArrayExpression\").tap(\"Parser\", function (expr) {\n        var items = expr.elements.map(function (element) {\n          return element !== null && _this2.evaluateExpression(element);\n        });\n        if (!items.every(Boolean)) return;\n        return new BasicEvaluatedExpression().setItems(items).setRange(expr.range);\n      });\n    }\n  }, {\n    key: \"getRenameIdentifier\",\n    value: function getRenameIdentifier(expr) {\n      var result = this.evaluateExpression(expr);\n\n      if (result && result.isIdentifier()) {\n        return result.identifier;\n      }\n    }\n  }, {\n    key: \"walkClass\",\n    value: function walkClass(classy) {\n      if (classy.superClass) this.walkExpression(classy.superClass);\n\n      if (classy.body && classy.body.type === \"ClassBody\") {\n        var wasTopLevel = this.scope.topLevelScope;\n        this.scope.topLevelScope = false;\n\n        var _iterator = _createForOfIteratorHelper(classy.body.body),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var methodDefinition = _step.value;\n\n            if (methodDefinition.type === \"MethodDefinition\") {\n              this.walkMethodDefinition(methodDefinition);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        this.scope.topLevelScope = wasTopLevel;\n      }\n    }\n  }, {\n    key: \"walkMethodDefinition\",\n    value: function walkMethodDefinition(methodDefinition) {\n      if (methodDefinition.computed && methodDefinition.key) {\n        this.walkExpression(methodDefinition.key);\n      }\n\n      if (methodDefinition.value) {\n        this.walkExpression(methodDefinition.value);\n      }\n    } // Prewalking iterates the scope for variable declarations\n\n  }, {\n    key: \"prewalkStatements\",\n    value: function prewalkStatements(statements) {\n      for (var index = 0, len = statements.length; index < len; index++) {\n        var statement = statements[index];\n        this.prewalkStatement(statement);\n      }\n    } // Block-Prewalking iterates the scope for block variable declarations\n\n  }, {\n    key: \"blockPrewalkStatements\",\n    value: function blockPrewalkStatements(statements) {\n      for (var index = 0, len = statements.length; index < len; index++) {\n        var statement = statements[index];\n        this.blockPrewalkStatement(statement);\n      }\n    } // Walking iterates the statements and expressions and processes them\n\n  }, {\n    key: \"walkStatements\",\n    value: function walkStatements(statements) {\n      for (var index = 0, len = statements.length; index < len; index++) {\n        var statement = statements[index];\n        this.walkStatement(statement);\n      }\n    }\n  }, {\n    key: \"prewalkStatement\",\n    value: function prewalkStatement(statement) {\n      switch (statement.type) {\n        case \"BlockStatement\":\n          this.prewalkBlockStatement(statement);\n          break;\n\n        case \"DoWhileStatement\":\n          this.prewalkDoWhileStatement(statement);\n          break;\n\n        case \"ExportAllDeclaration\":\n          this.prewalkExportAllDeclaration(statement);\n          break;\n\n        case \"ExportDefaultDeclaration\":\n          this.prewalkExportDefaultDeclaration(statement);\n          break;\n\n        case \"ExportNamedDeclaration\":\n          this.prewalkExportNamedDeclaration(statement);\n          break;\n\n        case \"ForInStatement\":\n          this.prewalkForInStatement(statement);\n          break;\n\n        case \"ForOfStatement\":\n          this.prewalkForOfStatement(statement);\n          break;\n\n        case \"ForStatement\":\n          this.prewalkForStatement(statement);\n          break;\n\n        case \"FunctionDeclaration\":\n          this.prewalkFunctionDeclaration(statement);\n          break;\n\n        case \"IfStatement\":\n          this.prewalkIfStatement(statement);\n          break;\n\n        case \"ImportDeclaration\":\n          this.prewalkImportDeclaration(statement);\n          break;\n\n        case \"LabeledStatement\":\n          this.prewalkLabeledStatement(statement);\n          break;\n\n        case \"SwitchStatement\":\n          this.prewalkSwitchStatement(statement);\n          break;\n\n        case \"TryStatement\":\n          this.prewalkTryStatement(statement);\n          break;\n\n        case \"VariableDeclaration\":\n          this.prewalkVariableDeclaration(statement);\n          break;\n\n        case \"WhileStatement\":\n          this.prewalkWhileStatement(statement);\n          break;\n\n        case \"WithStatement\":\n          this.prewalkWithStatement(statement);\n          break;\n      }\n    }\n  }, {\n    key: \"blockPrewalkStatement\",\n    value: function blockPrewalkStatement(statement) {\n      switch (statement.type) {\n        case \"VariableDeclaration\":\n          this.blockPrewalkVariableDeclaration(statement);\n          break;\n\n        case \"ExportDefaultDeclaration\":\n          this.blockPrewalkExportDefaultDeclaration(statement);\n          break;\n\n        case \"ExportNamedDeclaration\":\n          this.blockPrewalkExportNamedDeclaration(statement);\n          break;\n\n        case \"ClassDeclaration\":\n          this.blockPrewalkClassDeclaration(statement);\n          break;\n      }\n    }\n  }, {\n    key: \"walkStatement\",\n    value: function walkStatement(statement) {\n      if (this.hooks.statement.call(statement) !== undefined) return;\n\n      switch (statement.type) {\n        case \"BlockStatement\":\n          this.walkBlockStatement(statement);\n          break;\n\n        case \"ClassDeclaration\":\n          this.walkClassDeclaration(statement);\n          break;\n\n        case \"DoWhileStatement\":\n          this.walkDoWhileStatement(statement);\n          break;\n\n        case \"ExportDefaultDeclaration\":\n          this.walkExportDefaultDeclaration(statement);\n          break;\n\n        case \"ExportNamedDeclaration\":\n          this.walkExportNamedDeclaration(statement);\n          break;\n\n        case \"ExpressionStatement\":\n          this.walkExpressionStatement(statement);\n          break;\n\n        case \"ForInStatement\":\n          this.walkForInStatement(statement);\n          break;\n\n        case \"ForOfStatement\":\n          this.walkForOfStatement(statement);\n          break;\n\n        case \"ForStatement\":\n          this.walkForStatement(statement);\n          break;\n\n        case \"FunctionDeclaration\":\n          this.walkFunctionDeclaration(statement);\n          break;\n\n        case \"IfStatement\":\n          this.walkIfStatement(statement);\n          break;\n\n        case \"LabeledStatement\":\n          this.walkLabeledStatement(statement);\n          break;\n\n        case \"ReturnStatement\":\n          this.walkReturnStatement(statement);\n          break;\n\n        case \"SwitchStatement\":\n          this.walkSwitchStatement(statement);\n          break;\n\n        case \"ThrowStatement\":\n          this.walkThrowStatement(statement);\n          break;\n\n        case \"TryStatement\":\n          this.walkTryStatement(statement);\n          break;\n\n        case \"VariableDeclaration\":\n          this.walkVariableDeclaration(statement);\n          break;\n\n        case \"WhileStatement\":\n          this.walkWhileStatement(statement);\n          break;\n\n        case \"WithStatement\":\n          this.walkWithStatement(statement);\n          break;\n      }\n    } // Real Statements\n\n  }, {\n    key: \"prewalkBlockStatement\",\n    value: function prewalkBlockStatement(statement) {\n      this.prewalkStatements(statement.body);\n    }\n  }, {\n    key: \"walkBlockStatement\",\n    value: function walkBlockStatement(statement) {\n      var _this3 = this;\n\n      this.inBlockScope(function () {\n        var body = statement.body;\n\n        _this3.blockPrewalkStatements(body);\n\n        _this3.walkStatements(body);\n      });\n    }\n  }, {\n    key: \"walkExpressionStatement\",\n    value: function walkExpressionStatement(statement) {\n      this.walkExpression(statement.expression);\n    }\n  }, {\n    key: \"prewalkIfStatement\",\n    value: function prewalkIfStatement(statement) {\n      this.prewalkStatement(statement.consequent);\n\n      if (statement.alternate) {\n        this.prewalkStatement(statement.alternate);\n      }\n    }\n  }, {\n    key: \"walkIfStatement\",\n    value: function walkIfStatement(statement) {\n      var result = this.hooks.statementIf.call(statement);\n\n      if (result === undefined) {\n        this.walkExpression(statement.test);\n        this.walkStatement(statement.consequent);\n\n        if (statement.alternate) {\n          this.walkStatement(statement.alternate);\n        }\n      } else {\n        if (result) {\n          this.walkStatement(statement.consequent);\n        } else if (statement.alternate) {\n          this.walkStatement(statement.alternate);\n        }\n      }\n    }\n  }, {\n    key: \"prewalkLabeledStatement\",\n    value: function prewalkLabeledStatement(statement) {\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkLabeledStatement\",\n    value: function walkLabeledStatement(statement) {\n      var hook = this.hooks.label.get(statement.label.name);\n\n      if (hook !== undefined) {\n        var result = hook.call(statement);\n        if (result === true) return;\n      }\n\n      this.walkStatement(statement.body);\n    }\n  }, {\n    key: \"prewalkWithStatement\",\n    value: function prewalkWithStatement(statement) {\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkWithStatement\",\n    value: function walkWithStatement(statement) {\n      this.walkExpression(statement.object);\n      this.walkStatement(statement.body);\n    }\n  }, {\n    key: \"prewalkSwitchStatement\",\n    value: function prewalkSwitchStatement(statement) {\n      this.prewalkSwitchCases(statement.cases);\n    }\n  }, {\n    key: \"walkSwitchStatement\",\n    value: function walkSwitchStatement(statement) {\n      this.walkExpression(statement.discriminant);\n      this.walkSwitchCases(statement.cases);\n    }\n  }, {\n    key: \"walkTerminatingStatement\",\n    value: function walkTerminatingStatement(statement) {\n      if (statement.argument) this.walkExpression(statement.argument);\n    }\n  }, {\n    key: \"walkReturnStatement\",\n    value: function walkReturnStatement(statement) {\n      this.walkTerminatingStatement(statement);\n    }\n  }, {\n    key: \"walkThrowStatement\",\n    value: function walkThrowStatement(statement) {\n      this.walkTerminatingStatement(statement);\n    }\n  }, {\n    key: \"prewalkTryStatement\",\n    value: function prewalkTryStatement(statement) {\n      this.prewalkStatement(statement.block);\n    }\n  }, {\n    key: \"walkTryStatement\",\n    value: function walkTryStatement(statement) {\n      if (this.scope.inTry) {\n        this.walkStatement(statement.block);\n      } else {\n        this.scope.inTry = true;\n        this.walkStatement(statement.block);\n        this.scope.inTry = false;\n      }\n\n      if (statement.handler) this.walkCatchClause(statement.handler);\n      if (statement.finalizer) this.walkStatement(statement.finalizer);\n    }\n  }, {\n    key: \"prewalkWhileStatement\",\n    value: function prewalkWhileStatement(statement) {\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkWhileStatement\",\n    value: function walkWhileStatement(statement) {\n      this.walkExpression(statement.test);\n      this.walkStatement(statement.body);\n    }\n  }, {\n    key: \"prewalkDoWhileStatement\",\n    value: function prewalkDoWhileStatement(statement) {\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkDoWhileStatement\",\n    value: function walkDoWhileStatement(statement) {\n      this.walkStatement(statement.body);\n      this.walkExpression(statement.test);\n    }\n  }, {\n    key: \"prewalkForStatement\",\n    value: function prewalkForStatement(statement) {\n      if (statement.init) {\n        if (statement.init.type === \"VariableDeclaration\") {\n          this.prewalkStatement(statement.init);\n        }\n      }\n\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkForStatement\",\n    value: function walkForStatement(statement) {\n      var _this4 = this;\n\n      this.inBlockScope(function () {\n        if (statement.init) {\n          if (statement.init.type === \"VariableDeclaration\") {\n            _this4.blockPrewalkVariableDeclaration(statement.init);\n\n            _this4.walkStatement(statement.init);\n          } else {\n            _this4.walkExpression(statement.init);\n          }\n        }\n\n        if (statement.test) {\n          _this4.walkExpression(statement.test);\n        }\n\n        if (statement.update) {\n          _this4.walkExpression(statement.update);\n        }\n\n        var body = statement.body;\n\n        if (body.type === \"BlockStatement\") {\n          // no need to add additional scope\n          _this4.blockPrewalkStatements(body.body);\n\n          _this4.walkStatements(body.body);\n        } else {\n          _this4.walkStatement(body);\n        }\n      });\n    }\n  }, {\n    key: \"prewalkForInStatement\",\n    value: function prewalkForInStatement(statement) {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.prewalkVariableDeclaration(statement.left);\n      }\n\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkForInStatement\",\n    value: function walkForInStatement(statement) {\n      var _this5 = this;\n\n      this.inBlockScope(function () {\n        if (statement.left.type === \"VariableDeclaration\") {\n          _this5.blockPrewalkVariableDeclaration(statement.left);\n\n          _this5.walkVariableDeclaration(statement.left);\n        } else {\n          _this5.walkPattern(statement.left);\n        }\n\n        _this5.walkExpression(statement.right);\n\n        var body = statement.body;\n\n        if (body.type === \"BlockStatement\") {\n          // no need to add additional scope\n          _this5.blockPrewalkStatements(body.body);\n\n          _this5.walkStatements(body.body);\n        } else {\n          _this5.walkStatement(body);\n        }\n      });\n    }\n  }, {\n    key: \"prewalkForOfStatement\",\n    value: function prewalkForOfStatement(statement) {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.prewalkVariableDeclaration(statement.left);\n      }\n\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkForOfStatement\",\n    value: function walkForOfStatement(statement) {\n      var _this6 = this;\n\n      this.inBlockScope(function () {\n        if (statement.left.type === \"VariableDeclaration\") {\n          _this6.blockPrewalkVariableDeclaration(statement.left);\n\n          _this6.walkVariableDeclaration(statement.left);\n        } else {\n          _this6.walkPattern(statement.left);\n        }\n\n        _this6.walkExpression(statement.right);\n\n        var body = statement.body;\n\n        if (body.type === \"BlockStatement\") {\n          // no need to add additional scope\n          _this6.blockPrewalkStatements(body.body);\n\n          _this6.walkStatements(body.body);\n        } else {\n          _this6.walkStatement(body);\n        }\n      });\n    } // Declarations\n\n  }, {\n    key: \"prewalkFunctionDeclaration\",\n    value: function prewalkFunctionDeclaration(statement) {\n      if (statement.id) {\n        this.scope.renames.set(statement.id.name, null);\n        this.scope.definitions.add(statement.id.name);\n      }\n    }\n  }, {\n    key: \"walkFunctionDeclaration\",\n    value: function walkFunctionDeclaration(statement) {\n      var _this7 = this;\n\n      var wasTopLevel = this.scope.topLevelScope;\n      this.scope.topLevelScope = false;\n      this.inFunctionScope(true, statement.params, function () {\n        var _iterator2 = _createForOfIteratorHelper(statement.params),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var param = _step2.value;\n\n            _this7.walkPattern(param);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        if (statement.body.type === \"BlockStatement\") {\n          _this7.detectMode(statement.body.body);\n\n          _this7.prewalkStatement(statement.body);\n\n          _this7.walkStatement(statement.body);\n        } else {\n          _this7.walkExpression(statement.body);\n        }\n      });\n      this.scope.topLevelScope = wasTopLevel;\n    }\n  }, {\n    key: \"prewalkImportDeclaration\",\n    value: function prewalkImportDeclaration(statement) {\n      var source = statement.source.value;\n      this.hooks[\"import\"].call(statement, source);\n\n      var _iterator3 = _createForOfIteratorHelper(statement.specifiers),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var specifier = _step3.value;\n          var name = specifier.local.name;\n          this.scope.renames.set(name, null);\n          this.scope.definitions.add(name);\n\n          switch (specifier.type) {\n            case \"ImportDefaultSpecifier\":\n              this.hooks.importSpecifier.call(statement, source, \"default\", name);\n              break;\n\n            case \"ImportSpecifier\":\n              this.hooks.importSpecifier.call(statement, source, specifier.imported.name, name);\n              break;\n\n            case \"ImportNamespaceSpecifier\":\n              this.hooks.importSpecifier.call(statement, source, null, name);\n              break;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"enterDeclaration\",\n    value: function enterDeclaration(declaration, onIdent) {\n      switch (declaration.type) {\n        case \"VariableDeclaration\":\n          var _iterator4 = _createForOfIteratorHelper(declaration.declarations),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var declarator = _step4.value;\n\n              switch (declarator.type) {\n                case \"VariableDeclarator\":\n                  {\n                    this.enterPattern(declarator.id, onIdent);\n                    break;\n                  }\n              }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n\n          break;\n\n        case \"FunctionDeclaration\":\n          this.enterPattern(declaration.id, onIdent);\n          break;\n\n        case \"ClassDeclaration\":\n          this.enterPattern(declaration.id, onIdent);\n          break;\n      }\n    }\n  }, {\n    key: \"blockPrewalkExportNamedDeclaration\",\n    value: function blockPrewalkExportNamedDeclaration(statement) {\n      if (statement.declaration) {\n        this.blockPrewalkStatement(statement.declaration);\n      }\n    }\n  }, {\n    key: \"prewalkExportNamedDeclaration\",\n    value: function prewalkExportNamedDeclaration(statement) {\n      var _this8 = this;\n\n      var source;\n\n      if (statement.source) {\n        source = statement.source.value;\n        this.hooks.exportImport.call(statement, source);\n      } else {\n        this.hooks[\"export\"].call(statement);\n      }\n\n      if (statement.declaration) {\n        if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {\n          this.prewalkStatement(statement.declaration);\n          var index = 0;\n          this.enterDeclaration(statement.declaration, function (def) {\n            _this8.hooks.exportSpecifier.call(statement, def, def, index++);\n          });\n        }\n      }\n\n      if (statement.specifiers) {\n        for (var specifierIndex = 0; specifierIndex < statement.specifiers.length; specifierIndex++) {\n          var specifier = statement.specifiers[specifierIndex];\n\n          switch (specifier.type) {\n            case \"ExportSpecifier\":\n              {\n                var name = specifier.exported.name;\n\n                if (source) {\n                  this.hooks.exportImportSpecifier.call(statement, source, specifier.local.name, name, specifierIndex);\n                } else {\n                  this.hooks.exportSpecifier.call(statement, specifier.local.name, name, specifierIndex);\n                }\n\n                break;\n              }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"walkExportNamedDeclaration\",\n    value: function walkExportNamedDeclaration(statement) {\n      if (statement.declaration) {\n        this.walkStatement(statement.declaration);\n      }\n    }\n  }, {\n    key: \"blockPrewalkExportDefaultDeclaration\",\n    value: function blockPrewalkExportDefaultDeclaration(statement) {\n      if (statement.declaration.type === \"ClassDeclaration\") {\n        this.blockPrewalkClassDeclaration(statement.declaration);\n      }\n    }\n  }, {\n    key: \"prewalkExportDefaultDeclaration\",\n    value: function prewalkExportDefaultDeclaration(statement) {\n      this.prewalkStatement(statement.declaration);\n\n      if (statement.declaration.id && statement.declaration.type !== \"FunctionExpression\" && statement.declaration.type !== \"ClassExpression\") {\n        this.hooks.exportSpecifier.call(statement, statement.declaration.id.name, \"default\");\n      }\n    }\n  }, {\n    key: \"walkExportDefaultDeclaration\",\n    value: function walkExportDefaultDeclaration(statement) {\n      this.hooks[\"export\"].call(statement);\n\n      if (statement.declaration.id && statement.declaration.type !== \"FunctionExpression\" && statement.declaration.type !== \"ClassExpression\") {\n        if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {\n          this.walkStatement(statement.declaration);\n        }\n      } else {\n        // Acorn parses `export default function() {}` as `FunctionDeclaration` and\n        // `export default class {}` as `ClassDeclaration`, both with `id = null`.\n        // These nodes must be treated as expressions.\n        if (statement.declaration.type === \"FunctionDeclaration\") {\n          this.walkFunctionDeclaration(statement.declaration);\n        } else if (statement.declaration.type === \"ClassDeclaration\") {\n          this.walkClassDeclaration(statement.declaration);\n        } else {\n          this.walkExpression(statement.declaration);\n        }\n\n        if (!this.hooks.exportExpression.call(statement, statement.declaration)) {\n          this.hooks.exportSpecifier.call(statement, statement.declaration, \"default\");\n        }\n      }\n    }\n  }, {\n    key: \"prewalkExportAllDeclaration\",\n    value: function prewalkExportAllDeclaration(statement) {\n      var source = statement.source.value;\n      this.hooks.exportImport.call(statement, source);\n      this.hooks.exportImportSpecifier.call(statement, source, null, null, 0);\n    }\n  }, {\n    key: \"prewalkVariableDeclaration\",\n    value: function prewalkVariableDeclaration(statement) {\n      if (statement.kind !== \"var\") return;\n\n      this._prewalkVariableDeclaration(statement, this.hooks.varDeclarationVar);\n    }\n  }, {\n    key: \"blockPrewalkVariableDeclaration\",\n    value: function blockPrewalkVariableDeclaration(statement) {\n      if (statement.kind === \"var\") return;\n      var hookMap = statement.kind === \"const\" ? this.hooks.varDeclarationConst : this.hooks.varDeclarationLet;\n\n      this._prewalkVariableDeclaration(statement, hookMap);\n    }\n  }, {\n    key: \"_prewalkVariableDeclaration\",\n    value: function _prewalkVariableDeclaration(statement, hookMap) {\n      var _this9 = this;\n\n      var _iterator5 = _createForOfIteratorHelper(statement.declarations),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var declarator = _step5.value;\n\n          switch (declarator.type) {\n            case \"VariableDeclarator\":\n              {\n                this.enterPattern(declarator.id, function (name, decl) {\n                  var hook = hookMap.get(name);\n\n                  if (hook === undefined || !hook.call(decl)) {\n                    hook = _this9.hooks.varDeclaration.get(name);\n\n                    if (hook === undefined || !hook.call(decl)) {\n                      _this9.scope.renames.set(name, null);\n\n                      _this9.scope.definitions.add(name);\n                    }\n                  }\n                });\n                break;\n              }\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  }, {\n    key: \"walkVariableDeclaration\",\n    value: function walkVariableDeclaration(statement) {\n      var _iterator6 = _createForOfIteratorHelper(statement.declarations),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var declarator = _step6.value;\n\n          switch (declarator.type) {\n            case \"VariableDeclarator\":\n              {\n                var renameIdentifier = declarator.init && this.getRenameIdentifier(declarator.init);\n\n                if (renameIdentifier && declarator.id.type === \"Identifier\") {\n                  var hook = this.hooks.canRename.get(renameIdentifier);\n\n                  if (hook !== undefined && hook.call(declarator.init)) {\n                    // renaming with \"var a = b;\"\n                    var _hook4 = this.hooks.rename.get(renameIdentifier);\n\n                    if (_hook4 === undefined || !_hook4.call(declarator.init)) {\n                      this.scope.renames.set(declarator.id.name, this.scope.renames.get(renameIdentifier) || renameIdentifier);\n                      this.scope.definitions[\"delete\"](declarator.id.name);\n                    }\n\n                    break;\n                  }\n                }\n\n                this.walkPattern(declarator.id);\n                if (declarator.init) this.walkExpression(declarator.init);\n                break;\n              }\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n  }, {\n    key: \"blockPrewalkClassDeclaration\",\n    value: function blockPrewalkClassDeclaration(statement) {\n      if (statement.id) {\n        this.scope.renames.set(statement.id.name, null);\n        this.scope.definitions.add(statement.id.name);\n      }\n    }\n  }, {\n    key: \"walkClassDeclaration\",\n    value: function walkClassDeclaration(statement) {\n      this.walkClass(statement);\n    }\n  }, {\n    key: \"prewalkSwitchCases\",\n    value: function prewalkSwitchCases(switchCases) {\n      for (var index = 0, len = switchCases.length; index < len; index++) {\n        var switchCase = switchCases[index];\n        this.prewalkStatements(switchCase.consequent);\n      }\n    }\n  }, {\n    key: \"walkSwitchCases\",\n    value: function walkSwitchCases(switchCases) {\n      for (var index = 0, len = switchCases.length; index < len; index++) {\n        var switchCase = switchCases[index];\n\n        if (switchCase.test) {\n          this.walkExpression(switchCase.test);\n        }\n\n        this.walkStatements(switchCase.consequent);\n      }\n    }\n  }, {\n    key: \"walkCatchClause\",\n    value: function walkCatchClause(catchClause) {\n      var _this10 = this;\n\n      this.inBlockScope(function () {\n        // Error binding is optional in catch clause since ECMAScript 2019\n        if (catchClause.param !== null) {\n          _this10.enterPattern(catchClause.param, function (ident) {\n            _this10.scope.renames.set(ident, null);\n\n            _this10.scope.definitions.add(ident);\n          });\n\n          _this10.walkPattern(catchClause.param);\n        }\n\n        _this10.prewalkStatement(catchClause.body);\n\n        _this10.walkStatement(catchClause.body);\n      });\n    }\n  }, {\n    key: \"walkPattern\",\n    value: function walkPattern(pattern) {\n      switch (pattern.type) {\n        case \"ArrayPattern\":\n          this.walkArrayPattern(pattern);\n          break;\n\n        case \"AssignmentPattern\":\n          this.walkAssignmentPattern(pattern);\n          break;\n\n        case \"MemberExpression\":\n          this.walkMemberExpression(pattern);\n          break;\n\n        case \"ObjectPattern\":\n          this.walkObjectPattern(pattern);\n          break;\n\n        case \"RestElement\":\n          this.walkRestElement(pattern);\n          break;\n      }\n    }\n  }, {\n    key: \"walkAssignmentPattern\",\n    value: function walkAssignmentPattern(pattern) {\n      this.walkExpression(pattern.right);\n      this.walkPattern(pattern.left);\n    }\n  }, {\n    key: \"walkObjectPattern\",\n    value: function walkObjectPattern(pattern) {\n      for (var i = 0, len = pattern.properties.length; i < len; i++) {\n        var prop = pattern.properties[i];\n\n        if (prop) {\n          if (prop.computed) this.walkExpression(prop.key);\n          if (prop.value) this.walkPattern(prop.value);\n        }\n      }\n    }\n  }, {\n    key: \"walkArrayPattern\",\n    value: function walkArrayPattern(pattern) {\n      for (var i = 0, len = pattern.elements.length; i < len; i++) {\n        var element = pattern.elements[i];\n        if (element) this.walkPattern(element);\n      }\n    }\n  }, {\n    key: \"walkRestElement\",\n    value: function walkRestElement(pattern) {\n      this.walkPattern(pattern.argument);\n    }\n  }, {\n    key: \"walkExpressions\",\n    value: function walkExpressions(expressions) {\n      var _iterator7 = _createForOfIteratorHelper(expressions),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var expression = _step7.value;\n\n          if (expression) {\n            this.walkExpression(expression);\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  }, {\n    key: \"walkExpression\",\n    value: function walkExpression(expression) {\n      switch (expression.type) {\n        case \"ArrayExpression\":\n          this.walkArrayExpression(expression);\n          break;\n\n        case \"ArrowFunctionExpression\":\n          this.walkArrowFunctionExpression(expression);\n          break;\n\n        case \"AssignmentExpression\":\n          this.walkAssignmentExpression(expression);\n          break;\n\n        case \"AwaitExpression\":\n          this.walkAwaitExpression(expression);\n          break;\n\n        case \"BinaryExpression\":\n          this.walkBinaryExpression(expression);\n          break;\n\n        case \"CallExpression\":\n          this.walkCallExpression(expression);\n          break;\n\n        case \"ClassExpression\":\n          this.walkClassExpression(expression);\n          break;\n\n        case \"ConditionalExpression\":\n          this.walkConditionalExpression(expression);\n          break;\n\n        case \"FunctionExpression\":\n          this.walkFunctionExpression(expression);\n          break;\n\n        case \"Identifier\":\n          this.walkIdentifier(expression);\n          break;\n\n        case \"LogicalExpression\":\n          this.walkLogicalExpression(expression);\n          break;\n\n        case \"MemberExpression\":\n          this.walkMemberExpression(expression);\n          break;\n\n        case \"NewExpression\":\n          this.walkNewExpression(expression);\n          break;\n\n        case \"ObjectExpression\":\n          this.walkObjectExpression(expression);\n          break;\n\n        case \"SequenceExpression\":\n          this.walkSequenceExpression(expression);\n          break;\n\n        case \"SpreadElement\":\n          this.walkSpreadElement(expression);\n          break;\n\n        case \"TaggedTemplateExpression\":\n          this.walkTaggedTemplateExpression(expression);\n          break;\n\n        case \"TemplateLiteral\":\n          this.walkTemplateLiteral(expression);\n          break;\n\n        case \"ThisExpression\":\n          this.walkThisExpression(expression);\n          break;\n\n        case \"UnaryExpression\":\n          this.walkUnaryExpression(expression);\n          break;\n\n        case \"UpdateExpression\":\n          this.walkUpdateExpression(expression);\n          break;\n\n        case \"YieldExpression\":\n          this.walkYieldExpression(expression);\n          break;\n      }\n    }\n  }, {\n    key: \"walkAwaitExpression\",\n    value: function walkAwaitExpression(expression) {\n      this.walkExpression(expression.argument);\n    }\n  }, {\n    key: \"walkArrayExpression\",\n    value: function walkArrayExpression(expression) {\n      if (expression.elements) {\n        this.walkExpressions(expression.elements);\n      }\n    }\n  }, {\n    key: \"walkSpreadElement\",\n    value: function walkSpreadElement(expression) {\n      if (expression.argument) {\n        this.walkExpression(expression.argument);\n      }\n    }\n  }, {\n    key: \"walkObjectExpression\",\n    value: function walkObjectExpression(expression) {\n      for (var propIndex = 0, len = expression.properties.length; propIndex < len; propIndex++) {\n        var prop = expression.properties[propIndex];\n\n        if (prop.type === \"SpreadElement\") {\n          this.walkExpression(prop.argument);\n          continue;\n        }\n\n        if (prop.computed) {\n          this.walkExpression(prop.key);\n        }\n\n        if (prop.shorthand) {\n          this.scope.inShorthand = true;\n        }\n\n        this.walkExpression(prop.value);\n\n        if (prop.shorthand) {\n          this.scope.inShorthand = false;\n        }\n      }\n    }\n  }, {\n    key: \"walkFunctionExpression\",\n    value: function walkFunctionExpression(expression) {\n      var _this11 = this;\n\n      var wasTopLevel = this.scope.topLevelScope;\n      this.scope.topLevelScope = false;\n      var scopeParams = expression.params; // Add function name in scope for recursive calls\n\n      if (expression.id) {\n        scopeParams.push(expression.id.name);\n      }\n\n      this.inFunctionScope(true, scopeParams, function () {\n        var _iterator8 = _createForOfIteratorHelper(expression.params),\n            _step8;\n\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var param = _step8.value;\n\n            _this11.walkPattern(param);\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n\n        if (expression.body.type === \"BlockStatement\") {\n          _this11.detectMode(expression.body.body);\n\n          _this11.prewalkStatement(expression.body);\n\n          _this11.walkStatement(expression.body);\n        } else {\n          _this11.walkExpression(expression.body);\n        }\n      });\n      this.scope.topLevelScope = wasTopLevel;\n    }\n  }, {\n    key: \"walkArrowFunctionExpression\",\n    value: function walkArrowFunctionExpression(expression) {\n      var _this12 = this;\n\n      this.inFunctionScope(false, expression.params, function () {\n        var _iterator9 = _createForOfIteratorHelper(expression.params),\n            _step9;\n\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var param = _step9.value;\n\n            _this12.walkPattern(param);\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n\n        if (expression.body.type === \"BlockStatement\") {\n          _this12.detectMode(expression.body.body);\n\n          _this12.prewalkStatement(expression.body);\n\n          _this12.walkStatement(expression.body);\n        } else {\n          _this12.walkExpression(expression.body);\n        }\n      });\n    }\n  }, {\n    key: \"walkSequenceExpression\",\n    value: function walkSequenceExpression(expression) {\n      if (expression.expressions) this.walkExpressions(expression.expressions);\n    }\n  }, {\n    key: \"walkUpdateExpression\",\n    value: function walkUpdateExpression(expression) {\n      this.walkExpression(expression.argument);\n    }\n  }, {\n    key: \"walkUnaryExpression\",\n    value: function walkUnaryExpression(expression) {\n      if (expression.operator === \"typeof\") {\n        var exprName = this.getNameForExpression(expression.argument);\n\n        if (exprName && exprName.free) {\n          var hook = this.hooks[\"typeof\"].get(exprName.name);\n\n          if (hook !== undefined) {\n            var result = hook.call(expression);\n            if (result === true) return;\n          }\n        }\n      }\n\n      this.walkExpression(expression.argument);\n    }\n  }, {\n    key: \"walkLeftRightExpression\",\n    value: function walkLeftRightExpression(expression) {\n      this.walkExpression(expression.left);\n      this.walkExpression(expression.right);\n    }\n  }, {\n    key: \"walkBinaryExpression\",\n    value: function walkBinaryExpression(expression) {\n      this.walkLeftRightExpression(expression);\n    }\n  }, {\n    key: \"walkLogicalExpression\",\n    value: function walkLogicalExpression(expression) {\n      var result = this.hooks.expressionLogicalOperator.call(expression);\n\n      if (result === undefined) {\n        this.walkLeftRightExpression(expression);\n      } else {\n        if (result) {\n          this.walkExpression(expression.right);\n        }\n      }\n    }\n  }, {\n    key: \"walkAssignmentExpression\",\n    value: function walkAssignmentExpression(expression) {\n      var _this13 = this;\n\n      var renameIdentifier = this.getRenameIdentifier(expression.right);\n\n      if (expression.left.type === \"Identifier\" && renameIdentifier) {\n        var hook = this.hooks.canRename.get(renameIdentifier);\n\n        if (hook !== undefined && hook.call(expression.right)) {\n          // renaming \"a = b;\"\n          var _hook5 = this.hooks.rename.get(renameIdentifier);\n\n          if (_hook5 === undefined || !_hook5.call(expression.right)) {\n            this.scope.renames.set(expression.left.name, renameIdentifier);\n            this.scope.definitions[\"delete\"](expression.left.name);\n          }\n\n          return;\n        }\n      }\n\n      if (expression.left.type === \"Identifier\") {\n        var assignedHook = this.hooks.assigned.get(expression.left.name);\n\n        if (assignedHook === undefined || !assignedHook.call(expression)) {\n          this.walkExpression(expression.right);\n        }\n\n        this.scope.renames.set(expression.left.name, null);\n        var assignHook = this.hooks.assign.get(expression.left.name);\n\n        if (assignHook === undefined || !assignHook.call(expression)) {\n          this.walkExpression(expression.left);\n        }\n\n        return;\n      }\n\n      this.walkExpression(expression.right);\n      this.walkPattern(expression.left);\n      this.enterPattern(expression.left, function (name, decl) {\n        _this13.scope.renames.set(name, null);\n      });\n    }\n  }, {\n    key: \"walkConditionalExpression\",\n    value: function walkConditionalExpression(expression) {\n      var result = this.hooks.expressionConditionalOperator.call(expression);\n\n      if (result === undefined) {\n        this.walkExpression(expression.test);\n        this.walkExpression(expression.consequent);\n\n        if (expression.alternate) {\n          this.walkExpression(expression.alternate);\n        }\n      } else {\n        if (result) {\n          this.walkExpression(expression.consequent);\n        } else if (expression.alternate) {\n          this.walkExpression(expression.alternate);\n        }\n      }\n    }\n  }, {\n    key: \"walkNewExpression\",\n    value: function walkNewExpression(expression) {\n      var callee = this.evaluateExpression(expression.callee);\n\n      if (callee.isIdentifier()) {\n        var hook = this.hooks[\"new\"].get(callee.identifier);\n\n        if (hook !== undefined) {\n          var result = hook.call(expression);\n\n          if (result === true) {\n            return;\n          }\n        }\n      }\n\n      this.walkExpression(expression.callee);\n\n      if (expression.arguments) {\n        this.walkExpressions(expression.arguments);\n      }\n    }\n  }, {\n    key: \"walkYieldExpression\",\n    value: function walkYieldExpression(expression) {\n      if (expression.argument) {\n        this.walkExpression(expression.argument);\n      }\n    }\n  }, {\n    key: \"walkTemplateLiteral\",\n    value: function walkTemplateLiteral(expression) {\n      if (expression.expressions) {\n        this.walkExpressions(expression.expressions);\n      }\n    }\n  }, {\n    key: \"walkTaggedTemplateExpression\",\n    value: function walkTaggedTemplateExpression(expression) {\n      if (expression.tag) {\n        this.walkExpression(expression.tag);\n      }\n\n      if (expression.quasi && expression.quasi.expressions) {\n        this.walkExpressions(expression.quasi.expressions);\n      }\n    }\n  }, {\n    key: \"walkClassExpression\",\n    value: function walkClassExpression(expression) {\n      this.walkClass(expression);\n    }\n  }, {\n    key: \"_walkIIFE\",\n    value: function _walkIIFE(functionExpression, options, currentThis) {\n      var _this14 = this;\n\n      var renameArgOrThis = function renameArgOrThis(argOrThis) {\n        var renameIdentifier = _this14.getRenameIdentifier(argOrThis);\n\n        if (renameIdentifier) {\n          var hook = _this14.hooks.canRename.get(renameIdentifier);\n\n          if (hook !== undefined && hook.call(argOrThis)) {\n            var _hook6 = _this14.hooks.rename.get(renameIdentifier);\n\n            if (_hook6 === undefined || !_hook6.call(argOrThis)) {\n              return renameIdentifier;\n            }\n          }\n        }\n\n        _this14.walkExpression(argOrThis);\n      };\n\n      var params = functionExpression.params;\n      var renameThis = currentThis ? renameArgOrThis(currentThis) : null;\n      var args = options.map(renameArgOrThis);\n      var wasTopLevel = this.scope.topLevelScope;\n      this.scope.topLevelScope = false;\n      var scopeParams = params.filter(function (identifier, idx) {\n        return !args[idx];\n      }); // Add function name in scope for recursive calls\n\n      if (functionExpression.id) {\n        scopeParams.push(functionExpression.id.name);\n      }\n\n      this.inFunctionScope(true, scopeParams, function () {\n        if (renameThis) {\n          _this14.scope.renames.set(\"this\", renameThis);\n        }\n\n        for (var i = 0; i < args.length; i++) {\n          var param = args[i];\n          if (!param) continue;\n          if (!params[i] || params[i].type !== \"Identifier\") continue;\n\n          _this14.scope.renames.set(params[i].name, param);\n        }\n\n        if (functionExpression.body.type === \"BlockStatement\") {\n          _this14.detectMode(functionExpression.body.body);\n\n          _this14.prewalkStatement(functionExpression.body);\n\n          _this14.walkStatement(functionExpression.body);\n        } else {\n          _this14.walkExpression(functionExpression.body);\n        }\n      });\n      this.scope.topLevelScope = wasTopLevel;\n    }\n  }, {\n    key: \"walkCallExpression\",\n    value: function walkCallExpression(expression) {\n      if (expression.callee.type === \"MemberExpression\" && expression.callee.object.type === \"FunctionExpression\" && !expression.callee.computed && (expression.callee.property.name === \"call\" || expression.callee.property.name === \"bind\") && expression.arguments.length > 0) {\n        // (function(…) { }.call/bind(?, …))\n        this._walkIIFE(expression.callee.object, expression.arguments.slice(1), expression.arguments[0]);\n      } else if (expression.callee.type === \"FunctionExpression\") {\n        // (function(…) { }(…))\n        this._walkIIFE(expression.callee, expression.arguments, null);\n      } else if (expression.callee.type === \"Import\") {\n        var result = this.hooks.importCall.call(expression);\n        if (result === true) return;\n        if (expression.arguments) this.walkExpressions(expression.arguments);\n      } else {\n        var callee = this.evaluateExpression(expression.callee);\n\n        if (callee.isIdentifier()) {\n          var callHook = this.hooks.call.get(callee.identifier);\n\n          if (callHook !== undefined) {\n            var _result = callHook.call(expression);\n\n            if (_result === true) return;\n          }\n\n          var identifier = callee.identifier.replace(/\\.[^.]+$/, \"\");\n\n          if (identifier !== callee.identifier) {\n            var callAnyHook = this.hooks.callAnyMember.get(identifier);\n\n            if (callAnyHook !== undefined) {\n              var _result2 = callAnyHook.call(expression);\n\n              if (_result2 === true) return;\n            }\n          }\n        }\n\n        if (expression.callee) this.walkExpression(expression.callee);\n        if (expression.arguments) this.walkExpressions(expression.arguments);\n      }\n    }\n  }, {\n    key: \"walkMemberExpression\",\n    value: function walkMemberExpression(expression) {\n      var exprName = this.getNameForExpression(expression);\n\n      if (exprName && exprName.free) {\n        var expressionHook = this.hooks.expression.get(exprName.name);\n\n        if (expressionHook !== undefined) {\n          var result = expressionHook.call(expression);\n          if (result === true) return;\n        }\n\n        var expressionAnyMemberHook = this.hooks.expressionAnyMember.get(exprName.nameGeneral);\n\n        if (expressionAnyMemberHook !== undefined) {\n          var _result3 = expressionAnyMemberHook.call(expression);\n\n          if (_result3 === true) return;\n        }\n      }\n\n      this.walkExpression(expression.object);\n      if (expression.computed === true) this.walkExpression(expression.property);\n    }\n  }, {\n    key: \"walkThisExpression\",\n    value: function walkThisExpression(expression) {\n      var expressionHook = this.hooks.expression.get(\"this\");\n\n      if (expressionHook !== undefined) {\n        expressionHook.call(expression);\n      }\n    }\n  }, {\n    key: \"walkIdentifier\",\n    value: function walkIdentifier(expression) {\n      if (!this.scope.definitions.has(expression.name)) {\n        var hook = this.hooks.expression.get(this.scope.renames.get(expression.name) || expression.name);\n\n        if (hook !== undefined) {\n          var result = hook.call(expression);\n          if (result === true) return;\n        }\n      }\n    }\n    /**\n     * @deprecated\n     * @param {any} params scope params\n     * @param {function(): void} fn inner function\n     * @returns {void}\n     */\n\n  }, {\n    key: \"inScope\",\n    value: function inScope(params, fn) {\n      var _this15 = this;\n\n      var oldScope = this.scope;\n      this.scope = {\n        topLevelScope: oldScope.topLevelScope,\n        inTry: false,\n        inShorthand: false,\n        isStrict: oldScope.isStrict,\n        isAsmJs: oldScope.isAsmJs,\n        definitions: oldScope.definitions.createChild(),\n        renames: oldScope.renames.createChild()\n      };\n      this.scope.renames.set(\"this\", null);\n      this.enterPatterns(params, function (ident) {\n        _this15.scope.renames.set(ident, null);\n\n        _this15.scope.definitions.add(ident);\n      });\n      fn();\n      this.scope = oldScope;\n    }\n  }, {\n    key: \"inFunctionScope\",\n    value: function inFunctionScope(hasThis, params, fn) {\n      var _this16 = this;\n\n      var oldScope = this.scope;\n      this.scope = {\n        topLevelScope: oldScope.topLevelScope,\n        inTry: false,\n        inShorthand: false,\n        isStrict: oldScope.isStrict,\n        isAsmJs: oldScope.isAsmJs,\n        definitions: oldScope.definitions.createChild(),\n        renames: oldScope.renames.createChild()\n      };\n\n      if (hasThis) {\n        this.scope.renames.set(\"this\", null);\n      }\n\n      this.enterPatterns(params, function (ident) {\n        _this16.scope.renames.set(ident, null);\n\n        _this16.scope.definitions.add(ident);\n      });\n      fn();\n      this.scope = oldScope;\n    }\n  }, {\n    key: \"inBlockScope\",\n    value: function inBlockScope(fn) {\n      var oldScope = this.scope;\n      this.scope = {\n        topLevelScope: oldScope.topLevelScope,\n        inTry: oldScope.inTry,\n        inShorthand: false,\n        isStrict: oldScope.isStrict,\n        isAsmJs: oldScope.isAsmJs,\n        definitions: oldScope.definitions.createChild(),\n        renames: oldScope.renames.createChild()\n      };\n      fn();\n      this.scope = oldScope;\n    } // TODO webpack 5: remove this methods\n    // only for backward-compat\n\n  }, {\n    key: \"detectStrictMode\",\n    value: function detectStrictMode(statements) {\n      this.detectMode(statements);\n    }\n  }, {\n    key: \"detectMode\",\n    value: function detectMode(statements) {\n      var isLiteral = statements.length >= 1 && statements[0].type === \"ExpressionStatement\" && statements[0].expression.type === \"Literal\";\n\n      if (isLiteral && statements[0].expression.value === \"use strict\") {\n        this.scope.isStrict = true;\n      }\n\n      if (isLiteral && statements[0].expression.value === \"use asm\") {\n        this.scope.isAsmJs = true;\n      }\n    }\n  }, {\n    key: \"enterPatterns\",\n    value: function enterPatterns(patterns, onIdent) {\n      var _iterator10 = _createForOfIteratorHelper(patterns),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var pattern = _step10.value;\n\n          if (typeof pattern !== \"string\") {\n            this.enterPattern(pattern, onIdent);\n          } else if (pattern) {\n            onIdent(pattern);\n          }\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    }\n  }, {\n    key: \"enterPattern\",\n    value: function enterPattern(pattern, onIdent) {\n      if (!pattern) return;\n\n      switch (pattern.type) {\n        case \"ArrayPattern\":\n          this.enterArrayPattern(pattern, onIdent);\n          break;\n\n        case \"AssignmentPattern\":\n          this.enterAssignmentPattern(pattern, onIdent);\n          break;\n\n        case \"Identifier\":\n          this.enterIdentifier(pattern, onIdent);\n          break;\n\n        case \"ObjectPattern\":\n          this.enterObjectPattern(pattern, onIdent);\n          break;\n\n        case \"RestElement\":\n          this.enterRestElement(pattern, onIdent);\n          break;\n\n        case \"Property\":\n          this.enterPattern(pattern.value, onIdent);\n          break;\n      }\n    }\n  }, {\n    key: \"enterIdentifier\",\n    value: function enterIdentifier(pattern, onIdent) {\n      onIdent(pattern.name, pattern);\n    }\n  }, {\n    key: \"enterObjectPattern\",\n    value: function enterObjectPattern(pattern, onIdent) {\n      for (var propIndex = 0, len = pattern.properties.length; propIndex < len; propIndex++) {\n        var prop = pattern.properties[propIndex];\n        this.enterPattern(prop, onIdent);\n      }\n    }\n  }, {\n    key: \"enterArrayPattern\",\n    value: function enterArrayPattern(pattern, onIdent) {\n      for (var elementIndex = 0, len = pattern.elements.length; elementIndex < len; elementIndex++) {\n        var element = pattern.elements[elementIndex];\n        this.enterPattern(element, onIdent);\n      }\n    }\n  }, {\n    key: \"enterRestElement\",\n    value: function enterRestElement(pattern, onIdent) {\n      this.enterPattern(pattern.argument, onIdent);\n    }\n  }, {\n    key: \"enterAssignmentPattern\",\n    value: function enterAssignmentPattern(pattern, onIdent) {\n      this.enterPattern(pattern.left, onIdent);\n    }\n  }, {\n    key: \"evaluateExpression\",\n    value: function evaluateExpression(expression) {\n      try {\n        var hook = this.hooks.evaluate.get(expression.type);\n\n        if (hook !== undefined) {\n          var result = hook.call(expression);\n\n          if (result !== undefined) {\n            if (result) {\n              result.setExpression(expression);\n            }\n\n            return result;\n          }\n        }\n      } catch (e) {\n        console.warn(e); // ignore error\n      }\n\n      return new BasicEvaluatedExpression().setRange(expression.range).setExpression(expression);\n    }\n  }, {\n    key: \"parseString\",\n    value: function parseString(expression) {\n      switch (expression.type) {\n        case \"BinaryExpression\":\n          if (expression.operator === \"+\") {\n            return this.parseString(expression.left) + this.parseString(expression.right);\n          }\n\n          break;\n\n        case \"Literal\":\n          return expression.value + \"\";\n      }\n\n      throw new Error(expression.type + \" is not supported as parameter for require\");\n    }\n  }, {\n    key: \"parseCalculatedString\",\n    value: function parseCalculatedString(expression) {\n      switch (expression.type) {\n        case \"BinaryExpression\":\n          if (expression.operator === \"+\") {\n            var left = this.parseCalculatedString(expression.left);\n            var right = this.parseCalculatedString(expression.right);\n\n            if (left.code) {\n              return {\n                range: left.range,\n                value: left.value,\n                code: true,\n                conditional: false\n              };\n            } else if (right.code) {\n              return {\n                range: [left.range[0], right.range ? right.range[1] : left.range[1]],\n                value: left.value + right.value,\n                code: true,\n                conditional: false\n              };\n            } else {\n              return {\n                range: [left.range[0], right.range[1]],\n                value: left.value + right.value,\n                code: false,\n                conditional: false\n              };\n            }\n          }\n\n          break;\n\n        case \"ConditionalExpression\":\n          {\n            var consequent = this.parseCalculatedString(expression.consequent);\n            var alternate = this.parseCalculatedString(expression.alternate);\n            var items = [];\n\n            if (consequent.conditional) {\n              items.push.apply(items, _toConsumableArray(consequent.conditional));\n            } else if (!consequent.code) {\n              items.push(consequent);\n            } else {\n              break;\n            }\n\n            if (alternate.conditional) {\n              items.push.apply(items, _toConsumableArray(alternate.conditional));\n            } else if (!alternate.code) {\n              items.push(alternate);\n            } else {\n              break;\n            }\n\n            return {\n              range: undefined,\n              value: \"\",\n              code: true,\n              conditional: items\n            };\n          }\n\n        case \"Literal\":\n          return {\n            range: expression.range,\n            value: expression.value + \"\",\n            code: false,\n            conditional: false\n          };\n      }\n\n      return {\n        range: undefined,\n        value: \"\",\n        code: true,\n        conditional: false\n      };\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(source, initialState) {\n      var ast;\n      var comments;\n\n      if (_typeof(source) === \"object\" && source !== null) {\n        ast = source;\n        comments = source.comments;\n      } else {\n        comments = [];\n        ast = Parser.parse(source, {\n          sourceType: this.sourceType,\n          onComment: comments\n        });\n      }\n\n      var oldScope = this.scope;\n      var oldState = this.state;\n      var oldComments = this.comments;\n      this.scope = {\n        topLevelScope: true,\n        inTry: false,\n        inShorthand: false,\n        isStrict: false,\n        isAsmJs: false,\n        definitions: new StackedSetMap(),\n        renames: new StackedSetMap()\n      };\n      var state = this.state = initialState || {};\n      this.comments = comments;\n\n      if (this.hooks.program.call(ast, comments) === undefined) {\n        this.detectMode(ast.body);\n        this.prewalkStatements(ast.body);\n        this.blockPrewalkStatements(ast.body);\n        this.walkStatements(ast.body);\n      }\n\n      this.scope = oldScope;\n      this.state = oldState;\n      this.comments = oldComments;\n      return state;\n    }\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(source) {\n      var ast = Parser.parse(\"(\" + source + \")\", {\n        sourceType: this.sourceType,\n        locations: false\n      }); // TODO(https://github.com/acornjs/acorn/issues/741)\n      // @ts-ignore\n\n      if (ast.body.length !== 1 || ast.body[0].type !== \"ExpressionStatement\") {\n        throw new Error(\"evaluate: Source is not a expression\");\n      } // TODO(https://github.com/acornjs/acorn/issues/741)\n      // @ts-ignore\n\n\n      return this.evaluateExpression(ast.body[0].expression);\n    }\n  }, {\n    key: \"getComments\",\n    value: function getComments(range) {\n      return this.comments.filter(function (comment) {\n        return comment.range[0] >= range[0] && comment.range[1] <= range[1];\n      });\n    }\n  }, {\n    key: \"parseCommentOptions\",\n    value: function parseCommentOptions(range) {\n      var comments = this.getComments(range);\n\n      if (comments.length === 0) {\n        return EMPTY_COMMENT_OPTIONS;\n      }\n\n      var options = {};\n      var errors = [];\n\n      var _iterator11 = _createForOfIteratorHelper(comments),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var comment = _step11.value;\n          var value = comment.value;\n\n          if (value && webpackCommentRegExp.test(value)) {\n            // try compile only if webpack options comment is present\n            try {\n              var val = vm.runInNewContext(\"(function(){return {\".concat(value, \"};})()\"));\n              Object.assign(options, val);\n            } catch (e) {\n              e.comment = comment;\n              errors.push(e);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n\n      return {\n        options: options,\n        errors: errors\n      };\n    }\n  }, {\n    key: \"getNameForExpression\",\n    value: function getNameForExpression(expression) {\n      var expr = expression;\n      var exprName = [];\n\n      while (expr.type === \"MemberExpression\" && expr.property.type === (expr.computed ? \"Literal\" : \"Identifier\")) {\n        exprName.push(expr.computed ? expr.property.value : expr.property.name);\n        expr = expr.object;\n      }\n\n      var free;\n\n      if (expr.type === \"Identifier\") {\n        free = !this.scope.definitions.has(expr.name);\n        exprName.push(this.scope.renames.get(expr.name) || expr.name);\n      } else if (expr.type === \"ThisExpression\" && this.scope.renames.get(\"this\")) {\n        free = true;\n        exprName.push(this.scope.renames.get(\"this\"));\n      } else if (expr.type === \"ThisExpression\") {\n        free = this.scope.topLevelScope;\n        exprName.push(\"this\");\n      } else {\n        return null;\n      }\n\n      var prefix = \"\";\n\n      for (var i = exprName.length - 1; i >= 2; i--) {\n        prefix += exprName[i] + \".\";\n      }\n\n      if (exprName.length > 1) {\n        prefix += exprName[1];\n      }\n\n      var name = prefix ? prefix + \".\" + exprName[0] : exprName[0];\n      var nameGeneral = prefix;\n      return {\n        name: name,\n        nameGeneral: nameGeneral,\n        free: free\n      };\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(code, options) {\n      var type = options ? options.sourceType : \"module\";\n      var parserOptions = Object.assign(Object.create(null), defaultParserOptions, options);\n\n      if (type === \"auto\") {\n        parserOptions.sourceType = \"module\";\n      } else if (parserOptions.sourceType === \"script\") {\n        parserOptions.allowReturnOutsideFunction = true;\n      }\n\n      var ast;\n      var error;\n      var threw = false;\n\n      try {\n        ast = acornParser.parse(code, parserOptions);\n      } catch (e) {\n        error = e;\n        threw = true;\n      }\n\n      if (threw && type === \"auto\") {\n        parserOptions.sourceType = \"script\";\n        parserOptions.allowReturnOutsideFunction = true;\n\n        if (Array.isArray(parserOptions.onComment)) {\n          parserOptions.onComment.length = 0;\n        }\n\n        try {\n          ast = acornParser.parse(code, parserOptions);\n          threw = false;\n        } catch (e) {\n          threw = true;\n        }\n      }\n\n      if (threw) {\n        throw error;\n      }\n\n      return ast;\n    }\n  }]);\n\n  return Parser;\n}(Tapable); // TODO remove in webpack 5\n\n\nObject.defineProperty(Parser.prototype, \"getCommentOptions\", {\n  configurable: false,\n  value: util.deprecate(\n  /**\n   * @deprecated\n   * @param {TODO} range Range\n   * @returns {void}\n   * @this {Parser}\n   */\n  function (range) {\n    return this.parseCommentOptions(range).options;\n  }, \"Parser.getCommentOptions: Use Parser.parseCommentOptions(range) instead\")\n});\nmodule.exports = Parser;","map":null,"metadata":{},"sourceType":"module"}