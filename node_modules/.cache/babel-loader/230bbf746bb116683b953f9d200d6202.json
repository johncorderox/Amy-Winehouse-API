{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar EventEmitter = require(\"events\").EventEmitter;\n\nvar async = require(\"neo-async\");\n\nvar chokidar = require(\"./chokidar\");\n\nvar fs = require(\"graceful-fs\");\n\nvar path = require(\"path\");\n\nvar watcherManager = require(\"./watcherManager\");\n\nvar FS_ACCURACY = 1000;\n\nfunction withoutCase(str) {\n  return str.toLowerCase();\n}\n\nfunction Watcher(directoryWatcher, filePath, startTime) {\n  EventEmitter.call(this);\n  this.directoryWatcher = directoryWatcher;\n  this.path = filePath;\n  this.startTime = startTime && +startTime; // TODO this.data seem to be only read, weird\n\n  this.data = 0;\n}\n\nWatcher.prototype = Object.create(EventEmitter.prototype);\nWatcher.prototype.constructor = Watcher;\n\nWatcher.prototype.checkStartTime = function checkStartTime(mtime, initial) {\n  if (typeof this.startTime !== \"number\") return !initial;\n  var startTime = this.startTime;\n  return startTime <= mtime;\n};\n\nWatcher.prototype.close = function close() {\n  this.emit(\"closed\");\n};\n\nfunction DirectoryWatcher(directoryPath, options) {\n  EventEmitter.call(this);\n  this.options = options;\n  this.path = directoryPath;\n  this.files = Object.create(null);\n  this.directories = Object.create(null);\n  var interval = typeof options.poll === \"number\" ? options.poll : undefined;\n  this.watcher = chokidar.watch(directoryPath, {\n    ignoreInitial: true,\n    persistent: true,\n    followSymlinks: false,\n    depth: 0,\n    atomic: false,\n    alwaysStat: true,\n    ignorePermissionErrors: true,\n    ignored: options.ignored,\n    usePolling: options.poll ? true : undefined,\n    interval: interval,\n    binaryInterval: interval,\n    disableGlobbing: true\n  });\n  this.watcher.on(\"add\", this.onFileAdded.bind(this));\n  this.watcher.on(\"addDir\", this.onDirectoryAdded.bind(this));\n  this.watcher.on(\"change\", this.onChange.bind(this));\n  this.watcher.on(\"unlink\", this.onFileUnlinked.bind(this));\n  this.watcher.on(\"unlinkDir\", this.onDirectoryUnlinked.bind(this));\n  this.watcher.on(\"error\", this.onWatcherError.bind(this));\n  this.initialScan = true;\n  this.nestedWatching = false;\n  this.initialScanRemoved = [];\n  this.doInitialScan();\n  this.watchers = Object.create(null);\n  this.parentWatcher = null;\n  this.refs = 0;\n}\n\nmodule.exports = DirectoryWatcher;\nDirectoryWatcher.prototype = Object.create(EventEmitter.prototype);\nDirectoryWatcher.prototype.constructor = DirectoryWatcher;\n\nDirectoryWatcher.prototype.setFileTime = function setFileTime(filePath, mtime, initial, type) {\n  var now = Date.now();\n  var old = this.files[filePath];\n  this.files[filePath] = [initial ? Math.min(now, mtime) : now, mtime]; // we add the fs accuracy to reach the maximum possible mtime\n\n  if (mtime) mtime = mtime + FS_ACCURACY;\n\n  if (!old) {\n    if (mtime) {\n      if (this.watchers[withoutCase(filePath)]) {\n        this.watchers[withoutCase(filePath)].forEach(function (w) {\n          if (!initial || w.checkStartTime(mtime, initial)) {\n            w.emit(\"change\", mtime, initial ? \"initial\" : type);\n          }\n        });\n      }\n    }\n  } else if (!initial && mtime) {\n    if (this.watchers[withoutCase(filePath)]) {\n      this.watchers[withoutCase(filePath)].forEach(function (w) {\n        w.emit(\"change\", mtime, type);\n      });\n    }\n  } else if (!initial && !mtime) {\n    if (this.watchers[withoutCase(filePath)]) {\n      this.watchers[withoutCase(filePath)].forEach(function (w) {\n        w.emit(\"remove\", type);\n      });\n    }\n  }\n\n  if (this.watchers[withoutCase(this.path)]) {\n    this.watchers[withoutCase(this.path)].forEach(function (w) {\n      if (!initial || w.checkStartTime(mtime, initial)) {\n        w.emit(\"change\", filePath, mtime, initial ? \"initial\" : type);\n      }\n    });\n  }\n};\n\nDirectoryWatcher.prototype.setDirectory = function setDirectory(directoryPath, exist, initial, type) {\n  if (directoryPath === this.path) {\n    if (!initial && this.watchers[withoutCase(this.path)]) {\n      this.watchers[withoutCase(this.path)].forEach(function (w) {\n        w.emit(\"change\", directoryPath, w.data, initial ? \"initial\" : type);\n      });\n    }\n  } else {\n    var old = this.directories[directoryPath];\n\n    if (!old) {\n      if (exist) {\n        if (this.nestedWatching) {\n          this.createNestedWatcher(directoryPath);\n        } else {\n          this.directories[directoryPath] = true;\n        }\n\n        if (!initial && this.watchers[withoutCase(this.path)]) {\n          this.watchers[withoutCase(this.path)].forEach(function (w) {\n            w.emit(\"change\", directoryPath, w.data, initial ? \"initial\" : type);\n          });\n        }\n\n        if (this.watchers[withoutCase(directoryPath) + \"#directory\"]) {\n          this.watchers[withoutCase(directoryPath) + \"#directory\"].forEach(function (w) {\n            w.emit(\"change\", w.data, initial ? \"initial\" : type);\n          });\n        }\n      }\n    } else {\n      if (!exist) {\n        if (this.nestedWatching) this.directories[directoryPath].close();\n        delete this.directories[directoryPath];\n\n        if (!initial && this.watchers[withoutCase(this.path)]) {\n          this.watchers[withoutCase(this.path)].forEach(function (w) {\n            w.emit(\"change\", directoryPath, w.data, initial ? \"initial\" : type);\n          });\n        }\n\n        if (this.watchers[withoutCase(directoryPath) + \"#directory\"]) {\n          this.watchers[withoutCase(directoryPath) + \"#directory\"].forEach(function (w) {\n            w.emit(\"change\", directoryPath, w.data, initial ? \"initial\" : type);\n          });\n        }\n      }\n    }\n  }\n};\n\nDirectoryWatcher.prototype.createNestedWatcher = function (directoryPath) {\n  this.directories[directoryPath] = watcherManager.watchDirectory(directoryPath, this.options, 1);\n  this.directories[directoryPath].on(\"change\", function (filePath, mtime, type) {\n    if (this.watchers[withoutCase(this.path)]) {\n      this.watchers[withoutCase(this.path)].forEach(function (w) {\n        if (w.checkStartTime(mtime, false)) {\n          w.emit(\"change\", filePath, mtime, type);\n        }\n      });\n    }\n  }.bind(this));\n};\n\nDirectoryWatcher.prototype.setNestedWatching = function (flag) {\n  if (this.nestedWatching !== !!flag) {\n    this.nestedWatching = !!flag;\n\n    if (this.nestedWatching) {\n      Object.keys(this.directories).forEach(function (directory) {\n        this.createNestedWatcher(directory);\n      }, this);\n    } else {\n      Object.keys(this.directories).forEach(function (directory) {\n        this.directories[directory].close();\n        this.directories[directory] = true;\n      }, this);\n    }\n  }\n};\n\nDirectoryWatcher.prototype.watch = function watch(filePath, startTime) {\n  this.watchers[withoutCase(filePath)] = this.watchers[withoutCase(filePath)] || [];\n  this.refs++;\n  var watcher = new Watcher(this, filePath, startTime);\n  watcher.on(\"closed\", function () {\n    var idx = this.watchers[withoutCase(filePath)].indexOf(watcher);\n    this.watchers[withoutCase(filePath)].splice(idx, 1);\n\n    if (this.watchers[withoutCase(filePath)].length === 0) {\n      delete this.watchers[withoutCase(filePath)];\n      if (this.path === filePath) this.setNestedWatching(false);\n    }\n\n    if (--this.refs <= 0) this.close();\n  }.bind(this));\n  this.watchers[withoutCase(filePath)].push(watcher);\n  var data;\n\n  if (filePath === this.path) {\n    this.setNestedWatching(true);\n    data = false;\n    Object.keys(this.files).forEach(function (file) {\n      var d = this.files[file];\n      if (!data) data = d;else data = [Math.max(data[0], d[0]), Math.max(data[1], d[1])];\n    }, this);\n  } else {\n    data = this.files[filePath];\n  }\n\n  process.nextTick(function () {\n    if (data) {\n      var ts = data[0] === data[1] ? data[0] + FS_ACCURACY : data[0];\n      if (ts >= startTime) watcher.emit(\"change\", data[1]);\n    } else if (this.initialScan && this.initialScanRemoved.indexOf(filePath) >= 0) {\n      watcher.emit(\"remove\");\n    }\n  }.bind(this));\n  return watcher;\n};\n\nDirectoryWatcher.prototype.onFileAdded = function onFileAdded(filePath, stat) {\n  if (filePath.indexOf(this.path) !== 0) return;\n  if (/[\\\\\\/]/.test(filePath.substr(this.path.length + 1))) return;\n  this.setFileTime(filePath, +stat.mtime || +stat.ctime || 1, false, \"add\");\n};\n\nDirectoryWatcher.prototype.onDirectoryAdded = function onDirectoryAdded(directoryPath\n/*, stat */\n) {\n  if (directoryPath.indexOf(this.path) !== 0) return;\n  if (/[\\\\\\/]/.test(directoryPath.substr(this.path.length + 1))) return;\n  this.setDirectory(directoryPath, true, false, \"add\");\n};\n\nDirectoryWatcher.prototype.onChange = function onChange(filePath, stat) {\n  if (filePath.indexOf(this.path) !== 0) return;\n  if (/[\\\\\\/]/.test(filePath.substr(this.path.length + 1))) return;\n  var mtime = +stat.mtime || +stat.ctime || 1;\n  ensureFsAccuracy(mtime);\n  this.setFileTime(filePath, mtime, false, \"change\");\n};\n\nDirectoryWatcher.prototype.onFileUnlinked = function onFileUnlinked(filePath) {\n  if (filePath.indexOf(this.path) !== 0) return;\n  if (/[\\\\\\/]/.test(filePath.substr(this.path.length + 1))) return;\n  this.setFileTime(filePath, null, false, \"unlink\");\n\n  if (this.initialScan) {\n    this.initialScanRemoved.push(filePath);\n  }\n};\n\nDirectoryWatcher.prototype.onDirectoryUnlinked = function onDirectoryUnlinked(directoryPath) {\n  if (directoryPath.indexOf(this.path) !== 0) return;\n  if (/[\\\\\\/]/.test(directoryPath.substr(this.path.length + 1))) return;\n  this.setDirectory(directoryPath, false, false, \"unlink\");\n\n  if (this.initialScan) {\n    this.initialScanRemoved.push(directoryPath);\n  }\n};\n\nDirectoryWatcher.prototype.onWatcherError = function onWatcherError(err) {\n  console.warn(\"Error from chokidar (\" + this.path + \"): \" + err);\n};\n\nDirectoryWatcher.prototype.doInitialScan = function doInitialScan() {\n  fs.readdir(this.path, function (err, items) {\n    if (err) {\n      this.parentWatcher = watcherManager.watchFile(this.path + \"#directory\", this.options, 1);\n      this.parentWatcher.on(\"change\", function (mtime, type) {\n        if (this.watchers[withoutCase(this.path)]) {\n          this.watchers[withoutCase(this.path)].forEach(function (w) {\n            w.emit(\"change\", this.path, mtime, type);\n          }, this);\n        }\n      }.bind(this));\n      this.initialScan = false;\n      return;\n    }\n\n    async.forEach(items, function (item, callback) {\n      var itemPath = path.join(this.path, item);\n      fs.stat(itemPath, function (err2, stat) {\n        if (!this.initialScan) return;\n\n        if (err2) {\n          callback();\n          return;\n        }\n\n        if (stat.isFile()) {\n          if (!this.files[itemPath]) this.setFileTime(itemPath, +stat.mtime || +stat.ctime || 1, true);\n        } else if (stat.isDirectory()) {\n          if (!this.directories[itemPath]) this.setDirectory(itemPath, true, true);\n        }\n\n        callback();\n      }.bind(this));\n    }.bind(this), function () {\n      this.initialScan = false;\n      this.initialScanRemoved = null;\n    }.bind(this));\n  }.bind(this));\n};\n\nDirectoryWatcher.prototype.getTimes = function () {\n  var obj = Object.create(null);\n  var selfTime = 0;\n  Object.keys(this.files).forEach(function (file) {\n    var data = this.files[file];\n    var time;\n\n    if (data[1]) {\n      time = Math.max(data[0], data[1] + FS_ACCURACY);\n    } else {\n      time = data[0];\n    }\n\n    obj[file] = time;\n    if (time > selfTime) selfTime = time;\n  }, this);\n\n  if (this.nestedWatching) {\n    Object.keys(this.directories).forEach(function (dir) {\n      var w = this.directories[dir];\n      var times = w.directoryWatcher.getTimes();\n      Object.keys(times).forEach(function (file) {\n        var time = times[file];\n        obj[file] = time;\n        if (time > selfTime) selfTime = time;\n      });\n    }, this);\n    obj[this.path] = selfTime;\n  }\n\n  return obj;\n};\n\nDirectoryWatcher.prototype.close = function () {\n  this.initialScan = false;\n  var p = this.watcher.close();\n  if (p && p[\"catch\"]) p[\"catch\"](this.onWatcherError.bind(this));\n\n  if (this.nestedWatching) {\n    Object.keys(this.directories).forEach(function (dir) {\n      this.directories[dir].close();\n    }, this);\n  }\n\n  if (this.parentWatcher) this.parentWatcher.close();\n  this.emit(\"closed\");\n};\n\nfunction ensureFsAccuracy(mtime) {\n  if (!mtime) return;\n  if (FS_ACCURACY > 1 && mtime % 1 !== 0) FS_ACCURACY = 1;else if (FS_ACCURACY > 10 && mtime % 10 !== 0) FS_ACCURACY = 10;else if (FS_ACCURACY > 100 && mtime % 100 !== 0) FS_ACCURACY = 100;\n}","map":null,"metadata":{},"sourceType":"module"}