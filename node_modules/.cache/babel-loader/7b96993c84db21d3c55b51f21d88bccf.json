{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n/**\n * Gets the value at path of object\n * @param {object} obj object to query\n * @param {string} path query path\n * @returns {any} - if {@param path} requests element from array, then `undefined` will be returned\n */\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar getProperty = function getProperty(obj, path) {\n  var name = path.split(\".\");\n\n  for (var i = 0; i < name.length - 1; i++) {\n    obj = obj[name[i]];\n    if (_typeof(obj) !== \"object\" || !obj || Array.isArray(obj)) return;\n  }\n\n  return obj[name.pop()];\n};\n/**\n * Sets the value at path of object. Stops execution, if {@param path} requests element from array to be set\n * @param {object} obj object to query\n * @param {string} path query path\n * @param {any} value value to be set\n * @returns {void}\n */\n\n\nvar setProperty = function setProperty(obj, path, value) {\n  var name = path.split(\".\");\n\n  for (var i = 0; i < name.length - 1; i++) {\n    if (_typeof(obj[name[i]]) !== \"object\" && obj[name[i]] !== undefined) return;\n    if (Array.isArray(obj[name[i]])) return;\n    if (!obj[name[i]]) obj[name[i]] = {};\n    obj = obj[name[i]];\n  }\n\n  obj[name.pop()] = value;\n};\n/**\n * @typedef {'call' | 'make' | 'append'} ConfigType\n */\n\n/**\n * @typedef {(options: object) => any} MakeConfigHandler\n */\n\n/**\n * @typedef {(value: any, options: object) => any} CallConfigHandler\n */\n\n/**\n * @typedef {any[]} AppendConfigValues\n */\n\n\nvar OptionsDefaulter = /*#__PURE__*/function () {\n  function OptionsDefaulter() {\n    _classCallCheck(this, OptionsDefaulter);\n\n    /**\n     * Stores default options settings or functions for computing them\n     */\n    this.defaults = {};\n    /**\n     * Stores configuration for options\n     * @type {{[key: string]: ConfigType}}\n     */\n\n    this.config = {};\n  }\n  /**\n   * Enhancing {@param options} with default values\n   * @param {object} options provided options\n   * @returns {object} - enhanced options\n   * @throws {Error} - will throw error, if configuration value is other then `undefined` or {@link ConfigType}\n   */\n\n\n  _createClass(OptionsDefaulter, [{\n    key: \"process\",\n    value: function process(options) {\n      options = Object.assign({}, options);\n\n      for (var name in this.defaults) {\n        switch (this.config[name]) {\n          /**\n           * If {@link ConfigType} doesn't specified and current value is `undefined`, then default value will be assigned\n           */\n          case undefined:\n            if (getProperty(options, name) === undefined) {\n              setProperty(options, name, this.defaults[name]);\n            }\n\n            break;\n\n          /**\n           * Assign result of {@link CallConfigHandler}\n           */\n\n          case \"call\":\n            setProperty(options, name, this.defaults[name].call(this, getProperty(options, name), options));\n            break;\n\n          /**\n           * Assign result of {@link MakeConfigHandler}, if current value is `undefined`\n           */\n\n          case \"make\":\n            if (getProperty(options, name) === undefined) {\n              setProperty(options, name, this.defaults[name].call(this, options));\n            }\n\n            break;\n\n          /**\n           * Adding {@link AppendConfigValues} at the end of the current array\n           */\n\n          case \"append\":\n            {\n              var _oldValue;\n\n              var oldValue = getProperty(options, name);\n\n              if (!Array.isArray(oldValue)) {\n                oldValue = [];\n              }\n\n              (_oldValue = oldValue).push.apply(_oldValue, _toConsumableArray(this.defaults[name]));\n\n              setProperty(options, name, oldValue);\n              break;\n            }\n\n          default:\n            throw new Error(\"OptionsDefaulter cannot process \" + this.config[name]);\n        }\n      }\n\n      return options;\n    }\n    /**\n     * Builds up default values\n     * @param {string} name option path\n     * @param {ConfigType | any} config if {@param def} is provided, then only {@link ConfigType} is allowed\n     * @param {MakeConfigHandler | CallConfigHandler | AppendConfigValues} [def] defaults\n     * @returns {void}\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(name, config, def) {\n      if (def !== undefined) {\n        this.defaults[name] = def;\n        this.config[name] = config;\n      } else {\n        this.defaults[name] = config;\n        delete this.config[name];\n      }\n    }\n  }]);\n\n  return OptionsDefaulter;\n}();\n\nmodule.exports = OptionsDefaulter;","map":null,"metadata":{},"sourceType":"module"}