{"ast":null,"code":"/*\n MIT License http://www.opensource.org/licenses/mit-license.php\n Author Tobias Koppers @sokra\n */\n\"use strict\";\n/**\n * @param {any[]} args items to be truncated\n * @param {number} maxLength maximum length of args including spaces between\n * @returns {string[]} truncated args\n */\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar truncateArgs = function truncateArgs(args, maxLength) {\n  var lengths = args.map(function (a) {\n    return \"\".concat(a).length;\n  });\n  var availableLength = maxLength - lengths.length + 1;\n\n  if (availableLength > 0 && args.length === 1) {\n    if (availableLength >= args[0].length) {\n      return args;\n    } else if (availableLength > 3) {\n      return [\"...\" + args[0].slice(-availableLength + 3)];\n    } else {\n      return [args[0].slice(-availableLength)];\n    }\n  } // Check if there is space for at least 4 chars per arg\n\n\n  if (availableLength < lengths.reduce(function (s, i) {\n    return s + Math.min(i, 6);\n  }, 0)) {\n    // remove args\n    if (args.length > 1) return truncateArgs(args.slice(0, args.length - 1), maxLength);\n    return [];\n  }\n\n  var currentLength = lengths.reduce(function (a, b) {\n    return a + b;\n  }, 0); // Check if all fits into maxLength\n\n  if (currentLength <= availableLength) return args; // Try to remove chars from the longest items until it fits\n\n  var _loop = function _loop() {\n    var maxLength = Math.max.apply(Math, _toConsumableArray(lengths));\n    var shorterItems = lengths.filter(function (l) {\n      return l !== maxLength;\n    });\n    var nextToMaxLength = shorterItems.length > 0 ? Math.max.apply(Math, _toConsumableArray(shorterItems)) : 0;\n    var maxReduce = maxLength - nextToMaxLength;\n    var maxItems = lengths.length - shorterItems.length;\n    var overrun = currentLength - availableLength;\n\n    for (var i = 0; i < lengths.length; i++) {\n      if (lengths[i] === maxLength) {\n        var reduce = Math.min(Math.floor(overrun / maxItems), maxReduce);\n        lengths[i] -= reduce;\n        currentLength -= reduce;\n        overrun -= reduce;\n        maxItems--;\n      }\n    }\n  };\n\n  while (currentLength > availableLength) {\n    _loop();\n  } // Return args reduced to length in lengths\n\n\n  return args.map(function (a, i) {\n    var str = \"\".concat(a);\n    var length = lengths[i];\n\n    if (str.length === length) {\n      return str;\n    } else if (length > 5) {\n      return \"...\" + str.slice(-length + 3);\n    } else if (length > 0) {\n      return str.slice(-length);\n    } else {\n      return \"\";\n    }\n  });\n};\n\nmodule.exports = truncateArgs;","map":null,"metadata":{},"sourceType":"module"}