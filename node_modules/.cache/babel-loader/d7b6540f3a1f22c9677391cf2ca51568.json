{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./ModuleTemplate\")} ModuleTemplate */\n\n/** @typedef {import(\"webpack-sources\").ConcatSource} ConcatSource */\nvar _require = require(\"webpack-sources\"),\n    ConcatSource = _require.ConcatSource;\n\nvar HotUpdateChunk = require(\"./HotUpdateChunk\");\n\nvar START_LOWERCASE_ALPHABET_CODE = \"a\".charCodeAt(0);\nvar START_UPPERCASE_ALPHABET_CODE = \"A\".charCodeAt(0);\nvar DELTA_A_TO_Z = \"z\".charCodeAt(0) - START_LOWERCASE_ALPHABET_CODE + 1;\nvar FUNCTION_CONTENT_REGEX = /^function\\s?\\(\\)\\s?\\{\\r?\\n?|\\r?\\n?\\}$/g;\nvar INDENT_MULTILINE_REGEX = /^\\t/gm;\nvar LINE_SEPARATOR_REGEX = /\\r?\\n/g;\nvar IDENTIFIER_NAME_REPLACE_REGEX = /^([^a-zA-Z$_])/;\nvar IDENTIFIER_ALPHA_NUMERIC_NAME_REPLACE_REGEX = /[^a-zA-Z0-9$]+/g;\nvar COMMENT_END_REGEX = /\\*\\//g;\nvar PATH_NAME_NORMALIZE_REPLACE_REGEX = /[^a-zA-Z0-9_!§$()=\\-^°]+/g;\nvar MATCH_PADDED_HYPHENS_REPLACE_REGEX = /^-|-$/g;\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/**\n * @typedef {Object} HasId\n * @property {number | string} id\n */\n\n/**\n * @typedef {function(Module, number): boolean} ModuleFilterPredicate\n */\n\n/**\n * @param {HasId} a first id object to be sorted\n * @param {HasId} b second id object to be sorted against\n * @returns {-1|0|1} the sort value\n */\n\nvar stringifyIdSortPredicate = function stringifyIdSortPredicate(a, b) {\n  var aId = a.id + \"\";\n  var bId = b.id + \"\";\n  if (aId < bId) return -1;\n  if (aId > bId) return 1;\n  return 0;\n};\n\nvar Template = /*#__PURE__*/function () {\n  function Template() {\n    _classCallCheck(this, Template);\n  }\n\n  _createClass(Template, null, [{\n    key: \"getFunctionContent\",\n    value:\n    /**\n     *\n     * @param {Function} fn a runtime function (.runtime.js) \"template\"\n     * @returns {string} the updated and normalized function string\n     */\n    function getFunctionContent(fn) {\n      return fn.toString().replace(FUNCTION_CONTENT_REGEX, \"\").replace(INDENT_MULTILINE_REGEX, \"\").replace(LINE_SEPARATOR_REGEX, \"\\n\");\n    }\n    /**\n     * @param {string} str the string converted to identifier\n     * @returns {string} created identifier\n     */\n\n  }, {\n    key: \"toIdentifier\",\n    value: function toIdentifier(str) {\n      if (typeof str !== \"string\") return \"\";\n      return str.replace(IDENTIFIER_NAME_REPLACE_REGEX, \"_$1\").replace(IDENTIFIER_ALPHA_NUMERIC_NAME_REPLACE_REGEX, \"_\");\n    }\n    /**\n     *\n     * @param {string} str string to be converted to commented in bundle code\n     * @returns {string} returns a commented version of string\n     */\n\n  }, {\n    key: \"toComment\",\n    value: function toComment(str) {\n      if (!str) return \"\";\n      return \"/*! \".concat(str.replace(COMMENT_END_REGEX, \"* /\"), \" */\");\n    }\n    /**\n     *\n     * @param {string} str string to be converted to \"normal comment\"\n     * @returns {string} returns a commented version of string\n     */\n\n  }, {\n    key: \"toNormalComment\",\n    value: function toNormalComment(str) {\n      if (!str) return \"\";\n      return \"/* \".concat(str.replace(COMMENT_END_REGEX, \"* /\"), \" */\");\n    }\n    /**\n     * @param {string} str string path to be normalized\n     * @returns {string} normalized bundle-safe path\n     */\n\n  }, {\n    key: \"toPath\",\n    value: function toPath(str) {\n      if (typeof str !== \"string\") return \"\";\n      return str.replace(PATH_NAME_NORMALIZE_REPLACE_REGEX, \"-\").replace(MATCH_PADDED_HYPHENS_REPLACE_REGEX, \"\");\n    } // map number to a single character a-z, A-Z or <_ + number> if number is too big\n\n    /**\n     *\n     * @param {number} n number to convert to ident\n     * @returns {string} returns single character ident\n     */\n\n  }, {\n    key: \"numberToIdentifer\",\n    value: function numberToIdentifer(n) {\n      // lower case\n      if (n < DELTA_A_TO_Z) {\n        return String.fromCharCode(START_LOWERCASE_ALPHABET_CODE + n);\n      } // upper case\n\n\n      if (n < DELTA_A_TO_Z * 2) {\n        return String.fromCharCode(START_UPPERCASE_ALPHABET_CODE + n - DELTA_A_TO_Z);\n      } // use multiple letters\n\n\n      return Template.numberToIdentifer(n % (2 * DELTA_A_TO_Z)) + Template.numberToIdentifer(Math.floor(n / (2 * DELTA_A_TO_Z)));\n    }\n    /**\n     *\n     * @param {string | string[]} s string to convert to identity\n     * @returns {string} converted identity\n     */\n\n  }, {\n    key: \"indent\",\n    value: function indent(s) {\n      if (Array.isArray(s)) {\n        return s.map(Template.indent).join(\"\\n\");\n      } else {\n        var str = s.trimRight();\n        if (!str) return \"\";\n        var ind = str[0] === \"\\n\" ? \"\" : \"\\t\";\n        return ind + str.replace(/\\n([^\\n])/g, \"\\n\\t$1\");\n      }\n    }\n    /**\n     *\n     * @param {string|string[]} s string to create prefix for\n     * @param {string} prefix prefix to compose\n     * @returns {string} returns new prefix string\n     */\n\n  }, {\n    key: \"prefix\",\n    value: function prefix(s, _prefix) {\n      var str = Template.asString(s).trim();\n      if (!str) return \"\";\n      var ind = str[0] === \"\\n\" ? \"\" : _prefix;\n      return ind + str.replace(/\\n([^\\n])/g, \"\\n\" + _prefix + \"$1\");\n    }\n    /**\n     *\n     * @param {string|string[]} str string or string collection\n     * @returns {string} returns a single string from array\n     */\n\n  }, {\n    key: \"asString\",\n    value: function asString(str) {\n      if (Array.isArray(str)) {\n        return str.join(\"\\n\");\n      }\n\n      return str;\n    }\n    /**\n     * @typedef {Object} WithId\n     * @property {string|number} id\n     */\n\n    /**\n     * @param {WithId[]} modules a collection of modules to get array bounds for\n     * @returns {[number, number] | false} returns the upper and lower array bounds\n     * or false if not every module has a number based id\n     */\n\n  }, {\n    key: \"getModulesArrayBounds\",\n    value: function getModulesArrayBounds(modules) {\n      var maxId = -Infinity;\n      var minId = Infinity;\n\n      var _iterator = _createForOfIteratorHelper(modules),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _module = _step.value;\n          if (typeof _module.id !== \"number\") return false;\n          if (maxId < _module.id) maxId =\n          /** @type {number} */\n          _module.id;\n          if (minId > _module.id) minId =\n          /** @type {number} */\n          _module.id;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (minId < 16 + (\"\" + minId).length) {\n        // add minId x ',' instead of 'Array(minId).concat(…)'\n        minId = 0;\n      }\n\n      var objectOverhead = modules.map(function (module) {\n        return (module.id + \"\").length + 2;\n      }).reduce(function (a, b) {\n        return a + b;\n      }, -1);\n      var arrayOverhead = minId === 0 ? maxId : 16 + (\"\" + minId).length + maxId;\n      return arrayOverhead < objectOverhead ? [minId, maxId] : false;\n    }\n    /**\n     * @param {Chunk} chunk chunk whose modules will be rendered\n     * @param {ModuleFilterPredicate} filterFn function used to filter modules from chunk to render\n     * @param {ModuleTemplate} moduleTemplate ModuleTemplate instance used to render modules\n     * @param {TODO | TODO[]} dependencyTemplates templates needed for each module to render dependencies\n     * @param {string=} prefix applying prefix strings\n     * @returns {ConcatSource} rendered chunk modules in a Source object\n     */\n\n  }, {\n    key: \"renderChunkModules\",\n    value: function renderChunkModules(chunk, filterFn, moduleTemplate, dependencyTemplates) {\n      var prefix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"\";\n      var source = new ConcatSource();\n      var modules = chunk.getModules().filter(filterFn);\n      var removedModules;\n\n      if (chunk instanceof HotUpdateChunk) {\n        removedModules = chunk.removedModules;\n      }\n\n      if (modules.length === 0 && (!removedModules || removedModules.length === 0)) {\n        source.add(\"[]\");\n        return source;\n      }\n      /** @type {{id: string|number, source: Source|string}[]} */\n\n\n      var allModules = modules.map(function (module) {\n        return {\n          id: module.id,\n          source: moduleTemplate.render(module, dependencyTemplates, {\n            chunk: chunk\n          })\n        };\n      });\n\n      if (removedModules && removedModules.length > 0) {\n        var _iterator2 = _createForOfIteratorHelper(removedModules),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var id = _step2.value;\n            allModules.push({\n              id: id,\n              source: \"false\"\n            });\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      var bounds = Template.getModulesArrayBounds(allModules);\n\n      if (bounds) {\n        // Render a spare array\n        var minId = bounds[0];\n        var maxId = bounds[1];\n\n        if (minId !== 0) {\n          source.add(\"Array(\".concat(minId, \").concat(\"));\n        }\n\n        source.add(\"[\\n\");\n        /** @type {Map<string|number, {id: string|number, source: Source|string}>} */\n\n        var _modules = new Map();\n\n        var _iterator3 = _createForOfIteratorHelper(allModules),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _module3 = _step3.value;\n\n            _modules.set(_module3.id, _module3);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        for (var idx = minId; idx <= maxId; idx++) {\n          var _module2 = _modules.get(idx);\n\n          if (idx !== minId) {\n            source.add(\",\\n\");\n          }\n\n          source.add(\"/* \".concat(idx, \" */\"));\n\n          if (_module2) {\n            source.add(\"\\n\");\n            source.add(_module2.source);\n          }\n        }\n\n        source.add(\"\\n\" + prefix + \"]\");\n\n        if (minId !== 0) {\n          source.add(\")\");\n        }\n      } else {\n        // Render an object\n        source.add(\"{\\n\");\n        allModules.sort(stringifyIdSortPredicate).forEach(function (module, idx) {\n          if (idx !== 0) {\n            source.add(\",\\n\");\n          }\n\n          source.add(\"\\n/***/ \".concat(JSON.stringify(module.id), \":\\n\"));\n          source.add(module.source);\n        });\n        source.add(\"\\n\\n\".concat(prefix, \"}\"));\n      }\n\n      return source;\n    }\n  }]);\n\n  return Template;\n}();\n\nmodule.exports = Template;","map":null,"metadata":{},"sourceType":"module"}