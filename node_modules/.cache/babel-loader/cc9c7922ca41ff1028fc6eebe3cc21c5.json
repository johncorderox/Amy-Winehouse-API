{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar _require = require(\"tapable\"),\n    Tapable = _require.Tapable,\n    SyncHook = _require.SyncHook,\n    MultiHook = _require.MultiHook;\n\nvar asyncLib = require(\"neo-async\");\n\nvar MultiWatching = require(\"./MultiWatching\");\n\nvar MultiStats = require(\"./MultiStats\");\n\nvar ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\n\nmodule.exports = /*#__PURE__*/function (_Tapable) {\n  _inherits(MultiCompiler, _Tapable);\n\n  var _super = _createSuper(MultiCompiler);\n\n  function MultiCompiler(compilers) {\n    var _this;\n\n    _classCallCheck(this, MultiCompiler);\n\n    _this = _super.call(this);\n    _this.hooks = {\n      done: new SyncHook([\"stats\"]),\n      invalid: new MultiHook(compilers.map(function (c) {\n        return c.hooks.invalid;\n      })),\n      run: new MultiHook(compilers.map(function (c) {\n        return c.hooks.run;\n      })),\n      watchClose: new SyncHook([]),\n      watchRun: new MultiHook(compilers.map(function (c) {\n        return c.hooks.watchRun;\n      })),\n      infrastructureLog: new MultiHook(compilers.map(function (c) {\n        return c.hooks.infrastructureLog;\n      }))\n    };\n\n    if (!Array.isArray(compilers)) {\n      compilers = Object.keys(compilers).map(function (name) {\n        compilers[name].name = name;\n        return compilers[name];\n      });\n    }\n\n    _this.compilers = compilers;\n    var doneCompilers = 0;\n    var compilerStats = [];\n    var index = 0;\n\n    var _iterator = _createForOfIteratorHelper(_this.compilers),\n        _step;\n\n    try {\n      var _loop = function _loop() {\n        var compiler = _step.value;\n        var compilerDone = false;\n        var compilerIndex = index++; // eslint-disable-next-line no-loop-func\n\n        compiler.hooks.done.tap(\"MultiCompiler\", function (stats) {\n          if (!compilerDone) {\n            compilerDone = true;\n            doneCompilers++;\n          }\n\n          compilerStats[compilerIndex] = stats;\n\n          if (doneCompilers === _this.compilers.length) {\n            _this.hooks.done.call(new MultiStats(compilerStats));\n          }\n        }); // eslint-disable-next-line no-loop-func\n\n        compiler.hooks.invalid.tap(\"MultiCompiler\", function () {\n          if (compilerDone) {\n            compilerDone = false;\n            doneCompilers--;\n          }\n        });\n      };\n\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        _loop();\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    _this.running = false;\n    return _this;\n  }\n\n  _createClass(MultiCompiler, [{\n    key: \"outputPath\",\n    get: function get() {\n      var commonPath = this.compilers[0].outputPath;\n\n      var _iterator2 = _createForOfIteratorHelper(this.compilers),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var compiler = _step2.value;\n\n          while (compiler.outputPath.indexOf(commonPath) !== 0 && /[/\\\\]/.test(commonPath)) {\n            commonPath = commonPath.replace(/[/\\\\][^/\\\\]*$/, \"\");\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      if (!commonPath && this.compilers[0].outputPath[0] === \"/\") return \"/\";\n      return commonPath;\n    }\n  }, {\n    key: \"inputFileSystem\",\n    get: function get() {\n      throw new Error(\"Cannot read inputFileSystem of a MultiCompiler\");\n    },\n    set: function set(value) {\n      var _iterator3 = _createForOfIteratorHelper(this.compilers),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var compiler = _step3.value;\n          compiler.inputFileSystem = value;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"outputFileSystem\",\n    get: function get() {\n      throw new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n    },\n    set: function set(value) {\n      var _iterator4 = _createForOfIteratorHelper(this.compilers),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var compiler = _step4.value;\n          compiler.outputFileSystem = value;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }, {\n    key: \"getInfrastructureLogger\",\n    value: function getInfrastructureLogger(name) {\n      return this.compilers[0].getInfrastructureLogger(name);\n    }\n  }, {\n    key: \"validateDependencies\",\n    value: function validateDependencies(callback) {\n      var _this2 = this;\n\n      var edges = new Set();\n      var missing = [];\n\n      var targetFound = function targetFound(compiler) {\n        var _iterator5 = _createForOfIteratorHelper(edges),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var edge = _step5.value;\n\n            if (edge.target === compiler) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n\n        return false;\n      };\n\n      var sortEdges = function sortEdges(e1, e2) {\n        return e1.source.name.localeCompare(e2.source.name) || e1.target.name.localeCompare(e2.target.name);\n      };\n\n      var _iterator6 = _createForOfIteratorHelper(this.compilers),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var source = _step6.value;\n\n          if (source.dependencies) {\n            var _iterator8 = _createForOfIteratorHelper(source.dependencies),\n                _step8;\n\n            try {\n              var _loop2 = function _loop2() {\n                var dep = _step8.value;\n\n                var target = _this2.compilers.find(function (c) {\n                  return c.name === dep;\n                });\n\n                if (!target) {\n                  missing.push(dep);\n                } else {\n                  edges.add({\n                    source: source,\n                    target: target\n                  });\n                }\n              };\n\n              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                _loop2();\n              }\n            } catch (err) {\n              _iterator8.e(err);\n            } finally {\n              _iterator8.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      var errors = missing.map(function (m) {\n        return \"Compiler dependency `\".concat(m, \"` not found.\");\n      });\n      var stack = this.compilers.filter(function (c) {\n        return !targetFound(c);\n      });\n\n      while (stack.length > 0) {\n        var current = stack.pop();\n\n        var _iterator7 = _createForOfIteratorHelper(edges),\n            _step7;\n\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var edge = _step7.value;\n\n            if (edge.source === current) {\n              edges[\"delete\"](edge);\n              var target = edge.target;\n\n              if (!targetFound(target)) {\n                stack.push(target);\n              }\n            }\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n      }\n\n      if (edges.size > 0) {\n        var lines = Array.from(edges).sort(sortEdges).map(function (edge) {\n          return \"\".concat(edge.source.name, \" -> \").concat(edge.target.name);\n        });\n        lines.unshift(\"Circular dependency found in compiler dependencies.\");\n        errors.unshift(lines.join(\"\\n\"));\n      }\n\n      if (errors.length > 0) {\n        var message = errors.join(\"\\n\");\n        callback(new Error(message));\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"runWithDependencies\",\n    value: function runWithDependencies(compilers, fn, callback) {\n      var fulfilledNames = new Set();\n      var remainingCompilers = compilers;\n\n      var isDependencyFulfilled = function isDependencyFulfilled(d) {\n        return fulfilledNames.has(d);\n      };\n\n      var getReadyCompilers = function getReadyCompilers() {\n        var readyCompilers = [];\n        var list = remainingCompilers;\n        remainingCompilers = [];\n\n        var _iterator9 = _createForOfIteratorHelper(list),\n            _step9;\n\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var c = _step9.value;\n            var ready = !c.dependencies || c.dependencies.every(isDependencyFulfilled);\n\n            if (ready) {\n              readyCompilers.push(c);\n            } else {\n              remainingCompilers.push(c);\n            }\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n\n        return readyCompilers;\n      };\n\n      var runCompilers = function runCompilers(callback) {\n        if (remainingCompilers.length === 0) return callback();\n        asyncLib.map(getReadyCompilers(), function (compiler, callback) {\n          fn(compiler, function (err) {\n            if (err) return callback(err);\n            fulfilledNames.add(compiler.name);\n            runCompilers(callback);\n          });\n        }, callback);\n      };\n\n      runCompilers(callback);\n    }\n  }, {\n    key: \"watch\",\n    value: function watch(watchOptions, handler) {\n      var _this3 = this;\n\n      if (this.running) return handler(new ConcurrentCompilationError());\n      var watchings = [];\n      var allStats = this.compilers.map(function () {\n        return null;\n      });\n      var compilerStatus = this.compilers.map(function () {\n        return false;\n      });\n\n      if (this.validateDependencies(handler)) {\n        this.running = true;\n        this.runWithDependencies(this.compilers, function (compiler, callback) {\n          var compilerIdx = _this3.compilers.indexOf(compiler);\n\n          var firstRun = true;\n          var watching = compiler.watch(Array.isArray(watchOptions) ? watchOptions[compilerIdx] : watchOptions, function (err, stats) {\n            if (err) handler(err);\n\n            if (stats) {\n              allStats[compilerIdx] = stats;\n              compilerStatus[compilerIdx] = \"new\";\n\n              if (compilerStatus.every(Boolean)) {\n                var freshStats = allStats.filter(function (s, idx) {\n                  return compilerStatus[idx] === \"new\";\n                });\n                compilerStatus.fill(true);\n                var multiStats = new MultiStats(freshStats);\n                handler(null, multiStats);\n              }\n            }\n\n            if (firstRun && !err) {\n              firstRun = false;\n              callback();\n            }\n          });\n          watchings.push(watching);\n        }, function () {// ignore\n        });\n      }\n\n      return new MultiWatching(watchings, this);\n    }\n  }, {\n    key: \"run\",\n    value: function run(callback) {\n      var _this4 = this;\n\n      if (this.running) {\n        return callback(new ConcurrentCompilationError());\n      }\n\n      var finalCallback = function finalCallback(err, stats) {\n        _this4.running = false;\n\n        if (callback !== undefined) {\n          return callback(err, stats);\n        }\n      };\n\n      var allStats = this.compilers.map(function () {\n        return null;\n      });\n\n      if (this.validateDependencies(callback)) {\n        this.running = true;\n        this.runWithDependencies(this.compilers, function (compiler, callback) {\n          var compilerIdx = _this4.compilers.indexOf(compiler);\n\n          compiler.run(function (err, stats) {\n            if (err) {\n              return callback(err);\n            }\n\n            allStats[compilerIdx] = stats;\n            callback();\n          });\n        }, function (err) {\n          if (err) {\n            return finalCallback(err);\n          }\n\n          finalCallback(null, new MultiStats(allStats));\n        });\n      }\n    }\n  }, {\n    key: \"purgeInputFileSystem\",\n    value: function purgeInputFileSystem() {\n      var _iterator10 = _createForOfIteratorHelper(this.compilers),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var compiler = _step10.value;\n\n          if (compiler.inputFileSystem && compiler.inputFileSystem.purge) {\n            compiler.inputFileSystem.purge();\n          }\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    }\n  }]);\n\n  return MultiCompiler;\n}(Tapable);","map":null,"metadata":{},"sourceType":"module"}