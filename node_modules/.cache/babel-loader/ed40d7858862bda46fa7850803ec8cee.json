{"ast":null,"code":"// Copyright 2012 The Obvious Corporation.\n\n/*\n * leb: LEB128 utilities.\n */\n\n/*\n * Modules used\n */\n\"use strict\";\n\nimport Long from \"@xtuc/long\";\nimport * as bits from \"./bits\";\nimport * as bufs from \"./bufs\";\n/*\n * Module variables\n */\n\n/** The minimum possible 32-bit signed int. */\n\nvar MIN_INT32 = -0x80000000;\n/** The maximum possible 32-bit signed int. */\n\nvar MAX_INT32 = 0x7fffffff;\n/** The maximum possible 32-bit unsigned int. */\n\nvar MAX_UINT32 = 0xffffffff;\n/** The minimum possible 64-bit signed int. */\n// const MIN_INT64 = -0x8000000000000000;\n\n/**\n * The maximum possible 64-bit signed int that is representable as a\n * JavaScript number.\n */\n// const MAX_INT64 = 0x7ffffffffffffc00;\n\n/**\n * The maximum possible 64-bit unsigned int that is representable as a\n * JavaScript number.\n */\n// const MAX_UINT64 = 0xfffffffffffff800;\n\n/*\n * Helper functions\n */\n\n/**\n * Determines the number of bits required to encode the number\n * represented in the given buffer as a signed value. The buffer is\n * taken to represent a signed number in little-endian form.\n *\n * The number of bits to encode is the (zero-based) bit number of the\n * highest-order non-sign-matching bit, plus two. For example:\n *\n *   11111011 01110101\n *   high          low\n *\n * The sign bit here is 1 (that is, it's a negative number). The highest\n * bit number that doesn't match the sign is bit #10 (where the lowest-order\n * bit is bit #0). So, we have to encode at least 12 bits total.\n *\n * As a special degenerate case, the numbers 0 and -1 each require just one bit.\n */\n\nfunction signedBitCount(buffer) {\n  return bits.highOrder(bits.getSign(buffer) ^ 1, buffer) + 2;\n}\n/**\n * Determines the number of bits required to encode the number\n * represented in the given buffer as an unsigned value. The buffer is\n * taken to represent an unsigned number in little-endian form.\n *\n * The number of bits to encode is the (zero-based) bit number of the\n * highest-order 1 bit, plus one. For example:\n *\n *   00011000 01010011\n *   high          low\n *\n * The highest-order 1 bit here is bit #12 (where the lowest-order bit\n * is bit #0). So, we have to encode at least 13 bits total.\n *\n * As a special degenerate case, the number 0 requires 1 bit.\n */\n\n\nfunction unsignedBitCount(buffer) {\n  var result = bits.highOrder(1, buffer) + 1;\n  return result ? result : 1;\n}\n/**\n * Common encoder for both signed and unsigned ints. This takes a\n * bigint-ish buffer, returning an LEB128-encoded buffer.\n */\n\n\nfunction encodeBufferCommon(buffer, signed) {\n  var signBit;\n  var bitCount;\n\n  if (signed) {\n    signBit = bits.getSign(buffer);\n    bitCount = signedBitCount(buffer);\n  } else {\n    signBit = 0;\n    bitCount = unsignedBitCount(buffer);\n  }\n\n  var byteCount = Math.ceil(bitCount / 7);\n  var result = bufs.alloc(byteCount);\n\n  for (var i = 0; i < byteCount; i++) {\n    var payload = bits.extract(buffer, i * 7, 7, signBit);\n    result[i] = payload | 0x80;\n  } // Mask off the top bit of the last byte, to indicate the end of the\n  // encoding.\n\n\n  result[byteCount - 1] &= 0x7f;\n  return result;\n}\n/**\n * Gets the byte-length of the value encoded in the given buffer at\n * the given index.\n */\n\n\nfunction encodedLength(encodedBuffer, index) {\n  var result = 0;\n\n  while (encodedBuffer[index + result] >= 0x80) {\n    result++;\n  }\n\n  result++; // to account for the last byte\n\n  if (index + result > encodedBuffer.length) {// FIXME(sven): seems to cause false positives\n    // throw new Error(\"integer representation too long\");\n  }\n\n  return result;\n}\n/**\n * Common decoder for both signed and unsigned ints. This takes an\n * LEB128-encoded buffer, returning a bigint-ish buffer.\n */\n\n\nfunction decodeBufferCommon(encodedBuffer, index, signed) {\n  index = index === undefined ? 0 : index;\n  var length = encodedLength(encodedBuffer, index);\n  var bitLength = length * 7;\n  var byteLength = Math.ceil(bitLength / 8);\n  var result = bufs.alloc(byteLength);\n  var outIndex = 0;\n\n  while (length > 0) {\n    bits.inject(result, outIndex, 7, encodedBuffer[index]);\n    outIndex += 7;\n    index++;\n    length--;\n  }\n\n  var signBit;\n  var signByte;\n\n  if (signed) {\n    // Sign-extend the last byte.\n    var lastByte = result[byteLength - 1];\n    var endBit = outIndex % 8;\n\n    if (endBit !== 0) {\n      var shift = 32 - endBit; // 32 because JS bit ops work on 32-bit ints.\n\n      lastByte = result[byteLength - 1] = lastByte << shift >> shift & 0xff;\n    }\n\n    signBit = lastByte >> 7;\n    signByte = signBit * 0xff;\n  } else {\n    signBit = 0;\n    signByte = 0;\n  } // Slice off any superfluous bytes, that is, ones that add no meaningful\n  // bits (because the value would be the same if they were removed).\n\n\n  while (byteLength > 1 && result[byteLength - 1] === signByte && (!signed || result[byteLength - 2] >> 7 === signBit)) {\n    byteLength--;\n  }\n\n  result = bufs.resize(result, byteLength);\n  return {\n    value: result,\n    nextIndex: index\n  };\n}\n/*\n * Exported bindings\n */\n\n\nfunction encodeIntBuffer(buffer) {\n  return encodeBufferCommon(buffer, true);\n}\n\nfunction decodeIntBuffer(encodedBuffer, index) {\n  return decodeBufferCommon(encodedBuffer, index, true);\n}\n\nfunction encodeInt32(num) {\n  var buf = bufs.alloc(4);\n  buf.writeInt32LE(num, 0);\n  var result = encodeIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeInt32(encodedBuffer, index) {\n  var result = decodeIntBuffer(encodedBuffer, index);\n  var parsed = bufs.readInt(result.value);\n  var value = parsed.value;\n  bufs.free(result.value);\n\n  if (value < MIN_INT32 || value > MAX_INT32) {\n    throw new Error(\"integer too large\");\n  }\n\n  return {\n    value: value,\n    nextIndex: result.nextIndex\n  };\n}\n\nfunction encodeInt64(num) {\n  var buf = bufs.alloc(8);\n  bufs.writeInt64(num, buf);\n  var result = encodeIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeInt64(encodedBuffer, index) {\n  var result = decodeIntBuffer(encodedBuffer, index);\n  var value = Long.fromBytesLE(result.value, false);\n  bufs.free(result.value);\n  return {\n    value: value,\n    nextIndex: result.nextIndex,\n    lossy: false\n  };\n}\n\nfunction encodeUIntBuffer(buffer) {\n  return encodeBufferCommon(buffer, false);\n}\n\nfunction decodeUIntBuffer(encodedBuffer, index) {\n  return decodeBufferCommon(encodedBuffer, index, false);\n}\n\nfunction encodeUInt32(num) {\n  var buf = bufs.alloc(4);\n  buf.writeUInt32LE(num, 0);\n  var result = encodeUIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeUInt32(encodedBuffer, index) {\n  var result = decodeUIntBuffer(encodedBuffer, index);\n  var parsed = bufs.readUInt(result.value);\n  var value = parsed.value;\n  bufs.free(result.value);\n\n  if (value > MAX_UINT32) {\n    throw new Error(\"integer too large\");\n  }\n\n  return {\n    value: value,\n    nextIndex: result.nextIndex\n  };\n}\n\nfunction encodeUInt64(num) {\n  var buf = bufs.alloc(8);\n  bufs.writeUInt64(num, buf);\n  var result = encodeUIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeUInt64(encodedBuffer, index) {\n  var result = decodeUIntBuffer(encodedBuffer, index);\n  var value = Long.fromBytesLE(result.value, true);\n  bufs.free(result.value);\n  return {\n    value: value,\n    nextIndex: result.nextIndex,\n    lossy: false\n  };\n}\n\nexport default {\n  decodeInt32: decodeInt32,\n  decodeInt64: decodeInt64,\n  decodeIntBuffer: decodeIntBuffer,\n  decodeUInt32: decodeUInt32,\n  decodeUInt64: decodeUInt64,\n  decodeUIntBuffer: decodeUIntBuffer,\n  encodeInt32: encodeInt32,\n  encodeInt64: encodeInt64,\n  encodeIntBuffer: encodeIntBuffer,\n  encodeUInt32: encodeUInt32,\n  encodeUInt64: encodeUInt64,\n  encodeUIntBuffer: encodeUIntBuffer\n};","map":null,"metadata":{},"sourceType":"module"}