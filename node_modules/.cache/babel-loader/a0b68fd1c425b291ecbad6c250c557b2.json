{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar _require = require(\"tapable\"),\n    SyncBailHook = _require.SyncBailHook;\n\nvar _require2 = require(\"webpack-sources\"),\n    RawSource = _require2.RawSource;\n\nvar Template = require(\"./Template\");\n\nvar ModuleHotAcceptDependency = require(\"./dependencies/ModuleHotAcceptDependency\");\n\nvar ModuleHotDeclineDependency = require(\"./dependencies/ModuleHotDeclineDependency\");\n\nvar ConstDependency = require(\"./dependencies/ConstDependency\");\n\nvar NullFactory = require(\"./NullFactory\");\n\nvar ParserHelpers = require(\"./ParserHelpers\");\n\nmodule.exports = /*#__PURE__*/function () {\n  function HotModuleReplacementPlugin(options) {\n    _classCallCheck(this, HotModuleReplacementPlugin);\n\n    this.options = options || {};\n    this.multiStep = this.options.multiStep;\n    this.fullBuildTimeout = this.options.fullBuildTimeout || 200;\n    this.requestTimeout = this.options.requestTimeout || 10000;\n  }\n\n  _createClass(HotModuleReplacementPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var multiStep = this.multiStep;\n      var fullBuildTimeout = this.fullBuildTimeout;\n      var requestTimeout = this.requestTimeout;\n      var hotUpdateChunkFilename = compiler.options.output.hotUpdateChunkFilename;\n      var hotUpdateMainFilename = compiler.options.output.hotUpdateMainFilename;\n      compiler.hooks.additionalPass.tapAsync(\"HotModuleReplacementPlugin\", function (callback) {\n        if (multiStep) return setTimeout(callback, fullBuildTimeout);\n        return callback();\n      });\n\n      var addParserPlugins = function addParserPlugins(parser, parserOptions) {\n        parser.hooks.expression[\"for\"](\"__webpack_hash__\").tap(\"HotModuleReplacementPlugin\", ParserHelpers.toConstantDependencyWithWebpackRequire(parser, \"__webpack_require__.h()\"));\n        parser.hooks.evaluateTypeof[\"for\"](\"__webpack_hash__\").tap(\"HotModuleReplacementPlugin\", ParserHelpers.evaluateToString(\"string\"));\n        parser.hooks.evaluateIdentifier[\"for\"](\"module.hot\").tap({\n          name: \"HotModuleReplacementPlugin\",\n          before: \"NodeStuffPlugin\"\n        }, function (expr) {\n          return ParserHelpers.evaluateToIdentifier(\"module.hot\", !!parser.state.compilation.hotUpdateChunkTemplate)(expr);\n        }); // TODO webpack 5: refactor this, no custom hooks\n\n        if (!parser.hooks.hotAcceptCallback) {\n          parser.hooks.hotAcceptCallback = new SyncBailHook([\"expression\", \"requests\"]);\n        }\n\n        if (!parser.hooks.hotAcceptWithoutCallback) {\n          parser.hooks.hotAcceptWithoutCallback = new SyncBailHook([\"expression\", \"requests\"]);\n        }\n\n        parser.hooks.call[\"for\"](\"module.hot.accept\").tap(\"HotModuleReplacementPlugin\", function (expr) {\n          if (!parser.state.compilation.hotUpdateChunkTemplate) {\n            return false;\n          }\n\n          if (expr.arguments.length >= 1) {\n            var arg = parser.evaluateExpression(expr.arguments[0]);\n            var params = [];\n            var requests = [];\n\n            if (arg.isString()) {\n              params = [arg];\n            } else if (arg.isArray()) {\n              params = arg.items.filter(function (param) {\n                return param.isString();\n              });\n            }\n\n            if (params.length > 0) {\n              params.forEach(function (param, idx) {\n                var request = param.string;\n                var dep = new ModuleHotAcceptDependency(request, param.range);\n                dep.optional = true;\n                dep.loc = Object.create(expr.loc);\n                dep.loc.index = idx;\n                parser.state.module.addDependency(dep);\n                requests.push(request);\n              });\n\n              if (expr.arguments.length > 1) {\n                parser.hooks.hotAcceptCallback.call(expr.arguments[1], requests);\n                parser.walkExpression(expr.arguments[1]); // other args are ignored\n\n                return true;\n              } else {\n                parser.hooks.hotAcceptWithoutCallback.call(expr, requests);\n                return true;\n              }\n            }\n          }\n        });\n        parser.hooks.call[\"for\"](\"module.hot.decline\").tap(\"HotModuleReplacementPlugin\", function (expr) {\n          if (!parser.state.compilation.hotUpdateChunkTemplate) {\n            return false;\n          }\n\n          if (expr.arguments.length === 1) {\n            var arg = parser.evaluateExpression(expr.arguments[0]);\n            var params = [];\n\n            if (arg.isString()) {\n              params = [arg];\n            } else if (arg.isArray()) {\n              params = arg.items.filter(function (param) {\n                return param.isString();\n              });\n            }\n\n            params.forEach(function (param, idx) {\n              var dep = new ModuleHotDeclineDependency(param.string, param.range);\n              dep.optional = true;\n              dep.loc = Object.create(expr.loc);\n              dep.loc.index = idx;\n              parser.state.module.addDependency(dep);\n            });\n          }\n        });\n        parser.hooks.expression[\"for\"](\"module.hot\").tap(\"HotModuleReplacementPlugin\", ParserHelpers.skipTraversal);\n      };\n\n      compiler.hooks.compilation.tap(\"HotModuleReplacementPlugin\", function (compilation, _ref) {\n        var normalModuleFactory = _ref.normalModuleFactory;\n        // This applies the HMR plugin only to the targeted compiler\n        // It should not affect child compilations\n        if (compilation.compiler !== compiler) return;\n        var hotUpdateChunkTemplate = compilation.hotUpdateChunkTemplate;\n        if (!hotUpdateChunkTemplate) return;\n        compilation.dependencyFactories.set(ConstDependency, new NullFactory());\n        compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());\n        compilation.dependencyFactories.set(ModuleHotAcceptDependency, normalModuleFactory);\n        compilation.dependencyTemplates.set(ModuleHotAcceptDependency, new ModuleHotAcceptDependency.Template());\n        compilation.dependencyFactories.set(ModuleHotDeclineDependency, normalModuleFactory);\n        compilation.dependencyTemplates.set(ModuleHotDeclineDependency, new ModuleHotDeclineDependency.Template());\n        compilation.hooks.record.tap(\"HotModuleReplacementPlugin\", function (compilation, records) {\n          if (records.hash === compilation.hash) return;\n          records.hash = compilation.hash;\n          records.moduleHashs = {};\n\n          var _iterator = _createForOfIteratorHelper(compilation.modules),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _module = _step.value;\n\n              var identifier = _module.identifier();\n\n              records.moduleHashs[identifier] = _module.hash;\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          records.chunkHashs = {};\n\n          var _iterator2 = _createForOfIteratorHelper(compilation.chunks),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var chunk = _step2.value;\n              records.chunkHashs[chunk.id] = chunk.hash;\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n\n          records.chunkModuleIds = {};\n\n          var _iterator3 = _createForOfIteratorHelper(compilation.chunks),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _chunk = _step3.value;\n              records.chunkModuleIds[_chunk.id] = Array.from(_chunk.modulesIterable, function (m) {\n                return m.id;\n              });\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        });\n        var initialPass = false;\n        var recompilation = false;\n        compilation.hooks.afterHash.tap(\"HotModuleReplacementPlugin\", function () {\n          var records = compilation.records;\n\n          if (!records) {\n            initialPass = true;\n            return;\n          }\n\n          if (!records.hash) initialPass = true;\n          var preHash = records.preHash || \"x\";\n          var prepreHash = records.prepreHash || \"x\";\n\n          if (preHash === compilation.hash) {\n            recompilation = true;\n            compilation.modifyHash(prepreHash);\n            return;\n          }\n\n          records.prepreHash = records.hash || \"x\";\n          records.preHash = compilation.hash;\n          compilation.modifyHash(records.prepreHash);\n        });\n        compilation.hooks.shouldGenerateChunkAssets.tap(\"HotModuleReplacementPlugin\", function () {\n          if (multiStep && !recompilation && !initialPass) return false;\n        });\n        compilation.hooks.needAdditionalPass.tap(\"HotModuleReplacementPlugin\", function () {\n          if (multiStep && !recompilation && !initialPass) return true;\n        });\n        compilation.hooks.additionalChunkAssets.tap(\"HotModuleReplacementPlugin\", function () {\n          var records = compilation.records;\n          if (records.hash === compilation.hash) return;\n          if (!records.moduleHashs || !records.chunkHashs || !records.chunkModuleIds) return;\n\n          var _iterator4 = _createForOfIteratorHelper(compilation.modules),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _module3 = _step4.value;\n\n              var identifier = _module3.identifier();\n\n              var hash = _module3.hash;\n              _module3.hotUpdate = records.moduleHashs[identifier] !== hash;\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n\n          var hotUpdateMainContent = {\n            h: compilation.hash,\n            c: {}\n          };\n\n          var _loop = function _loop() {\n            var key = _Object$keys[_i];\n            var chunkId = isNaN(+key) ? key : +key;\n            var currentChunk = compilation.chunks.find(function (chunk) {\n              return \"\".concat(chunk.id) === key;\n            });\n\n            if (currentChunk) {\n              var newModules = currentChunk.getModules().filter(function (module) {\n                return module.hotUpdate;\n              });\n              var allModules = new Set();\n\n              var _iterator5 = _createForOfIteratorHelper(currentChunk.modulesIterable),\n                  _step5;\n\n              try {\n                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                  var _module2 = _step5.value;\n                  allModules.add(_module2.id);\n                }\n              } catch (err) {\n                _iterator5.e(err);\n              } finally {\n                _iterator5.f();\n              }\n\n              var removedModules = records.chunkModuleIds[chunkId].filter(function (id) {\n                return !allModules.has(id);\n              });\n\n              if (newModules.length > 0 || removedModules.length > 0) {\n                var _source = hotUpdateChunkTemplate.render(chunkId, newModules, removedModules, compilation.hash, compilation.moduleTemplates.javascript, compilation.dependencyTemplates);\n\n                var _compilation$getPathW = compilation.getPathWithInfo(hotUpdateChunkFilename, {\n                  hash: records.hash,\n                  chunk: currentChunk\n                }),\n                    _filename = _compilation$getPathW.path,\n                    _assetInfo = _compilation$getPathW.info;\n\n                compilation.additionalChunkAssets.push(_filename);\n                compilation.emitAsset(_filename, _source, Object.assign({\n                  hotModuleReplacement: true\n                }, _assetInfo));\n                hotUpdateMainContent.c[chunkId] = true;\n                currentChunk.files.push(_filename);\n                compilation.hooks.chunkAsset.call(currentChunk, _filename);\n              }\n            } else {\n              hotUpdateMainContent.c[chunkId] = false;\n            }\n          };\n\n          for (var _i = 0, _Object$keys = Object.keys(records.chunkHashs); _i < _Object$keys.length; _i++) {\n            _loop();\n          }\n\n          var source = new RawSource(JSON.stringify(hotUpdateMainContent));\n\n          var _compilation$getPathW2 = compilation.getPathWithInfo(hotUpdateMainFilename, {\n            hash: records.hash\n          }),\n              filename = _compilation$getPathW2.path,\n              assetInfo = _compilation$getPathW2.info;\n\n          compilation.emitAsset(filename, source, Object.assign({\n            hotModuleReplacement: true\n          }, assetInfo));\n        });\n        var mainTemplate = compilation.mainTemplate;\n        mainTemplate.hooks.hash.tap(\"HotModuleReplacementPlugin\", function (hash) {\n          hash.update(\"HotMainTemplateDecorator\");\n        });\n        mainTemplate.hooks.moduleRequire.tap(\"HotModuleReplacementPlugin\", function (_, chunk, hash, varModuleId) {\n          return \"hotCreateRequire(\".concat(varModuleId, \")\");\n        });\n        mainTemplate.hooks.requireExtensions.tap(\"HotModuleReplacementPlugin\", function (source) {\n          var buf = [source];\n          buf.push(\"\");\n          buf.push(\"// __webpack_hash__\");\n          buf.push(mainTemplate.requireFn + \".h = function() { return hotCurrentHash; };\");\n          return Template.asString(buf);\n        });\n\n        var needChunkLoadingCode = function needChunkLoadingCode(chunk) {\n          var _iterator6 = _createForOfIteratorHelper(chunk.groupsIterable),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var chunkGroup = _step6.value;\n              if (chunkGroup.chunks.length > 1) return true;\n              if (chunkGroup.getNumberOfChildren() > 0) return true;\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n\n          return false;\n        };\n\n        mainTemplate.hooks.bootstrap.tap(\"HotModuleReplacementPlugin\", function (source, chunk, hash) {\n          source = mainTemplate.hooks.hotBootstrap.call(source, chunk, hash);\n          return Template.asString([source, \"\", hotInitCode.replace(/\\$require\\$/g, mainTemplate.requireFn).replace(/\\$hash\\$/g, JSON.stringify(hash)).replace(/\\$requestTimeout\\$/g, requestTimeout).replace(/\\/\\*foreachInstalledChunks\\*\\//g, needChunkLoadingCode(chunk) ? \"for(var chunkId in installedChunks)\" : \"var chunkId = \".concat(JSON.stringify(chunk.id), \";\"))]);\n        });\n        mainTemplate.hooks.globalHash.tap(\"HotModuleReplacementPlugin\", function () {\n          return true;\n        });\n        mainTemplate.hooks.currentHash.tap(\"HotModuleReplacementPlugin\", function (_, length) {\n          if (isFinite(length)) {\n            return \"hotCurrentHash.substr(0, \".concat(length, \")\");\n          } else {\n            return \"hotCurrentHash\";\n          }\n        });\n        mainTemplate.hooks.moduleObj.tap(\"HotModuleReplacementPlugin\", function (source, chunk, hash, varModuleId) {\n          return Template.asString([\"\".concat(source, \",\"), \"hot: hotCreateModule(\".concat(varModuleId, \"),\"), \"parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),\", \"children: []\"]);\n        }); // TODO add HMR support for javascript/esm\n\n        normalModuleFactory.hooks.parser[\"for\"](\"javascript/auto\").tap(\"HotModuleReplacementPlugin\", addParserPlugins);\n        normalModuleFactory.hooks.parser[\"for\"](\"javascript/dynamic\").tap(\"HotModuleReplacementPlugin\", addParserPlugins);\n        compilation.hooks.normalModuleLoader.tap(\"HotModuleReplacementPlugin\", function (context) {\n          context.hot = true;\n        });\n      });\n    }\n  }]);\n\n  return HotModuleReplacementPlugin;\n}();\n\nvar hotInitCode = Template.getFunctionContent(require(\"./HotModuleReplacement.runtime\"));","map":null,"metadata":{},"sourceType":"module"}