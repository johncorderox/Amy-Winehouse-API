{"ast":null,"code":"'use strict';\n\nmodule.exports = move;\n\nvar nodeFs = require('fs');\n\nvar rimraf = require('rimraf');\n\nvar validate = require('aproba');\n\nvar copy = require('copy-concurrently');\n\nvar RunQueue = require('run-queue');\n\nvar extend = Object.assign || require('util')._extend;\n\nfunction promisify(Promise, fn) {\n  return function () {\n    var args = [].slice.call(arguments);\n    return new Promise(function (resolve, reject) {\n      return fn.apply(null, args.concat(function (err, value) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(value);\n        }\n      }));\n    });\n  };\n}\n\nfunction move(from, to, opts) {\n  validate('SSO|SS', arguments);\n  opts = extend({}, opts || {});\n  var Promise = opts.Promise || global.Promise;\n  var fs = opts.fs || nodeFs;\n  var rimrafAsync = promisify(Promise, rimraf);\n  var renameAsync = promisify(Promise, fs.rename);\n  opts.top = from;\n  var queue = new RunQueue({\n    maxConcurrency: opts.maxConcurrency,\n    Promise: Promise\n  });\n  opts.queue = queue;\n  opts.recurseWith = rename;\n  queue.add(0, rename, [from, to, opts]);\n  return queue.run().then(function () {\n    return remove(from);\n  }, function (err) {\n    // if the target already exists don't clobber it\n    if (err.code === 'EEXIST' || err.code === 'EPERM') {\n      return passThroughError();\n    } else {\n      return remove(to).then(passThroughError, passThroughError);\n    }\n\n    function passThroughError() {\n      return Promise.reject(err);\n    }\n  });\n\n  function remove(target) {\n    var opts = {\n      unlink: fs.unlink,\n      chmod: fs.chmod,\n      stat: fs.stat,\n      lstat: fs.lstat,\n      rmdir: fs.rmdir,\n      readdir: fs.readdir,\n      glob: false\n    };\n    return rimrafAsync(target, opts);\n  }\n\n  function rename(from, to, opts, done) {\n    return renameAsync(from, to)[\"catch\"](function (err) {\n      if (err.code !== 'EXDEV') {\n        return Promise.reject(err);\n      } else {\n        return remove(to).then(function () {\n          return copy.item(from, to, opts);\n        });\n      }\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"module"}