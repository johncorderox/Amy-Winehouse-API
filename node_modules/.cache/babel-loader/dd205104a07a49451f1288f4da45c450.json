{"ast":null,"code":"import * as encoder from \"./encoder\";\nexport function encodeNode(n) {\n  switch (n.type) {\n    case \"ModuleImport\":\n      // $FlowIgnore: ModuleImport ensure that the node is well formated\n      return encoder.encodeModuleImport(n);\n\n    case \"SectionMetadata\":\n      // $FlowIgnore: SectionMetadata ensure that the node is well formated\n      return encoder.encodeSectionMetadata(n);\n\n    case \"CallInstruction\":\n      // $FlowIgnore: SectionMetadata ensure that the node is well formated\n      return encoder.encodeCallInstruction(n);\n\n    case \"CallIndirectInstruction\":\n      // $FlowIgnore: SectionMetadata ensure that the node is well formated\n      return encoder.encodeCallIndirectInstruction(n);\n\n    case \"TypeInstruction\":\n      return encoder.encodeTypeInstruction(n);\n\n    case \"Instr\":\n      // $FlowIgnore\n      return encoder.encodeInstr(n);\n\n    case \"ModuleExport\":\n      // $FlowIgnore: SectionMetadata ensure that the node is well formated\n      return encoder.encodeModuleExport(n);\n\n    case \"Global\":\n      // $FlowIgnore\n      return encoder.encodeGlobal(n);\n\n    case \"Func\":\n      return encoder.encodeFuncBody(n);\n\n    case \"IndexInFuncSection\":\n      return encoder.encodeIndexInFuncSection(n);\n\n    case \"StringLiteral\":\n      return encoder.encodeStringLiteral(n);\n\n    case \"Elem\":\n      return encoder.encodeElem(n);\n\n    default:\n      throw new Error(\"Unsupported encoding for node of type: \" + JSON.stringify(n.type));\n  }\n}\nexport var encodeU32 = encoder.encodeU32;","map":null,"metadata":{},"sourceType":"module"}