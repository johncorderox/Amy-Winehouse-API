{"ast":null,"code":"'use strict';\n\nmodule.exports = copy;\nmodule.exports.item = copyItem;\nmodule.exports.recurse = recurseDir;\nmodule.exports.symlink = copySymlink;\nmodule.exports.file = copyFile;\n\nvar nodeFs = require('fs');\n\nvar path = require('path');\n\nvar validate = require('aproba');\n\nvar stockWriteStreamAtomic = require('fs-write-stream-atomic');\n\nvar mkdirp = require('mkdirp');\n\nvar rimraf = require('rimraf');\n\nvar isWindows = require('./is-windows');\n\nvar RunQueue = require('run-queue');\n\nvar extend = Object.assign || require('util')._extend;\n\nfunction promisify(Promise, fn) {\n  return function () {\n    var args = [].slice.call(arguments);\n    return new Promise(function (resolve, reject) {\n      return fn.apply(null, args.concat(function (err, value) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(value);\n        }\n      }));\n    });\n  };\n}\n\nfunction copy(from, to, opts) {\n  validate('SSO|SS', arguments);\n  opts = extend({}, opts || {});\n  var Promise = opts.Promise || global.Promise;\n  var fs = opts.fs || nodeFs;\n  if (opts.isWindows == null) opts.isWindows = isWindows;\n  if (!opts.Promise) opts.Promise = Promise;\n  if (!opts.fs) opts.fs = fs;\n  if (!opts.recurseWith) opts.recurseWith = copyItem;\n  if (!opts.lstat) opts.lstat = promisify(opts.Promise, fs.lstat);\n  if (!opts.stat) opts.stat = promisify(opts.Promise, fs.stat);\n  if (!opts.chown) opts.chown = promisify(opts.Promise, fs.chown);\n  if (!opts.readdir) opts.readdir = promisify(opts.Promise, fs.readdir);\n  if (!opts.readlink) opts.readlink = promisify(opts.Promise, fs.readlink);\n  if (!opts.symlink) opts.symlink = promisify(opts.Promise, fs.symlink);\n  if (!opts.chmod) opts.chmod = promisify(opts.Promise, fs.chmod);\n  opts.top = from;\n  opts.mkdirpAsync = promisify(opts.Promise, mkdirp);\n  var rimrafAsync = promisify(opts.Promise, rimraf);\n  var queue = new RunQueue({\n    maxConcurrency: opts.maxConcurrency,\n    Promise: Promise\n  });\n  opts.queue = queue;\n  queue.add(0, copyItem, [from, to, opts]);\n  return queue.run()[\"catch\"](function (err) {\n    // if the target already exists don't clobber it\n    if (err.code === 'EEXIST' || err.code === 'EPERM') {\n      return passThroughError();\n    } else {\n      return remove(to).then(passThroughError, passThroughError);\n    }\n\n    function passThroughError() {\n      return Promise.reject(err);\n    }\n  });\n\n  function remove(target) {\n    var opts = {\n      unlink: fs.unlink,\n      chmod: fs.chmod,\n      stat: fs.stat,\n      lstat: fs.lstat,\n      rmdir: fs.rmdir,\n      readdir: fs.readdir,\n      glob: false\n    };\n    return rimrafAsync(target, opts);\n  }\n}\n\nfunction copyItem(from, to, opts) {\n  validate('SSO', [from, to, opts]);\n  var fs = opts.fs || nodeFs;\n  var Promise = opts.Promise || global.Promise;\n  var lstat = opts.lstat || promisify(Promise, fs.lstat);\n  return lstat(to).then(function () {\n    return Promise.reject(eexists(from, to));\n  }, function (err) {\n    if (err && err.code !== 'ENOENT') return Promise.reject(err);\n    return lstat(from);\n  }).then(function (fromStat) {\n    var cmdOpts = extend(extend({}, opts), fromStat);\n\n    if (fromStat.isDirectory()) {\n      return recurseDir(from, to, cmdOpts);\n    } else if (fromStat.isSymbolicLink()) {\n      opts.queue.add(1, copySymlink, [from, to, cmdOpts]);\n    } else if (fromStat.isFile()) {\n      return copyFile(from, to, cmdOpts);\n    } else if (fromStat.isBlockDevice()) {\n      return Promise.reject(eunsupported(from + \" is a block device, and we don't know how to copy those.\"));\n    } else if (fromStat.isCharacterDevice()) {\n      return Promise.reject(eunsupported(from + \" is a character device, and we don't know how to copy those.\"));\n    } else if (fromStat.isFIFO()) {\n      return Promise.reject(eunsupported(from + \" is a FIFO, and we don't know how to copy those.\"));\n    } else if (fromStat.isSocket()) {\n      return Promise.reject(eunsupported(from + \" is a socket, and we don't know how to copy those.\"));\n    } else {\n      return Promise.reject(eunsupported(\"We can't tell what \" + from + \" is and so we can't copy it.\"));\n    }\n  });\n}\n\nfunction recurseDir(from, to, opts) {\n  validate('SSO', [from, to, opts]);\n  var recurseWith = opts.recurseWith || copyItem;\n  var fs = opts.fs || nodeFs;\n  var chown = opts.chown || promisify(Promise, fs.chown);\n  var readdir = opts.readdir || promisify(Promise, fs.readdir);\n  var mkdirpAsync = opts.mkdirpAsync || promisify(Promise, mkdirp);\n  return mkdirpAsync(to, {\n    fs: fs,\n    mode: opts.mode\n  }).then(function () {\n    var getuid = opts.getuid || process.getuid;\n\n    if (getuid && opts.uid != null && getuid() === 0) {\n      return chown(to, opts.uid, opts.gid);\n    }\n  }).then(function () {\n    return readdir(from);\n  }).then(function (files) {\n    files.forEach(function (file) {\n      opts.queue.add(0, recurseWith, [path.join(from, file), path.join(to, file), opts]);\n    });\n  });\n}\n\nfunction copySymlink(from, to, opts) {\n  validate('SSO', [from, to, opts]);\n  var fs = opts.fs || nodeFs;\n  var readlink = opts.readlink || promisify(Promise, fs.readlink);\n  var stat = opts.stat || promisify(Promise, fs.symlink);\n  var symlink = opts.symlink || promisify(Promise, fs.symlink);\n  var Promise = opts.Promise || global.Promise;\n  return readlink(from).then(function (fromDest) {\n    var absoluteDest = path.resolve(path.dirname(from), fromDest); // Treat absolute paths that are inside the tree we're\n    // copying as relative. This necessary to properly support junctions\n    // on windows (which are always absolute) but is also DWIM with symlinks.\n\n    var relativeDest = path.relative(opts.top, absoluteDest);\n    var linkFrom = relativeDest.substr(0, 2) === '..' ? fromDest : path.relative(path.dirname(from), absoluteDest);\n\n    if (opts.isWindows) {\n      return stat(absoluteDest)[\"catch\"](function () {\n        return null;\n      }).then(function (destStat) {\n        var isDir = destStat && destStat.isDirectory();\n        var type = isDir ? 'dir' : 'file';\n        return symlink(linkFrom, to, type)[\"catch\"](function (err) {\n          if (type === 'dir') {\n            return symlink(linkFrom, to, 'junction');\n          } else {\n            return Promise.reject(err);\n          }\n        });\n      });\n    } else {\n      return symlink(linkFrom, to);\n    }\n  });\n}\n\nfunction copyFile(from, to, opts) {\n  validate('SSO', [from, to, opts]);\n  var fs = opts.fs || nodeFs;\n  var writeStreamAtomic = opts.writeStreamAtomic || stockWriteStreamAtomic;\n  var Promise = opts.Promise || global.Promise;\n  var chmod = opts.chmod || promisify(Promise, fs.chmod);\n  var writeOpts = {};\n  var getuid = opts.getuid || process.getuid;\n\n  if (getuid && opts.uid != null && getuid() === 0) {\n    writeOpts.chown = {\n      uid: opts.uid,\n      gid: opts.gid\n    };\n  }\n\n  return new Promise(function (resolve, reject) {\n    var errored = false;\n\n    function onError(err) {\n      errored = true;\n      reject(err);\n    }\n\n    fs.createReadStream(from).once('error', onError).pipe(writeStreamAtomic(to, writeOpts)).once('error', onError).once('close', function () {\n      if (errored) return;\n\n      if (opts.mode != null) {\n        resolve(chmod(to, opts.mode));\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nfunction eexists(from, to) {\n  var err = new Error('Could not move ' + from + ' to ' + to + ': destination already exists.');\n  err.code = 'EEXIST';\n  return err;\n}\n\nfunction eunsupported(msg) {\n  var err = new Error(msg);\n  err.code = 'EUNSUPPORTED';\n  return err;\n}","map":null,"metadata":{},"sourceType":"module"}